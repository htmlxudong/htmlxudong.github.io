var Wd = (t) => {
  throw TypeError(t);
};
var Zd = (t, e, n) => e.has(t) || Wd("Cannot " + n);
var pi = (t, e, n) => (Zd(t, e, "read from private field"), n ? n.call(t) : e.get(t)), Kd = (t, e, n) => e.has(t) ? Wd("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), Gd = (t, e, n, r) => (Zd(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
import { ref as U, defineComponent as ve, provide as nr, markRaw as xh, reactive as Ct, h as Rr, render as qd, shallowRef as E4, onMounted as di, onBeforeUnmount as $a, getCurrentInstance as kh, watchEffect as x4, nextTick as Sh, unref as se, customRef as Mh, inject as rc, createVNode as k, resolveComponent as ce, createBlock as ye, openBlock as B, withCtx as R, createElementVNode as E, normalizeClass as lt, resolveDynamicComponent as js, toDisplayString as ft, createElementBlock as he, computed as Ge, normalizeStyle as or, renderSlot as Vi, useCssVars as k4, Fragment as Ye, renderList as bt, createTextVNode as Ae, createCommentVNode as it, mergeProps as Qd, withDirectives as za, isRef as S4, toRefs as M4, toValue as Xe, watch as Oh, getCurrentScope as O4, onScopeDispose as T4, useTemplateRef as L4, withKeys as N4, vShow as ic, Teleport as A4, onUnmounted as Th, Transition as R4 } from "vue";
function kt(t) {
  this.content = t;
}
kt.prototype = {
  constructor: kt,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), o = r.content.slice();
    return i == -1 ? o.push(n || t, e) : (o[i + 1] = e, n && (o[i] = n)), new kt(o);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new kt(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new kt([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new kt(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), o = r.find(t);
    return i.splice(o == -1 ? i.length : o, 0, e, n), new kt(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = kt.from(t), t.size ? new kt(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = kt.from(t), t.size ? new kt(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = kt.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
kt.from = function(t) {
  if (t instanceof kt) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new kt(e);
};
function Lh(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), o = e.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let s = Lh(i.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += i.nodeSize;
  }
}
function Nh(t, e, n, r) {
  for (let i = t.childCount, o = e.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let s = t.child(--i), a = e.child(--o), l = s.nodeSize;
    if (s == a) {
      n -= l, r -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let c = 0, d = Math.min(s.text.length, a.text.length);
      for (; c < d && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let c = Nh(s.content, a.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
class A {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], c = a + l.nodeSize;
      if (c > e && r(l, i + a, o || null, s) !== !1 && l.content.size) {
        let d = a + 1;
        l.nodesBetween(Math.max(0, e - d), Math.min(l.content.size, n - d), r, i + d);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let o = "", s = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (s ? s = !1 : o += r), o += c;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < e.content.length; o++)
      i.push(e.content[o]);
    return new A(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], l = s + a.nodeSize;
        l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), i += a.nodeSize), s = l;
      }
    return new A(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? A.empty : e == 0 && n == this.content.length ? this : new A(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new A(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new A([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new A(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return Lh(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return Nh(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return is(0, e);
    if (e == this.size)
      return is(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let o = this.child(r), s = i + o.nodeSize;
      if (s >= e)
        return s == e || n > 0 ? is(r + 1, s) : is(r, i);
      i = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return A.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new A(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return A.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      r += o.nodeSize, i && o.isText && e[i - 1].sameMarkup(o) ? (n || (n = e.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new A(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return A.empty;
    if (e instanceof A)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new A([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
A.empty = new A([], 0);
const gl = { index: 0, offset: 0 };
function is(t, e) {
  return gl.index = t, gl.offset = e, gl;
}
function Ws(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!Ws(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !Ws(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let $e = class u1 {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        n || (n = e.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return e;
        !r && o.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Ws(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return u1.none;
    if (e instanceof u1)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
$e.none = [];
class Zs extends Error {
}
class F {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = Rh(this.content, e + this.openStart, n);
    return r && new F(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new F(Ah(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return F.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new F(A.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new F(e, r, i);
  }
}
F.empty = new F(A.empty, 0, 0);
function Ah(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), o = t.maybeChild(r), { index: s, offset: a } = t.findIndex(n);
  if (i == e || o.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, o.copy(Ah(o.content, e - i - 1, n - i - 1)));
}
function Rh(t, e, n, r) {
  let { index: i, offset: o } = t.findIndex(e), s = t.maybeChild(i);
  if (o == e || s.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let a = Rh(s.content, e - o - 1, n);
  return a && t.replaceChild(i, s.copy(a));
}
function I4(t, e, n) {
  if (n.openStart > t.depth)
    throw new Zs("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new Zs("Inconsistent open depths");
  return Ih(t, e, n, 0);
}
function Ih(t, e, n, r) {
  let i = t.index(r), o = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let s = Ih(t, e, n, r + 1);
    return o.copy(o.content.replaceChild(i, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let s = t.parent, a = s.content;
      return Yr(s, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: s, end: a } = D4(n, t);
      return Yr(o, Ph(t, s, a, e, r));
    }
  else return Yr(o, Ks(t, e, r));
}
function Dh(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new Zs("Cannot join " + e.type.name + " onto " + t.type.name);
}
function f1(t, e, n) {
  let r = t.node(n);
  return Dh(r, e.node(n)), r;
}
function Qr(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function co(t, e, n, r) {
  let i = (e || t).node(n), o = 0, s = e ? e.index(n) : i.childCount;
  t && (o = t.index(n), t.depth > n ? o++ : t.textOffset && (Qr(t.nodeAfter, r), o++));
  for (let a = o; a < s; a++)
    Qr(i.child(a), r);
  e && e.depth == n && e.textOffset && Qr(e.nodeBefore, r);
}
function Yr(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function Ph(t, e, n, r, i) {
  let o = t.depth > i && f1(t, e, i + 1), s = r.depth > i && f1(n, r, i + 1), a = [];
  return co(null, t, i, a), o && s && e.index(i) == n.index(i) ? (Dh(o, s), Qr(Yr(o, Ph(t, e, n, r, i + 1)), a)) : (o && Qr(Yr(o, Ks(t, e, i + 1)), a), co(e, n, i, a), s && Qr(Yr(s, Ks(n, r, i + 1)), a)), co(r, null, i, a), new A(a);
}
function Ks(t, e, n) {
  let r = [];
  if (co(null, t, n, r), t.depth > n) {
    let i = f1(t, e, n + 1);
    Qr(Yr(i, Ks(t, e, n + 1)), r);
  }
  return co(e, null, n, r), new A(r);
}
function D4(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let o = n - 1; o >= 0; o--)
    i = e.node(o).copy(A.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class xo {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return $e.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let o = r.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Gs(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(o), c = o - l;
      if (r.push(s, a, i + l), !c || (s = s.child(a), s.isText))
        break;
      o = c - 1, i += l + 1;
    }
    return new xo(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = Yd.get(e);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let s = r.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      Yd.set(e, r = new P4());
    let i = r.elts[r.i] = xo.resolve(e, n);
    return r.i = (r.i + 1) % B4, i;
  }
}
class P4 {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const B4 = 12, Yd = /* @__PURE__ */ new WeakMap();
class Gs {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const $4 = /* @__PURE__ */ Object.create(null);
let Or = class p1 {
  /**
  @internal
  */
  constructor(e, n, r, i = $e.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || A.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && Ws(this.attrs, n || e.defaultAttrs || $4) && $e.sameSet(this.marks, r || $e.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new p1(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new p1(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return F.empty;
    let i = this.resolve(e), o = this.resolve(n), s = r ? 0 : i.sharedDepth(n), a = i.start(s), c = i.node(s).content.cut(i.pos - a, o.pos - a);
    return new F(c, i.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return I4(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return xo.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return xo.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Bh(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = A.empty, i = 0, o = r.childCount) {
    let s = this.contentMatchAt(e).matchFragment(r, i, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < o; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(e).matchType(r), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = $e.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!$e.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = A.fromJSON(e, n.content), o = e.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
Or.prototype.text = void 0;
class qs extends Or {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Bh(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new qs(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new qs(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function Bh(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class ri {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new z4(e, n);
    if (r.next == null)
      return ri.empty;
    let i = $h(r);
    r.next && r.err("Unexpected trailing text");
    let o = Z4(W4(i));
    return K4(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(e.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function o(s, a) {
      let l = s.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return A.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < s.next.length; c++) {
        let { type: d, next: u } = s.next[c];
        if (!(d.isText || d.hasRequiredAttrs()) && i.indexOf(u) == -1) {
          i.push(u);
          let f = o(u, a.concat(d));
          if (f)
            return f;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(e)) {
        let s = [];
        for (let a = i; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: l } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        o += (s ? ", " : "") + r.next[s].type.name + "->" + e.indexOf(r.next[s].next);
      return o;
    }).join(`
`);
  }
}
ri.empty = new ri(!0);
class z4 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function $h(t) {
  let e = [];
  do
    e.push(H4(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function H4(t) {
  let e = [];
  do
    e.push(F4(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function F4(t) {
  let e = j4(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = U4(t, e);
    else
      break;
  return e;
}
function Jd(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function U4(t, e) {
  let n = Jd(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = Jd(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function V4(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(e) && i.push(s);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function j4(t) {
  if (t.eat("(")) {
    let e = $h(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = V4(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function W4(t) {
  let e = [[]];
  return i(o(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(s, a, l) {
    let c = { term: l, to: a };
    return e[s].push(c), c;
  }
  function i(s, a) {
    s.forEach((l) => l.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, c) => l.concat(o(c, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let c = o(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return c;
        i(c, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return r(a, l), i(o(s.expr, l), l), [r(l)];
    } else if (s.type == "plus") {
      let l = n();
      return i(o(s.expr, a), l), i(o(s.expr, l), l), [r(l)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let c = 0; c < s.min; c++) {
          let d = n();
          i(o(s.expr, l), d), l = d;
        }
        if (s.max == -1)
          i(o(s.expr, l), l);
        else
          for (let c = s.min; c < s.max; c++) {
            let d = n();
            r(l, d), i(o(s.expr, l), d), l = d;
          }
        return [r(l)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function zh(t, e) {
  return e - t;
}
function Xd(t, e) {
  let n = [];
  return r(e), n.sort(zh);
  function r(i) {
    let o = t[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: l } = o[s];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function Z4(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Xd(t, 0));
  function n(r) {
    let i = [];
    r.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let d = 0; d < i.length; d++)
          i[d][0] == a && (c = i[d][1]);
        Xd(t, l).forEach((d) => {
          c || i.push([a, c = []]), c.indexOf(d) == -1 && c.push(d);
        });
      });
    });
    let o = e[r.join(",")] = new ri(r.indexOf(t.length - 1) > -1);
    for (let s = 0; s < i.length; s++) {
      let a = i[s][1].sort(zh);
      o.next.push({ type: i[s][0], next: e[a.join(",")] || n(a) });
    }
    return o;
  }
}
function K4(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, s = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: c } = i.next[a];
      s.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), r.indexOf(c) == -1 && r.push(c);
    }
    o && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function Hh(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function Fh(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let o = t[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function Uh(t, e, n, r) {
  for (let i in e)
    if (!(i in t))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in t) {
    let o = t[i];
    o.validate && o.validate(e[i]);
  }
}
function Vh(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new q4(t, r, e[r]);
  return n;
}
let eu = class jh {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = Vh(e, r.attrs), this.defaultAttrs = Hh(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ri.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : Fh(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Or(this, this.computeAttrs(e), A.from(n), $e.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = A.from(n), this.checkContent(n), new Or(this, this.computeAttrs(e), n, $e.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = A.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore(A.empty, !0);
    return o ? new Or(this, e, n.append(o), $e.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Uh(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : $e.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((o, s) => r[o] = new jh(o, n, s));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function G4(t, e, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`);
  };
}
class q4 {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? G4(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Ha {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = Vh(e, i.attrs), this.excluded = null;
    let o = Hh(this.attrs);
    this.instance = o ? new $e(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new $e(this, Fh(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((o, s) => r[o] = new Ha(o, i++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Uh(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Wh {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = kt.from(e.nodes), n.marks = kt.from(e.marks || {}), this.nodes = eu.compile(this.spec.nodes, this), this.marks = Ha.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[s] || (r[s] = ri.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? tu(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : tu(this, s.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof eu) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new qs(r, r.defaultAttrs, e, $e.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Or.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return $e.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function tu(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], o = t.marks[i], s = o;
    if (o)
      n.push(o);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function Q4(t) {
  return t.tag != null;
}
function Y4(t) {
  return t.style != null;
}
class Tr {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (Q4(i))
        this.tags.push(i);
      else if (Y4(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = e.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new ru(this, n, !1);
    return r.addAll(e, $e.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new ru(this, n, !0);
    return r.addAll(e, $e.none, n.from, n.to), F.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (eg(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(e);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(e) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, i);
    }
    for (let i in e.marks) {
      let o = e.marks[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = iu(s)), s.mark || s.ignore || s.clearMark || (s.mark = i);
      });
    }
    for (let i in e.nodes) {
      let o = e.nodes[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = iu(s)), s.node || s.ignore || s.mark || (s.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Tr(e, Tr.schemaRules(e)));
  }
}
const Zh = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, J4 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Kh = { ol: !0, ul: !0 }, ko = 1, h1 = 2, uo = 4;
function nu(t, e, n) {
  return e != null ? (e ? ko : 0) | (e === "full" ? h1 : 0) : t && t.whitespace == "pre" ? ko | h1 : n & ~uo;
}
class ss {
  constructor(e, n, r, i, o, s) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = $e.none, this.match = o || (s & uo ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(A.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & ko)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = A.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(A.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Zh.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class ru {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, s = nu(null, n.preserveWhitespace, 0) | (r ? uo : 0);
    i ? o = new ss(i.type, i.attrs, $e.none, !0, n.topMatch || i.type.contentMatch, s) : r ? o = new ss(null, null, $e.none, !0, null, s) : o = new ss(e.schema.topNodeType, null, $e.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, i = this.top, o = i.options & h1 ? "full" : this.localPreserveWS || (i.options & ko) > 0;
    if (o === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        o !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let s = i.content[i.content.length - 1], a = e.previousSibling;
        (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), a;
    Kh.hasOwnProperty(s) && this.parser.normalizeLists && X4(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : J4.hasOwnProperty(s))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, d = this.needsBlock;
      if (Zh.hasOwnProperty(s))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), c = !0, o.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let u = l && l.skip ? n : this.readStyles(e, n);
      u && this.addAll(e, u), c && this.sync(o), this.needsBlock = d;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], s = r.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(o, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, i) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        l && (o = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r, !1));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, i) {
    let o = r || 0;
    for (let s = r ? e.childNodes[r] : e.firstChild, a = i == null ? null : e.childNodes[i]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(s, n);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n, r) {
    let i, o;
    for (let s = this.open, a = 0; s >= 0; s--) {
      let l = this.nodes[s], c = l.findWrapping(e);
      if (c && (!i || i.length > c.length + a) && (i = c, o = l, !c.length))
        break;
      if (l.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!i)
      return null;
    this.sync(o);
    for (let s = 0; s < i.length; s++)
      n = this.enterInner(i[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let i = this.findPlace(e, n, r);
    if (i) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(e.type));
      let s = $e.none;
      for (let a of i.concat(e.marks))
        (o.type ? o.type.allowsMarkType(a.type) : ou(a.type, e.type)) && (s = a.addToSet(s));
      return o.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, i) {
    let o = this.findPlace(e.create(n), r, !1);
    return o && (o = this.enterInner(e, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(e, n, r, i = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = nu(e, o, s.options);
    s.options & uo && s.content.length == 0 && (a |= uo);
    let l = $e.none;
    return r = r.filter((c) => (s.type ? s.type.allowsMarkType(c.type) : ou(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new ss(e, n, l, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= ko);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= o; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let d = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= o ? r.node(l - o).type : null;
          if (!d || d.name != c && !d.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function X4(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Kh.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function eg(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function iu(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function ou(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: d } = a.edge(l);
        if (c == e || o.indexOf(d) < 0 && s(d))
          return !0;
      }
    };
    if (s(i.contentMatch))
      return !0;
  }
}
class ui {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = ml(n).createDocumentFragment());
    let i = r, o = [];
    return e.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < o.length && l < s.marks.length; ) {
          let c = s.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(o[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < o.length; )
          i = o.pop()[1];
        for (; l < s.marks.length; ) {
          let c = s.marks[l++], d = this.serializeMark(c, s.isInline, n);
          d && (o.push([c, i]), i.appendChild(d.dom), i = d.contentDOM || d.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = Is(ml(n), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(e.marks[i], e.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && Is(ml(r), i(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, i) {
    return Is(e, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new ui(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = su(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return su(e.marks);
  }
}
function su(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function ml(t) {
  return t.document || window.document;
}
const au = /* @__PURE__ */ new WeakMap();
function tg(t) {
  let e = au.get(t);
  return e === void 0 && au.set(t, e = ng(t)), e;
}
function ng(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(t), e;
}
function Is(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = tg(r)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = i.indexOf(" ");
  s > 0 && (n = i.slice(0, s), i = i.slice(s + 1));
  let a, l = n ? t.createElementNS(n, i) : t.createElement(i), c = e[1], d = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    d = 2;
    for (let u in c)
      if (c[u] != null) {
        let f = u.indexOf(" ");
        f > 0 ? l.setAttributeNS(u.slice(0, f), u.slice(f + 1), c[u]) : l.setAttribute(u, c[u]);
      }
  }
  for (let u = d; u < e.length; u++) {
    let f = e[u];
    if (f === 0) {
      if (u < e.length - 1 || u > d)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: h } = Is(t, f, n, r);
      if (l.appendChild(p), h) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = h;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const Gh = 65535, qh = Math.pow(2, 16);
function rg(t, e) {
  return t + e * qh;
}
function lu(t) {
  return t & Gh;
}
function ig(t) {
  return (t - (t & Gh)) / qh;
}
const Qh = 1, Yh = 2, Ds = 4, Jh = 8;
class g1 {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Jh) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Qh | Ds)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Yh | Ds)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Ds) > 0;
  }
}
class sn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && sn.empty)
      return sn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = lu(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + ig(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + o], d = this.ranges[a + s], u = l + c;
      if (e <= u) {
        let f = c ? e == l ? -1 : e == u ? 1 : n : n, p = l + i + (f < 0 ? 0 : d);
        if (r)
          return p;
        let h = e == (n < 0 ? l : u) ? null : rg(a / 3, e - l), m = e == l ? Yh : e == u ? Qh : Ds;
        return (n < 0 ? e != l : e != u) && (m |= Jh), new g1(p, m, h);
      }
      i += d - c;
    }
    return r ? e + i : new g1(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = lu(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + o], d = l + c;
      if (e <= d && a == i * 3)
        return !0;
      r += this.ranges[a + s] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let s = this.ranges[i], a = s - (this.inverted ? o : 0), l = s + (this.inverted ? 0 : o), c = this.ranges[i + n], d = this.ranges[i + r];
      e(a, a + c, l, l + d), o += d - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new sn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? sn.empty : new sn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
sn.empty = new sn([]);
class So {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, r = 0, i = e ? e.length : 0) {
    this.mirror = n, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new So(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e._maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new So();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this._maps[o], a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new g1(e, i, null);
  }
}
const Cl = /* @__PURE__ */ Object.create(null);
class Pt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return sn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Cl[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Cl)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Cl[e] = n, n.prototype.jsonID = e, n;
  }
}
class at {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new at(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new at(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return at.ok(e.replace(n, r, i));
    } catch (o) {
      if (o instanceof Zs)
        return at.fail(o.message);
      throw o;
    }
  }
}
function oc(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i);
    o.content.size && (o = o.copy(oc(o.content, e, o))), o.isInline && (o = e(o, n, i)), r.push(o);
  }
  return A.fromArray(r);
}
class _r extends Pt {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new F(oc(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), i), n.openStart, n.openEnd);
    return at.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new Hn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new _r(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof _r && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _r(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _r(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Pt.jsonID("addMark", _r);
class Hn extends Pt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new F(oc(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return at.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new _r(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Hn(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Hn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Hn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Hn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Pt.jsonID("removeMark", Hn);
class Er extends Pt {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return at.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return at.fromReplace(e, this.pos, this.pos + 1, new F(A.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new Er(this.pos, n.marks[i]);
        return new Er(this.pos, this.mark);
      }
    }
    return new ii(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Er(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Er(n.pos, e.markFromJSON(n.mark));
  }
}
Pt.jsonID("addNodeMark", Er);
class ii extends Pt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return at.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return at.fromReplace(e, this.pos, this.pos + 1, new F(A.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new Er(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ii(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new ii(n.pos, e.markFromJSON(n.mark));
  }
}
Pt.jsonID("removeNodeMark", ii);
class mt extends Pt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && m1(e, this.from, this.to) ? at.fail("Structure replace would overwrite content") : at.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new sn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new mt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new mt(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof mt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? F.empty : new F(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new mt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? F.empty : new F(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new mt(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new mt(n.from, n.to, F.fromJSON(e, n.slice), !!n.structure);
  }
}
Pt.jsonID("replace", mt);
class yt extends Pt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, o, s, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(e) {
    if (this.structure && (m1(e, this.from, this.gapFrom) || m1(e, this.gapTo, this.to)))
      return at.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return at.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? at.fromReplace(e, this.from, this.to, r) : at.fail("Content does not fit in gap");
  }
  getMap() {
    return new sn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new yt(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new yt(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new yt(n.from, n.to, n.gapFrom, n.gapTo, F.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Pt.jsonID("replaceAround", yt);
function m1(t, e, n) {
  let r = t.resolve(e), i = n - e, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, i--;
    }
  }
  return !1;
}
function og(t, e, n, r) {
  let i = [], o = [], s, a;
  t.doc.nodesBetween(e, n, (l, c, d) => {
    if (!l.isInline)
      return;
    let u = l.marks;
    if (!r.isInSet(u) && d.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), p = Math.min(c + l.nodeSize, n), h = r.addToSet(u);
      for (let m = 0; m < u.length; m++)
        u[m].isInSet(h) || (s && s.to == f && s.mark.eq(u[m]) ? s.to = p : i.push(s = new Hn(f, p, u[m])));
      a && a.to == f ? a.to = p : o.push(a = new _r(f, p, r));
    }
  }), i.forEach((l) => t.step(l)), o.forEach((l) => t.step(l));
}
function sg(t, e, n, r) {
  let i = [], o = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let l = null;
    if (r instanceof Ha) {
      let c = s.marks, d;
      for (; d = r.isInSet(c); )
        (l || (l = [])).push(d), c = d.removeFromSet(c);
    } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
    if (l && l.length) {
      let c = Math.min(a + s.nodeSize, n);
      for (let d = 0; d < l.length; d++) {
        let u = l[d], f;
        for (let p = 0; p < i.length; p++) {
          let h = i[p];
          h.step == o - 1 && u.eq(i[p].style) && (f = h);
        }
        f ? (f.to = c, f.step = o) : i.push({ style: u, from: Math.max(a, e), to: c, step: o });
      }
    }
  }), i.forEach((s) => t.step(new Hn(s.from, s.to, s.style)));
}
function sc(t, e, n, r = n.contentMatch, i = !0) {
  let o = t.doc.nodeAt(e), s = [], a = e + 1;
  for (let l = 0; l < o.childCount; l++) {
    let c = o.child(l), d = a + c.nodeSize, u = r.matchType(c.type);
    if (!u)
      s.push(new mt(a, d, F.empty));
    else {
      r = u;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new Hn(a, d, c.marks[f]));
      if (i && c.isText && n.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, h;
        for (; f = p.exec(c.text); )
          h || (h = new F(A.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), s.push(new mt(a + f.index, a + f.index + f[0].length, h));
      }
    }
    a = d;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(A.empty, !0);
    t.replace(a, a, new F(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    t.step(s[l]);
}
function ag(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function ji(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), o = t.$from.index(r), s = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(o, s, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !ag(i, o, s))
      break;
  }
  return null;
}
function lg(t, e, n) {
  let { $from: r, $to: i, depth: o } = e, s = r.before(o + 1), a = i.after(o + 1), l = s, c = a, d = A.empty, u = 0;
  for (let h = o, m = !1; h > n; h--)
    m || r.index(h) > 0 ? (m = !0, d = A.from(r.node(h).copy(d)), u++) : l--;
  let f = A.empty, p = 0;
  for (let h = o, m = !1; h > n; h--)
    m || i.after(h + 1) < i.end(h) ? (m = !0, f = A.from(i.node(h).copy(f)), p++) : c++;
  t.step(new yt(l, c, s, a, new F(d.append(f), u, p), d.size - u, !0));
}
function ac(t, e, n = null, r = t) {
  let i = cg(t, e), o = i && dg(r, e);
  return o ? i.map(cu).concat({ type: e, attrs: n }).concat(o.map(cu)) : null;
}
function cu(t) {
  return { type: t, attrs: null };
}
function cg(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.contentMatchAt(r).findWrapping(e);
  if (!o)
    return null;
  let s = o.length ? o[0] : e;
  return n.canReplaceWith(r, i, s) ? o : null;
}
function dg(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.child(r), s = e.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let c = r; l && c < i; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : s;
}
function ug(t, e, n) {
  let r = A.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = A.from(n[s].type.create(n[s].attrs, r));
  }
  let i = e.start, o = e.end;
  t.step(new yt(i, o, i, o, new F(r, 0, 0), n.length, !0));
}
function fg(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof i == "function" ? i(s) : i;
    if (s.isTextblock && !s.hasMarkup(r, l) && pg(t.doc, t.mapping.slice(o).map(a), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre", h = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !h ? c = !1 : !p && h && (c = !0);
      }
      c === !1 && e0(t, s, a, o), sc(t, t.mapping.slice(o).map(a, 1), r, void 0, c === null);
      let d = t.mapping.slice(o), u = d.map(a, 1), f = d.map(a + s.nodeSize, 1);
      return t.step(new yt(u, f, u + 1, f - 1, new F(A.from(r.create(l, null, s.marks)), 0, 0), 1, !0)), c === !0 && Xh(t, s, a, o), !1;
    }
  });
}
function Xh(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(i.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + o + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function e0(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(r).map(n + 1 + o);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function pg(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function hg(t, e, n, r, i) {
  let o = t.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return t.replaceWith(e, e + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new yt(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new F(A.from(s), 0, 0), 1, !0));
}
function sr(t, e, n = 1, r) {
  let i = t.resolve(e), o = i.depth - n, s = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, d = n - 2; c > o; c--, d--) {
    let u = i.node(c), f = i.index(c);
    if (u.type.spec.isolating)
      return !1;
    let p = u.content.cutByIndex(f, u.childCount), h = r && r[d + 1];
    h && (p = p.replaceChild(0, h.type.create(h.attrs)));
    let m = r && r[d] || u;
    if (!u.canReplace(f + 1, u.childCount) || !m.type.validContent(p))
      return !1;
  }
  let a = i.indexAfter(o), l = r && r[0];
  return i.node(o).canReplaceWith(a, a, l ? l.type : i.node(o + 1).type);
}
function gg(t, e, n = 1, r) {
  let i = t.doc.resolve(e), o = A.empty, s = A.empty;
  for (let a = i.depth, l = i.depth - n, c = n - 1; a > l; a--, c--) {
    o = A.from(i.node(a).copy(o));
    let d = r && r[c];
    s = A.from(d ? d.type.create(d.attrs, s) : i.node(a).copy(s));
  }
  t.step(new mt(e, e, new F(o.append(s), n, n), !0));
}
function Pr(t, e) {
  let n = t.resolve(e), r = n.index();
  return t0(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function mg(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i), s = o.type == r ? t.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function t0(t, e) {
  return !!(t && e && !t.isLeaf && mg(t, e));
}
function Fa(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let o, s, a = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), a++, s = r.node(i).maybeChild(a)) : (o = r.node(i).maybeChild(a - 1), s = r.node(i + 1)), o && !o.isTextblock && t0(o, s) && r.node(i).canReplace(a, a + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function Cg(t, e, n) {
  let r = null, { linebreakReplacement: i } = t.doc.type.schema, o = t.doc.resolve(e - n), s = o.node().type;
  if (i && s.inlineContent) {
    let d = s.whitespace == "pre", u = !!s.contentMatch.matchType(i);
    d && !u ? r = !1 : !d && u && (r = !0);
  }
  let a = t.steps.length;
  if (r === !1) {
    let d = t.doc.resolve(e + n);
    e0(t, d.node(), d.before(), a);
  }
  s.inlineContent && sc(t, e + n - 1, s, o.node().contentMatchAt(o.index()), r == null);
  let l = t.mapping.slice(a), c = l.map(e - n);
  if (t.step(new mt(c, l.map(e + n, -1), F.empty, !0)), r === !0) {
    let d = t.doc.resolve(c);
    Xh(t, d.node(), d.before(), t.steps.length);
  }
  return t;
}
function bg(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function n0(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), c = r.node(s), d = !1;
      if (o == 1)
        d = c.canReplace(l, l, i);
      else {
        let u = c.contentMatchAt(l).findWrapping(i.firstChild.type);
        d = u && c.canReplaceWith(l, l, u[0]);
      }
      if (d)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function Ua(t, e, n = e, r = F.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), o = t.resolve(n);
  return r0(i, o, r) ? new mt(e, n, r) : new yg(i, o, r).fit();
}
function r0(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class yg {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = A.empty;
    for (let i = 0; i <= e.depth; i++) {
      let o = e.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = A.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let o = this.placed, s = r.depth, a = i.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let l = new F(o, s, a);
    return e > -1 ? new yt(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new mt(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = bl(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let s = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], d, u = null;
          if (n == 1 && (s ? c.matchType(s.type) || (u = c.fillBefore(A.from(s), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: u };
          if (n == 2 && s && (d = c.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: d };
          if (o && c.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = bl(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new F(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = bl(e, n);
    if (i.childCount <= 1 && n > 0) {
      let o = e.size - n <= n + i.size;
      this.unplaced = new F(no(e, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new F(no(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let m = 0; m < o.length; m++)
        this.openFrontierNode(o[m]);
    let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - e, c = 0, d = [], { match: u, type: f } = this.frontier[n];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        d.push(i.child(m));
      u = u.matchFragment(i);
    }
    let p = a.size + e - (s.content.size - s.openEnd);
    for (; c < a.childCount; ) {
      let m = a.child(c), g = u.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || l == 0 || m.content.size) && (u = g, d.push(i0(m.mark(f.allowedMarks(m.marks)), c == 1 ? l : 0, c == a.childCount ? p : -1)));
    }
    let h = c == a.childCount;
    h || (p = -1), this.placed = ro(this.placed, n, A.from(d)), this.frontier[n].match = u, h && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = a; m < p; m++) {
      let C = g.lastChild;
      this.frontier.push({ type: C.type, match: C.contentMatchAt(C.childCount) }), g = C.content;
    }
    this.unplaced = h ? e == 0 ? F.empty : new F(no(s.content, e - 1, 1), e - 1, p < 0 ? s.openEnd : e - 1) : new F(no(s.content, e, c), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !yl(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = yl(e, n, i, r, o);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], d = yl(e, a, c, l, !0);
          if (!d || d.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: o ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = ro(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = ro(this.placed, this.depth, A.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(A.empty, !0);
    n.childCount && (this.placed = ro(this.placed, this.frontier.length, n));
  }
}
function no(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(no(t.firstChild.content, e - 1, n)));
}
function ro(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(ro(t.lastChild.content, e - 1, n)));
}
function bl(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function i0(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, i0(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(A.empty, !0)))), t.copy(r);
}
function yl(t, e, n, r, i) {
  let o = t.node(e), s = i ? t.indexAfter(e) : t.index(e);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, s);
  return a && !vg(n, o.content, s) ? a : null;
}
function vg(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function wg(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function _g(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), o = t.doc.resolve(n);
  if (r0(i, o, r))
    return t.step(new mt(e, n, r));
  let s = s0(i, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(i.depth + 1);
  s.unshift(a);
  for (let f = i.depth, p = i.pos - 1; f > 0; f--, p--) {
    let h = i.node(f).type.spec;
    if (h.defining || h.definingAsContext || h.isolating)
      break;
    s.indexOf(f) > -1 ? a = f : i.before(f) == p && s.splice(1, 0, -f);
  }
  let l = s.indexOf(a), c = [], d = r.openStart;
  for (let f = r.content, p = 0; ; p++) {
    let h = f.firstChild;
    if (c.push(h), p == r.openStart)
      break;
    f = h.content;
  }
  for (let f = d - 1; f >= 0; f--) {
    let p = c[f], h = wg(p.type);
    if (h && !p.sameMarkup(i.node(Math.abs(a) - 1)))
      d = f;
    else if (h || !p.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + d + 1) % (r.openStart + 1), h = c[p];
    if (h)
      for (let m = 0; m < s.length; m++) {
        let g = s[(m + l) % s.length], C = !0;
        g < 0 && (C = !1, g = -g);
        let v = i.node(g - 1), _ = i.index(g - 1);
        if (v.canReplaceWith(_, _, h.type, h.marks))
          return t.replace(i.before(g), C ? o.after(g) : n, new F(o0(r.content, 0, r.openStart, p), p, r.openEnd));
      }
  }
  let u = t.steps.length;
  for (let f = s.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > u)); f--) {
    let p = s[f];
    p < 0 || (e = i.before(p), n = o.after(p));
  }
}
function o0(t, e, n, r, i) {
  if (e < n) {
    let o = t.firstChild;
    t = t.replaceChild(0, o.copy(o0(o.content, e + 1, n, r, o)));
  }
  if (e > r) {
    let o = i.contentMatchAt(0), s = o.fillBefore(t).append(t);
    t = s.append(o.matchFragment(s).fillBefore(A.empty, !0));
  }
  return t;
}
function Eg(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = bg(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new F(A.from(r), 0, 0));
}
function xg(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), o = s0(r, i);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], l = s == o.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a));
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++)
    if (e - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s && r.start(s - 1) == i.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1)))
      return t.delete(r.before(s), n);
  t.delete(e, n);
}
function s0(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let o = t.start(i);
    if (o < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (o == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class Li extends Pt {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return at.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return at.fromReplace(e, this.pos, this.pos + 1, new F(A.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return sn.empty;
  }
  invert(e) {
    return new Li(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Li(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Li(n.pos, n.attr, n.value);
  }
}
Pt.jsonID("attr", Li);
class Mo extends Pt {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return at.ok(r);
  }
  getMap() {
    return sn.empty;
  }
  invert(e) {
    return new Mo(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Mo(n.attr, n.value);
  }
}
Pt.jsonID("docAttr", Mo);
let Ri = class extends Error {
};
Ri = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
Ri.prototype = Object.create(Error.prototype);
Ri.prototype.constructor = Ri;
Ri.prototype.name = "TransformError";
class lc {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new So();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new Ri(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = F.empty) {
    let i = Ua(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new F(A.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, F.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return _g(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return Eg(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return xg(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return lg(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return Cg(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return ug(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return fg(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return hg(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new Li(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new Mo(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new Er(e, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (n instanceof $e)
      n.isInSet(r.marks) && this.step(new ii(e, n));
    else {
      let i = r.marks, o, s = [];
      for (; o = n.isInSet(i); )
        s.push(new ii(e, o)), i = o.removeFromSet(i);
      for (let a = s.length - 1; a >= 0; a--)
        this.step(s[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, r) {
    return gg(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return og(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return sg(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return sc(this, e, n, r), this;
  }
}
const vl = /* @__PURE__ */ Object.create(null);
class le {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new a0(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = F.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let o = e.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: c } = s[a], d = e.mapping.slice(o);
      e.replaceRange(d.map(l.pos), d.map(c.pos), a ? F.empty : n), a == 0 && fu(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: s, $to: a } = i[o], l = e.mapping.slice(r), c = l.map(s.pos), d = l.map(a.pos);
      o ? e.deleteRange(c, d) : (e.replaceRangeWith(c, d, n), fu(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new ie(e) : yi(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let o = e.depth - 1; o >= 0; o--) {
      let s = n < 0 ? yi(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, r) : yi(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Gt(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return yi(e, e, 0, 0, 1) || new Gt(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return yi(e, e, e.content.size, e.childCount, -1) || new Gt(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = vl[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in vl)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return vl[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ie.between(this.$anchor, this.$head).getBookmark();
  }
}
le.prototype.visible = !0;
class a0 {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let du = !1;
function uu(t) {
  !du && !t.parent.inlineContent && (du = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ie extends le {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    uu(e), uu(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return le.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new ie(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = F.empty) {
    if (super.replace(e, n), n == F.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ie && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Va(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ie(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = le.findFrom(n, r, !0) || le.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return le.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = (le.findFrom(e, -r, !0) || le.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new ie(e, n);
  }
}
le.jsonID("text", ie);
class Va {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Va(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ie.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ne extends le {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = e.resolve(i);
    return r ? le.near(o) : new ne(o);
  }
  content() {
    return new F(A.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ne && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new cc(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ne(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ne(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ne.prototype.visible = !1;
le.jsonID("node", ne);
class cc {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Va(r, r) : new cc(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && ne.isSelectable(r) ? new ne(n) : le.near(n);
  }
}
class Gt extends le {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = F.empty) {
    if (n == F.empty) {
      e.delete(0, e.doc.content.size);
      let r = le.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Gt(e);
  }
  map(e) {
    return new Gt(e);
  }
  eq(e) {
    return e instanceof Gt;
  }
  getBookmark() {
    return kg;
  }
}
le.jsonID("all", Gt);
const kg = {
  map() {
    return this;
  },
  resolve(t) {
    return new Gt(t);
  }
};
function yi(t, e, n, r, i, o = !1) {
  if (e.inlineContent)
    return ie.create(t, n);
  for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < e.childCount : s >= 0; s += i) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!o && ne.isSelectable(a))
        return ne.create(t, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = yi(t, a, n + i, i < 0 ? a.childCount : 0, i, o);
      if (l)
        return l;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function fu(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof mt || i instanceof yt))
    return;
  let o = t.mapping.maps[r], s;
  o.forEach((a, l, c, d) => {
    s == null && (s = d);
  }), t.setSelection(le.near(t.doc.resolve(s), n));
}
const pu = 1, as = 2, hu = 4;
class Sg extends lc {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | pu) & ~as, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & pu) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= as, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return $e.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & as) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~as, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || $e.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, o)), this.selection.empty || this.setSelection(le.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= hu, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & hu) > 0;
  }
}
function gu(t, e) {
  return !e || !t ? t : t.bind(e);
}
class io {
  constructor(e, n, r) {
    this.name = e, this.init = gu(n.init, r), this.apply = gu(n.apply, r);
  }
}
const Mg = [
  new io("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new io("selection", {
    init(t, e) {
      return t.selection || le.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new io("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new io("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class wl {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Mg.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new io(r.key, r.spec.state, r));
    });
  }
}
class Mi {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = i ? i[s].n : 0, c = i ? i[s].state : this, d = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
          if (d && r.filterTransaction(d, s)) {
            if (d.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let u = 0; u < this.config.plugins.length; u++)
                i.push(u < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(d), r = r.applyInner(d), o = !0;
          }
          i && (i[s] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Mi(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(e, this[o.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Sg(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new wl(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Mi(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new wl(this.schema, e.plugins), r = n.fields, i = new Mi(n);
    for (let o = 0; o < r.length; o++) {
      let s = r[o].name;
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new wl(e.schema, e.plugins), o = new Mi(i);
    return i.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = Or.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        o.selection = le.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], c = l.spec.state;
            if (l.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = c.fromJSON.call(l, e, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(e, o);
      }
    }), o;
  }
}
function l0(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = l0(i, e, {})), n[r] = i;
  }
  return n;
}
class Qe {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && l0(e.props, this, this.props), this.key = e.key ? e.key.key : c0("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const _l = /* @__PURE__ */ Object.create(null);
function c0(t) {
  return t in _l ? t + "$" + ++_l[t] : (_l[t] = 0, t + "$");
}
class ct {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = c0(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const St = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Ii = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let C1 = null;
const Xn = function(t, e, n) {
  let r = C1 || (C1 = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, Og = function() {
  C1 = null;
}, oi = function(t, e, n, r) {
  return n && (mu(t, e, n, r, -1) || mu(t, e, n, r, 1));
}, Tg = /^(img|br|input|textarea|hr)$/i;
function mu(t, e, n, r, i) {
  for (var o; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : mn(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || Vo(t) || Tg.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = St(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      let s = t.childNodes[e + (i < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((o = s.pmViewDesc) === null || o === void 0) && o.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        t = s, e = i < 0 ? mn(t) : 0;
    } else
      return !1;
  }
}
function mn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Lg(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = mn(t);
    } else if (t.parentNode && !Vo(t))
      e = St(t), t = t.parentNode;
    else
      return null;
  }
}
function Ng(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !Vo(t))
      e = St(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function Ag(t, e, n) {
  for (let r = e == 0, i = e == mn(t); r || i; ) {
    if (t == n)
      return !0;
    let o = St(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && o == 0, i = i && o == mn(t);
  }
}
function Vo(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const ja = function(t) {
  return t.focusNode && oi(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function jr(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function Rg(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Ig(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(mn(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(mn(r.startContainer), r.startOffset) };
  }
}
const Un = typeof navigator < "u" ? navigator : null, Cu = typeof document < "u" ? document : null, Br = Un && Un.userAgent || "", b1 = /Edge\/(\d+)/.exec(Br), d0 = /MSIE \d/.exec(Br), y1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Br), qt = !!(d0 || y1 || b1), Lr = d0 ? document.documentMode : y1 ? +y1[1] : b1 ? +b1[1] : 0, Tn = !qt && /gecko\/(\d+)/i.test(Br);
Tn && +(/Firefox\/(\d+)/.exec(Br) || [0, 0])[1];
const v1 = !qt && /Chrome\/(\d+)/.exec(Br), It = !!v1, u0 = v1 ? +v1[1] : 0, Ut = !qt && !!Un && /Apple Computer/.test(Un.vendor), Di = Ut && (/Mobile\/\w+/.test(Br) || !!Un && Un.maxTouchPoints > 2), gn = Di || (Un ? /Mac/.test(Un.platform) : !1), Dg = Un ? /Win/.test(Un.platform) : !1, rr = /Android \d/.test(Br), jo = !!Cu && "webkitFontSmoothing" in Cu.documentElement.style, Pg = jo ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Bg(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function Kn(t, e) {
  return typeof t == "number" ? t : t[e];
}
function $g(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function bu(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, o = t.dom.ownerDocument;
  for (let s = n || t.dom; s; ) {
    if (s.nodeType != 1) {
      s = Ii(s);
      continue;
    }
    let a = s, l = a == o.body, c = l ? Bg(o) : $g(a), d = 0, u = 0;
    if (e.top < c.top + Kn(r, "top") ? u = -(c.top - e.top + Kn(i, "top")) : e.bottom > c.bottom - Kn(r, "bottom") && (u = e.bottom - e.top > c.bottom - c.top ? e.top + Kn(i, "top") - c.top : e.bottom - c.bottom + Kn(i, "bottom")), e.left < c.left + Kn(r, "left") ? d = -(c.left - e.left + Kn(i, "left")) : e.right > c.right - Kn(r, "right") && (d = e.right - c.right + Kn(i, "right")), d || u)
      if (l)
        o.defaultView.scrollBy(d, u);
      else {
        let p = a.scrollLeft, h = a.scrollTop;
        u && (a.scrollTop += u), d && (a.scrollLeft += d);
        let m = a.scrollLeft - p, g = a.scrollTop - h;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    let f = l ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    s = f == "absolute" ? s.offsetParent : Ii(s);
  }
}
function zg(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let o = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let a = t.root.elementFromPoint(o, s);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: f0(t.dom) };
}
function f0(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = Ii(r))
    ;
  return e;
}
function Hg({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  p0(n, r == 0 ? 0 : r - e);
}
function p0(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: o } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let hi = null;
function Fg(t) {
  if (t.setActive)
    return t.setActive();
  if (hi)
    return t.focus(hi);
  let e = f0(t);
  t.focus(hi == null ? {
    get preventScroll() {
      return hi = { preventScroll: !0 }, !0;
    }
  } : void 0), hi || (hi = !1, p0(e, 0));
}
function h0(t, e) {
  let n, r = 2e8, i, o = 0, s = e.top, a = e.top, l, c;
  for (let d = t.firstChild, u = 0; d; d = d.nextSibling, u++) {
    let f;
    if (d.nodeType == 1)
      f = d.getClientRects();
    else if (d.nodeType == 3)
      f = Xn(d).getClientRects();
    else
      continue;
    for (let p = 0; p < f.length; p++) {
      let h = f[p];
      if (h.top <= s && h.bottom >= a) {
        s = Math.max(h.bottom, s), a = Math.min(h.top, a);
        let m = h.left > e.left ? h.left - e.left : h.right < e.left ? e.left - h.right : 0;
        if (m < r) {
          n = d, r = m, i = m && n.nodeType == 3 ? {
            left: h.right < e.left ? h.right : h.left,
            top: e.top
          } : e, d.nodeType == 1 && m && (o = u + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
          continue;
        }
      } else h.top > e.top && !l && h.left <= e.left && h.right >= e.left && (l = d, c = { left: Math.max(h.left, Math.min(h.right, e.left)), top: h.top });
      !n && (e.left >= h.right && e.top >= h.top || e.left >= h.left && e.top >= h.bottom) && (o = u + 1);
    }
  }
  return !n && l && (n = l, i = c, r = 0), n && n.nodeType == 3 ? Ug(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: o } : h0(n, i);
}
function Ug(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let o = hr(r, 1);
    if (o.top != o.bottom && dc(e, o))
      return { node: t, offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function dc(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function Vg(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function jg(t, e, n) {
  let { node: r, offset: i } = h0(e, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, o);
}
function Wg(t, e, n, r) {
  let i = -1;
  for (let o = e, s = !1; o != t.dom; ) {
    let a = t.docView.nearestDesc(o, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > r.left || l.top > r.top ? i = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (i = a.posAfter), s = !0), !a.contentDOM && i < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    o = a.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function g0(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let s = t.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (dc(e, c))
            return g0(s, e, c);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return t;
}
function Zg(t, e) {
  let n = t.dom.ownerDocument, r, i = 0, o = Ig(n, e.left, e.top);
  o && ({ node: r, offset: i } = o);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = t.dom.getBoundingClientRect();
    if (!dc(e, c) || (s = g0(t.dom, e, c), !s))
      return null;
  }
  if (Ut)
    for (let c = s; r && c; c = Ii(c))
      c.draggable && (r = void 0);
  if (s = Vg(s, e), r) {
    if (Tn && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let d = r.childNodes[i], u;
      d.nodeName == "IMG" && (u = d.getBoundingClientRect()).right <= e.left && u.bottom > e.top && i++;
    }
    let c;
    jo && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = Wg(t, r, i, e));
  }
  a == null && (a = jg(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function yu(t) {
  return t.top < t.bottom || t.left < t.right;
}
function hr(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (yu(r))
      return r;
  }
  return Array.prototype.find.call(n, yu) || t.getBoundingClientRect();
}
const Kg = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function m0(t, e, n) {
  let { node: r, offset: i, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = jo || Tn;
  if (r.nodeType == 3)
    if (s && (Kg.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = hr(Xn(r, i, i), n);
      if (Tn && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = hr(Xn(r, i - 1, i - 1), -1);
        if (c.top == l.top) {
          let d = hr(Xn(r, i, i + 1), -1);
          if (d.top != l.top)
            return Qi(d, d.left < c.left);
        }
      }
      return l;
    } else {
      let l = i, c = i, d = n < 0 ? 1 : -1;
      return n < 0 && !i ? (c++, d = -1) : n >= 0 && i == r.nodeValue.length ? (l--, d = 1) : n < 0 ? l-- : c++, Qi(hr(Xn(r, l, c), d), d < 0);
    }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == mn(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return El(l.getBoundingClientRect(), !1);
    }
    if (o == null && i < mn(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return El(l.getBoundingClientRect(), !0);
    }
    return El(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == mn(r))) {
    let l = r.childNodes[i - 1], c = l.nodeType == 3 ? Xn(l, mn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return Qi(hr(c, 1), !1);
  }
  if (o == null && i < mn(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? Xn(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return Qi(hr(c, -1), !0);
  }
  return Qi(hr(r.nodeType == 3 ? Xn(r) : r, -n), n >= 0);
}
function Qi(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function El(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function C0(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function Gg(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return C0(t, e, () => {
    let { node: o } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = m0(t, i.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Xn(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let d = l[c];
        if (d.bottom > d.top + 1 && (n == "up" ? s.top - d.top > (d.bottom - s.top) * 2 : d.bottom - s.bottom > (s.bottom - d.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const qg = /[\u0590-\u08ac]/;
function Qg(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = t.domSelection();
  return a ? !qg.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : C0(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: d, anchorOffset: u } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: h, focusOffset: m } = t.domSelectionRange(), g = h && !p.contains(h.nodeType == 1 ? h : h.parentNode) || l == h && c == m;
    try {
      a.collapse(d, u), l && (l != d || c != u) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let vu = null, wu = null, _u = !1;
function Yg(t, e, n) {
  return vu == e && wu == n ? _u : (vu = e, wu = n, _u = n == "up" || n == "down" ? Gg(t, e, n) : Qg(t, e, n));
}
const Cn = 0, Eu = 1, Zr = 2, Vn = 3;
class Wo {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Cn, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let o, s;
        if (e == this.contentDOM)
          o = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (e == this.contentDOM)
          o = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > St(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let o = this.getDesc(i), s;
      if (o && (!n || o.node))
        if (r && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          r = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == e && o != r) {
        for (; !i.border && i.children.length; )
          for (let s = 0; s < i.children.length; s++) {
            let a = i.children[s];
            if (a.size) {
              i = a;
              break;
            }
          }
        return i;
      }
      if (e < o)
        return i.descAt(e - r - i.border);
      r = o;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let s = this.children[r], a = o + s.size;
      if (a > e || s instanceof y0) {
        i = e - o;
        break;
      }
      o = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof b0 && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? St(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? St(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let s = r, a = 0; ; a++) {
      let l = this.children[a], c = s + l.size;
      if (i == -1 && e <= c) {
        let d = s + l.border;
        if (e >= d && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, d);
        e = s;
        for (let u = a; u > 0; u--) {
          let f = this.children[u - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = St(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let d = a + 1; d < this.children.length; d++) {
          let u = this.children[d];
          if (u.size && u.dom.parentNode == this.contentDOM && !u.emptyChildAt(-1)) {
            o = St(u.dom);
            break;
          }
          n += u.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let o = Math.min(e, n), s = Math.max(e, n);
    for (let p = 0, h = 0; p < this.children.length; p++) {
      let m = this.children[p], g = h + m.size;
      if (o > h && s < g)
        return m.setSelection(e - h - m.border, n - h - m.border, r, i);
      h = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = r.root.getSelection(), d = r.domSelectionRange(), u = !1;
    if ((Tn || Ut) && e == n) {
      let { node: p, offset: h } = a;
      if (p.nodeType == 3) {
        if (u = !!(h && p.nodeValue[h - 1] == `
`), u && h == p.nodeValue.length)
          for (let m = p, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: St(g) + 1 });
              break;
            }
            let C = m.pmViewDesc;
            if (C && C.node && C.node.isBlock)
              break;
          }
      } else {
        let m = p.childNodes[h - 1];
        u = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (Tn && d.focusNode && d.focusNode != l.node && d.focusNode.nodeType == 1) {
      let p = d.focusNode.childNodes[d.focusOffset];
      p && p.contentEditable == "false" && (i = !0);
    }
    if (!(i || u && Ut) && oi(a.node, a.offset, d.anchorNode, d.anchorOffset) && oi(l.node, l.offset, d.focusNode, d.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !u) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let h = a;
        a = l, l = h;
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset), p.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], s = r + o.size;
      if (r == s ? e <= s && n >= r : e < s && n > r) {
        let a = r + o.border, l = s - o.border;
        if (e >= a && n <= l) {
          this.dirty = e == r || n == s ? Zr : Eu, e == a && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = Vn : o.markDirty(e - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Zr : Vn;
      }
      r = s;
    }
    this.dirty = Zr;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Zr : Eu;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class b0 extends Wo {
  constructor(e, n, r, i) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(e) {
    return this.dirty == Cn && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class Jg extends Wo {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class si extends Wo {
  constructor(e, n, r, i, o) {
    super(e, [], r, i), this.mark = n, this.spec = o;
  }
  static create(e, n, r, i) {
    let o = i.nodeViews[n.type.name], s = o && o(n, i, r);
    return (!s || !s.dom) && (s = ui.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new si(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & Vn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Vn && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != Cn) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Cn;
    }
  }
  slice(e, n, r) {
    let i = si.create(this.parent, this.mark, !0, r), o = this.children, s = this.size;
    n < s && (o = _1(o, n, s, r)), e > 0 && (o = _1(o, 0, e, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Nr extends Wo {
  constructor(e, n, r, i, o, s, a, l, c) {
    super(e, [], o, s), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, o, s) {
    let a = o.nodeViews[n.type.name], l, c = a && a(n, o, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), d = c && c.dom, u = c && c.contentDOM;
    if (n.isText) {
      if (!d)
        d = document.createTextNode(n.text);
      else if (d.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else d || ({ dom: d, contentDOM: u } = ui.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !u && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"), n.type.spec.draggable && (d.draggable = !0));
    let f = d;
    return d = _0(d, r, n), c ? l = new Xg(e, n, r, i, d, u || null, f, c, o, s + 1) : n.isText ? new Wa(e, n, r, i, d, f, o) : new Nr(e, n, r, i, d, u || null, f, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => A.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == Cn && e.eq(this.node) && Qs(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, o = e.composing ? this.localCompositionInfo(e, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, l = new tm(this, s && s.node, e);
    im(this.node, this.innerDeco, (c, d, u) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !u && l.syncToMarks(d == this.node.childCount ? $e.none : this.node.child(d).marks, r, e), l.placeWidget(c, e, i);
    }, (c, d, u, f) => {
      l.syncToMarks(c.marks, r, e);
      let p;
      l.findNodeMatch(c, d, u, f) || a && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (p = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(c, d, u, p, e) || l.updateNextNode(c, d, u, e, f, i) || l.addNode(c, d, u, e, i), i += c.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Zr) && (s && this.protectLocalComposition(e, s), v0(this.contentDOM, this.children, e), Di && om(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof ie) || r < n || i > n + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = sm(this.node.content, s, r - n, i - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new Jg(this, o, n, i);
    e.input.compositionNodes.push(s), this.children = _1(this.children, r, r + i.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == Vn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Cn;
  }
  updateOuterDeco(e) {
    if (Qs(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = w0(this.dom, this.nodeDOM, w1(this.outerDeco, this.node, n), w1(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function xu(t, e, n, r, i) {
  _0(r, e, t);
  let o = new Nr(void 0, t, e, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class Wa extends Nr {
  constructor(e, n, r, i, o, s, a) {
    super(e, n, r, i, o, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == Vn || this.dirty != Cn && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Cn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Cn, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), o = document.createTextNode(i.text);
    return new Wa(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Vn);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class y0 extends Wo {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Cn && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class Xg extends Nr {
  constructor(e, n, r, i, o, s, a, l, c, d) {
    super(e, n, r, i, o, s, a, c, d), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == Vn)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let o = this.spec.update(e, n, r);
      return o && this.updateInner(e, n, r, i), o;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function v0(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let o = 0; o < e.length; o++) {
    let s = e[o], a = s.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = ku(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(a, r);
    if (s instanceof si) {
      let l = r ? r.previousSibling : t.lastChild;
      v0(s.contentDOM, s.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = ku(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const fo = function(t) {
  t && (this.nodeName = t);
};
fo.prototype = /* @__PURE__ */ Object.create(null);
const Kr = [new fo()];
function w1(t, e, n) {
  if (t.length == 0)
    return Kr;
  let r = n ? Kr[0] : new fo(), i = [r];
  for (let o = 0; o < t.length; o++) {
    let s = t[o].type.attrs;
    if (s) {
      s.nodeName && i.push(r = new fo(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && i.length == 1 && i.push(r = new fo(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function w0(t, e, n, r) {
  if (n == Kr && r == Kr)
    return e;
  let i = e;
  for (let o = 0; o < r.length; o++) {
    let s = r[o], a = n[o];
    if (o) {
      let l;
      a && a.nodeName == s.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = Kr[0]), i = l;
    }
    em(i, a || Kr[0], s);
  }
  return i;
}
function em(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && t.classList.add(i[o]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function _0(t, e, n) {
  return w0(t, t, Kr, w1(e, n, t.nodeType != 1));
}
function Qs(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function ku(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class tm {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = nm(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, o = this.stack.length >> 1, s = Math.min(o, e.length);
    for (; i < s && (i == o - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < o; )
      this.destroyRest(), this.top.dirty = Cn, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[o]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = si.create(this.top, e[o], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let o = -1, s;
    if (i >= this.preMatch.index && (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, r))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, o) {
    let s = this.top.children[i];
    return s.dirty == Vn && s.dom == s.contentDOM && (s.dirty = Zr), s.update(e, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof Nr) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != o)
          return !1;
        let d = l.dom, u, f = this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Vn && Qs(n, l.outerDeco));
        if (!f && l.update(e, n, r, i))
          return this.destroyBetween(this.index, a), l.dom != d && (this.changed = !0), this.index++, !0;
        if (!f && (u = this.recreateWrapper(l, e, n, r, i, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = u, u.contentDOM && (u.dirty = Zr, u.updateChildren(i, s + 1), u.dirty = Cn), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, i, o, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Qs(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let a = Nr.create(this.top, n, r, i, o, s);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, o) {
    let s = Nr.create(this.top, e, n, r, i, o);
    s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new b0(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof si; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Wa) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Ut || It) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new y0(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function nm(t, e) {
  let n = e, r = n.children.length, i = t.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let c = n.children[r - 1];
        if (c instanceof si)
          n = c, r = c.children.length;
        else {
          a = c, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != t.child(i - 1))
        break;
      --i, o.set(a, i), s.push(a);
    }
  }
  return { index: i, matched: o, matches: s.reverse() };
}
function rm(t, e) {
  return t.type.side - e.type.side;
}
function im(t, e, n, r) {
  let i = e.locals(t), o = 0;
  if (i.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let d = t.child(c);
      r(d, i, e.forChild(o, d), c), o += d.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let d, u;
    for (; s < i.length && i[s].to == o; ) {
      let g = i[s++];
      g.widget && (d ? (u || (u = [d])).push(g) : d = g);
    }
    if (d)
      if (u) {
        u.sort(rm);
        for (let g = 0; g < u.length; g++)
          n(u[g], c, !!l);
      } else
        n(d, c, !!l);
    let f, p;
    if (l)
      p = -1, f = l, l = null;
    else if (c < t.childCount)
      p = c, f = t.child(c++);
    else
      break;
    for (let g = 0; g < a.length; g++)
      a[g].to <= o && a.splice(g--, 1);
    for (; s < i.length && i[s].from <= o && i[s].to > o; )
      a.push(i[s++]);
    let h = o + f.nodeSize;
    if (f.isText) {
      let g = h;
      s < i.length && i[s].from < g && (g = i[s].from);
      for (let C = 0; C < a.length; C++)
        a[C].to < g && (g = a[C].to);
      g < h && (l = f.cut(g - o), f = f.cut(0, g - o), h = g, p = -1);
    } else
      for (; s < i.length && i[s].to < h; )
        s++;
    let m = f.isInline && !f.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    r(f, m, e.forChild(o, f), p), o = h;
  }
}
function om(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function sm(t, e, n, r) {
  for (let i = 0, o = 0; i < t.childCount && o <= r; ) {
    let s = t.child(i++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; i < t.childCount; ) {
      let c = t.child(i++);
      if (o += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (o >= n) {
      if (o >= r && l.slice(r - e.length - a, r - a) == e)
        return r - e.length;
      let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function _1(t, e, n, r, i) {
  let o = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s], c = a, d = a += l.size;
    c >= n || d <= e ? o.push(l) : (c < e && o.push(l.slice(0, e - c, r)), i && (o.push(i), i = void 0), d > n && o.push(l.slice(n - c, l.size, r)));
  }
  return o;
}
function uc(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), o = i && i.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), l, c;
  if (ja(n)) {
    for (l = s; i && !i.node; )
      i = i.parent;
    let u = i.node;
    if (i && u.isAtom && ne.isSelectable(u) && i.parent && !(u.isInline && Ag(n.focusNode, n.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new ne(s == f ? a : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let u = s, f = s;
      for (let p = 0; p < n.rangeCount; p++) {
        let h = n.getRangeAt(p);
        u = Math.min(u, t.docView.posFromDOM(h.startContainer, h.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(h.endContainer, h.endOffset, -1));
      }
      if (u < 0)
        return null;
      [l, s] = f == t.state.selection.anchor ? [f, u] : [u, f], a = r.resolve(s);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let d = r.resolve(l);
  if (!c) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !o ? 1 : -1;
    c = fc(t, d, a, u);
  }
  return c;
}
function E0(t) {
  return t.editable ? t.hasFocus() : k0(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function ar(t, e = !1) {
  let n = t.state.selection;
  if (x0(t, n), !!E0(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && It) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && oi(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      lm(t);
    else {
      let { anchor: r, head: i } = n, o, s;
      Su && !(n instanceof ie) && (n.$from.parent.inlineContent || (o = Mu(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = Mu(t, n.to))), t.docView.setSelection(r, i, t, e), Su && (o && Ou(o), s && Ou(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && am(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Su = Ut || It && u0 < 63;
function Mu(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (Ut && i && i.contentEditable == "false")
    return xl(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return xl(i);
    if (o)
      return xl(o);
  }
}
function xl(t) {
  return t.contentEditable = "true", Ut && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Ou(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function am(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!E0(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function lm(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setStart(r.parentNode, St(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && qt && Lr <= 11 && (r.disabled = !0, r.disabled = !1);
}
function x0(t, e) {
  if (e instanceof ne) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (Tu(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    Tu(t);
}
function Tu(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function fc(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || ie.between(e, n, r);
}
function Lu(t) {
  return t.editable && !t.hasFocus() ? !1 : k0(t);
}
function k0(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function cm(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return oi(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function E1(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return o && le.findFrom(o, e);
}
function gr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Nu(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ie)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = t.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return gr(t, new ie(r.$anchor, s));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = E1(t.state, e);
        return i && i instanceof ne ? gr(t, i) : !1;
      } else if (!(gn && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = e < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? ne.isSelectable(o) ? gr(t, new ne(e < 0 ? t.state.doc.resolve(i.pos - o.nodeSize) : i)) : jo ? gr(t, new ie(t.state.doc.resolve(e < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof ne && r.node.isInline)
      return gr(t, new ie(e > 0 ? r.$to : r.$from));
    {
      let i = E1(t.state, e);
      return i ? gr(t, i) : !1;
    }
  }
}
function Ys(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function po(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function gi(t, e) {
  return e < 0 ? dm(t) : um(t);
}
function dm(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, o, s = !1;
  for (Tn && n.nodeType == 1 && r < Ys(n) && po(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (po(a, -1))
          i = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (S0(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && po(a, -1); )
          i = n.parentNode, o = St(a), a = a.previousSibling;
        if (a)
          n = a, r = Ys(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  s ? x1(t, n, r) : i && x1(t, i, o);
}
function um(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = Ys(n), o, s;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (po(a, 1))
        o = n, s = ++r;
      else
        break;
    } else {
      if (S0(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && po(a, 1); )
          o = a.parentNode, s = St(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Ys(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && x1(t, o, s);
}
function S0(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function fm(t, e) {
  for (; t && e == t.childNodes.length && !Vo(t); )
    e = St(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function pm(t, e) {
  for (; t && !e && !Vo(t); )
    e = St(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function x1(t, e, n) {
  if (e.nodeType != 3) {
    let o, s;
    (s = fm(e, n)) ? (e = s, n = 0) : (o = pm(e, n)) && (e = o, n = o.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (ja(r)) {
    let o = document.createRange();
    o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && ar(t);
  }, 50);
}
function Au(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(It || Dg) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e);
    if (e > n.start()) {
      let o = t.coordsAtPos(e - 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let o = t.coordsAtPos(e + 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Ru(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ie && !r.empty || n.indexOf("s") > -1 || gn && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = E1(t.state, e);
    if (s && s instanceof ne)
      return gr(t, s);
  }
  if (!i.parent.inlineContent) {
    let s = e < 0 ? i : o, a = r instanceof Gt ? le.near(s, e) : le.findFrom(s, e);
    return a ? gr(t, a) : !1;
  }
  return !1;
}
function Iu(t, e) {
  if (!(t.state.selection instanceof ie))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function Du(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function hm(t) {
  if (!Ut || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    Du(t, r, "true"), setTimeout(() => Du(t, r, "false"), 20);
  }
  return !1;
}
function gm(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function mm(t, e) {
  let n = e.keyCode, r = gm(e);
  if (n == 8 || gn && n == 72 && r == "c")
    return Iu(t, -1) || gi(t, -1);
  if (n == 46 && !e.shiftKey || gn && n == 68 && r == "c")
    return Iu(t, 1) || gi(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || gn && n == 66 && r == "c") {
    let i = n == 37 ? Au(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Nu(t, i, r) || gi(t, i);
  } else if (n == 39 || gn && n == 70 && r == "c") {
    let i = n == 39 ? Au(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Nu(t, i, r) || gi(t, i);
  } else {
    if (n == 38 || gn && n == 80 && r == "c")
      return Ru(t, -1, r) || gi(t, -1);
    if (n == 40 || gn && n == 78 && r == "c")
      return hm(t) || Ru(t, 1, r) || gi(t, 1);
    if (r == (gn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function pc(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = e;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let p = r.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content;
  }
  let s = t.someProp("clipboardSerializer") || ui.fromSchema(t.state.schema), a = A0(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(r, { document: a }));
  let c = l.firstChild, d, u = 0;
  for (; c && c.nodeType == 1 && (d = N0[c.nodeName.toLowerCase()]); ) {
    for (let p = d.length - 1; p >= 0; p--) {
      let h = a.createElement(d[p]);
      for (; l.firstChild; )
        h.appendChild(l.firstChild);
      l.appendChild(h), u++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${o}${u ? ` -${u}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (p) => p(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function M0(t, e, n, r, i) {
  let o = i.parent.type.spec.code, s, a;
  if (!n && !e)
    return null;
  let l = e && (r || o || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, o || r, t);
    }), o)
      return e ? new F(A.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : F.empty;
    let u = t.someProp("clipboardTextParser", (f) => f(e, i, r, t));
    if (u)
      a = u;
    else {
      let f = i.marks(), { schema: p } = t.state, h = ui.fromSchema(p);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = s.appendChild(document.createElement("p"));
        m && g.appendChild(h.serializeNode(p.text(m, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (u) => {
      n = u(n, t);
    }), s = vm(n), jo && wm(s);
  let c = s && s.querySelector("[data-pm-slice]"), d = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (d && d[3])
    for (let u = +d[3]; u > 0; u--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      s = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Tr.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || d),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !Cm.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), d)
    a = _m(Pu(a, +d[1], +d[2]), d[4]);
  else if (a = F.maxOpen(bm(a.content, i), !0), a.openStart || a.openEnd) {
    let u = 0, f = 0;
    for (let p = a.content.firstChild; u < a.openStart && !p.type.spec.isolating; u++, p = p.firstChild)
      ;
    for (let p = a.content.lastChild; f < a.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    a = Pu(a, u, f);
  }
  return t.someProp("transformPasted", (u) => {
    a = u(a, t);
  }), a;
}
const Cm = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function bm(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), o, s = [];
    if (t.forEach((a) => {
      if (!s)
        return;
      let l = i.findWrapping(a.type), c;
      if (!l)
        return s = null;
      if (c = s.length && o.length && T0(l, o, a, s[s.length - 1], 0))
        s[s.length - 1] = c;
      else {
        s.length && (s[s.length - 1] = L0(s[s.length - 1], o.length));
        let d = O0(a, l);
        s.push(d), i = i.matchType(d.type), o = l;
      }
    }), s)
      return A.from(s);
  }
  return t;
}
function O0(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, A.from(t));
  return t;
}
function T0(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let o = T0(t, e, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(A.from(O0(n, t, i + 1))));
  }
}
function L0(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, L0(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(A.empty, !0);
  return t.copy(n.append(r));
}
function k1(t, e, n, r, i, o) {
  let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
  return t.childCount > 1 && (o = 0), i < r - 1 && (a = k1(a, e, n, r, i + 1, o)), i >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(A.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
}
function Pu(t, e, n) {
  return e < t.openStart && (t = new F(k1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new F(k1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const N0 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Bu = null;
function A0() {
  return Bu || (Bu = document.implementation.createHTMLDocument("title"));
}
let kl = null;
function ym(t) {
  let e = window.trustedTypes;
  return e ? (kl || (kl = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), kl.createHTML(t)) : t;
}
function vm(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = A0().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && N0[r[1].toLowerCase()]) && (t = i.map((o) => "<" + o + ">").join("") + t + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = ym(t), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function wm(t) {
  let e = t.querySelectorAll(It ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function _m(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: o, openEnd: s } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = A.from(l.create(r[a + 1], i)), o++, s++;
  }
  return new F(i, o, s);
}
const Vt = {}, jt = {}, Em = { touchstart: !0, touchmove: !0 };
class xm {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function km(t) {
  for (let e in Vt) {
    let n = Vt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      Mm(t, r) && !hc(t, r) && (t.editable || !(r.type in jt)) && n(t, r);
    }, Em[e] ? { passive: !0 } : void 0);
  }
  Ut && t.dom.addEventListener("input", () => null), S1(t);
}
function xr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function Sm(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function S1(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => hc(t, r));
  });
}
function hc(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function Mm(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function Om(t, e) {
  !hc(t, e) && Vt[e.type] && (t.editable || !(e.type in jt)) && Vt[e.type](t, e);
}
jt.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !I0(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(rr && It && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), Di && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, jr(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || mm(t, n) ? n.preventDefault() : xr(t, "key");
};
jt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
jt.keypress = (t, e) => {
  let n = e;
  if (I0(t, n) || !n.charCode || n.ctrlKey && !n.altKey || gn && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof ie) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode), o = () => t.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, i, o)) && t.dispatch(o()), n.preventDefault();
  }
};
function Za(t) {
  return { left: t.clientX, top: t.clientY };
}
function Tm(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function gc(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let o = t.state.doc.resolve(r);
  for (let s = o.depth + 1; s > 0; s--)
    if (t.someProp(e, (a) => s > o.depth ? a(t, n, o.nodeAfter, o.before(s), i, !0) : a(t, n, o.node(s), o.before(s), i, !1)))
      return !0;
  return !1;
}
function Ni(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function Lm(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ne.isSelectable(r) ? (Ni(t, new ne(n)), !0) : !1;
}
function Nm(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof ne && (r = n.node);
  let o = t.state.doc.resolve(e);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (ne.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(s);
      break;
    }
  }
  return i != null ? (Ni(t, ne.create(t.state.doc, i)), !0) : !1;
}
function Am(t, e, n, r, i) {
  return gc(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (o) => o(t, e, r)) || (i ? Nm(t, n) : Lm(t, n));
}
function Rm(t, e, n, r) {
  return gc(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function Im(t, e, n, r) {
  return gc(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || Dm(t, n, r);
}
function Dm(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Ni(t, ie.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let o = i.depth + 1; o > 0; o--) {
    let s = o > i.depth ? i.nodeAfter : i.node(o), a = i.before(o);
    if (s.inlineContent)
      Ni(t, ie.create(r, a + 1, a + 1 + s.content.size));
    else if (ne.isSelectable(s))
      Ni(t, ne.create(r, a));
    else
      continue;
    return !0;
  }
}
function mc(t) {
  return Js(t);
}
const R0 = gn ? "metaKey" : "ctrlKey";
Vt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = mc(t), i = Date.now(), o = "singleClick";
  i - t.input.lastClick.time < 500 && Tm(n, t.input.lastClick) && !n[R0] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? o = "doubleClick" : t.input.lastClick.type == "doubleClick" && (o = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o, button: n.button };
  let s = t.posAtCoords(Za(n));
  s && (o == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new Pm(t, s, n, !!r)) : (o == "doubleClick" ? Rm : Im)(t, s.pos, s.inside, n) ? n.preventDefault() : xr(t, "pointer"));
};
class Pm {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[R0], this.allowDefault = r.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let d = e.state.doc.resolve(n.pos);
      o = d.parent, s = d.depth ? d.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || c instanceof ne && c.from <= s && c.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Tn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), xr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ar(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Za(e))), this.updateAllowDefault(e), this.allowDefault || !n ? xr(this.view, "pointer") : Am(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Ut && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    It && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Ni(this.view, le.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : xr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), xr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Vt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), mc(t), xr(t, "pointer");
};
Vt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), xr(t, "pointer");
};
Vt.contextmenu = (t) => mc(t);
function I0(t, e) {
  return t.composing ? !0 : Ut && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const Bm = rr ? 5e3 : -1;
jt.compositionstart = jt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof ie && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Js(t, !0), t.markCursor = null;
    else if (Js(t, !e.selection.empty), Tn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          i = s, o = -1;
      }
    }
    t.input.composing = !0;
  }
  D0(t, Bm);
};
jt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, D0(t, 20));
};
function D0(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Js(t), e));
}
function P0(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = zm()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function $m(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = Lg(e.focusNode, e.focusOffset), r = Ng(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = t.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function zm() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Js(t, e = !1) {
  if (!(rr && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), P0(t), e || t.docView && t.docView.dirty) {
      let n = uc(t), r = t.state.selection;
      return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function Hm(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Oo = qt && Lr < 15 || Di && Pg < 604;
Vt.copy = jt.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = Oo ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = pc(t, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", l)) : Hm(t, a), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function Fm(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function Um(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? To(t, r.value, null, i, e) : To(t, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function To(t, e, n, r, i) {
  let o = M0(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, o || F.empty)))
    return !0;
  if (!o)
    return !1;
  let s = Fm(o), a = s ? t.state.tr.replaceSelectionWith(s, r) : t.state.tr.replaceSelection(o);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function B0(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
jt.paste = (t, e) => {
  let n = e;
  if (t.composing && !rr)
    return;
  let r = Oo ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && To(t, B0(r), r.getData("text/html"), i, n) ? n.preventDefault() : Um(t, n);
};
class $0 {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const Vm = gn ? "altKey" : "ctrlKey";
function z0(t, e) {
  let n = t.someProp("dragCopies", (r) => !r(e));
  return n ?? !e[Vm];
}
Vt.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, o = i.empty ? null : t.posAtCoords(Za(n)), s;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof ne ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      s = ne.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && (s = ne.create(t.state.doc, u.posBefore));
    }
  }
  let a = (s || t.state.selection).content(), { dom: l, text: c, slice: d } = pc(t, a);
  (!n.dataTransfer.files.length || !It || u0 > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Oo ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Oo || n.dataTransfer.setData("text/plain", c), t.dragging = new $0(d, z0(t, n), s);
};
Vt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
jt.dragover = jt.dragenter = (t, e) => e.preventDefault();
jt.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(Za(n));
  if (!i)
    return;
  let o = t.state.doc.resolve(i.pos), s = r && r.slice;
  s ? t.someProp("transformPasted", (h) => {
    s = h(s, t);
  }) : s = M0(t, B0(n.dataTransfer), Oo ? null : n.dataTransfer.getData("text/html"), !1, o);
  let a = !!(r && z0(t, n));
  if (t.someProp("handleDrop", (h) => h(t, n, s || F.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let l = s ? n0(t.state.doc, o.pos, s) : o.pos;
  l == null && (l = o.pos);
  let c = t.state.tr;
  if (a) {
    let { node: h } = r;
    h ? h.replace(c) : c.deleteSelection();
  }
  let d = c.mapping.map(l), u = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = c.doc;
  if (u ? c.replaceRangeWith(d, d, s.content.firstChild) : c.replaceRange(d, d, s), c.doc.eq(f))
    return;
  let p = c.doc.resolve(d);
  if (u && ne.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild))
    c.setSelection(new ne(p));
  else {
    let h = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, C, v) => h = v), c.setSelection(fc(t, p, c.doc.resolve(h)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
Vt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && ar(t);
  }, 20));
};
Vt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Vt.beforeinput = (t, e) => {
  if (It && rr && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (o) => o(t, jr(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in jt)
  Vt[t] = jt[t];
function Lo(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Xs {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || Jr, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: o, deleted: s } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return s ? null : new Tt(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Xs && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Lo(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Ar {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Jr;
  }
  map(e, n, r, i) {
    let o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= s ? null : new Tt(o, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Ar && Lo(this.attrs, e.attrs) && Lo(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ar;
  }
  destroy() {
  }
}
class Cc {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Jr;
  }
  map(e, n, r, i) {
    let o = e.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let s = e.mapResult(n.to + i, -1);
    return s.deleted || s.pos <= o.pos ? null : new Tt(o.pos - r, s.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), o;
    return i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof Cc && Lo(this.attrs, e.attrs) && Lo(this.spec, e.spec);
  }
  destroy() {
  }
}
class Tt {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Tt(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Tt(e, e, new Xs(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new Tt(e, n, new Ar(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new Tt(e, n, new Cc(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ar;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Xs;
  }
}
const vi = [], Jr = {};
class Ke {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : vi, this.children = n.length ? n : vi;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? ea(n, e, 0, Jr) : Rt;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= e && (!o || o(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, r, i + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Rt || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Jr);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? jm(this.children, s || [], e, n, r, i, o) : s ? new Ke(s.sort(Xr), vi) : Rt;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Rt ? Ke.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, o = 0;
    e.forEach((a, l) => {
      let c = l + r, d;
      if (d = F0(n, a, c)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < l; )
          o += 3;
        i[o] == l ? i[o + 2] = i[o + 2].addInner(a, d, c + 1) : i.splice(o, 0, l, l + a.nodeSize, ea(d, a, c + 1, Jr)), o += 3;
      }
    });
    let s = H0(o ? U0(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new Ke(s.length ? this.local.concat(s).sort(Xr) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Rt ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let s, a = r[o] + n, l = r[o + 1] + n;
      for (let d = 0, u; d < e.length; d++)
        (u = e[d]) && u.from > a && u.to < l && (e[d] = null, (s || (s = [])).push(u));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[o + 2].removeInner(s, a + 1);
      c != Rt ? r[o + 2] = c : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, s; o < e.length; o++)
        if (s = e[o])
          for (let a = 0; a < i.length; a++)
            i[a].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Ke(i, r) : Rt;
  }
  forChild(e, n) {
    if (this == Rt)
      return this;
    if (n.isLeaf)
      return Ke.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let o = e + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > o && l.type instanceof Ar) {
        let c = Math.max(o, l.from) - o, d = Math.min(s, l.to) - o;
        c < d && (i || (i = [])).push(l.copy(c, d));
      }
    }
    if (i) {
      let a = new Ke(i.sort(Xr), vi);
      return r ? new yr([a, r]) : a;
    }
    return r || Rt;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Ke) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return bc(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Rt)
      return vi;
    if (e.inlineContent || !this.local.some(Ar.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Ar || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Ke.empty = new Ke([], []);
Ke.removeOverlap = bc;
const Rt = Ke.empty;
class yr {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, Jr));
    return yr.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Ke.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(e, n);
      o != Rt && (o instanceof yr ? r = r.concat(o.members) : r.push(o));
    }
    return yr.from(r);
  }
  eq(e) {
    if (!(e instanceof yr) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(e);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? bc(r ? n : n.sort(Xr)) : vi;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Rt;
      case 1:
        return e[0];
      default:
        return new yr(e.every((n) => n instanceof Ke) ? e : e.reduce((n, r) => n.concat(r instanceof Ke ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function jm(t, e, n, r, i, o, s) {
  let a = t.slice();
  for (let c = 0, d = o; c < n.maps.length; c++) {
    let u = 0;
    n.maps[c].forEach((f, p, h, m) => {
      let g = m - h - (p - f);
      for (let C = 0; C < a.length; C += 3) {
        let v = a[C + 1];
        if (v < 0 || f > v + d - u)
          continue;
        let _ = a[C] + d - u;
        p >= _ ? a[C + 1] = f <= _ ? -2 : -1 : f >= d && g && (a[C] += g, a[C + 1] += g);
      }
      u += g;
    }), d = n.maps[c].map(d, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let d = n.map(t[c] + o), u = d - i;
      if (u < 0 || u >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + o, -1), p = f - i, { index: h, offset: m } = r.content.findIndex(u), g = r.maybeChild(h);
      if (g && m == u && m + g.nodeSize == p) {
        let C = a[c + 2].mapInner(n, g, d + 1, t[c] + o + 1, s);
        C != Rt ? (a[c] = u, a[c + 1] = p, a[c + 2] = C) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = Wm(a, t, e, n, i, o, s), d = ea(c, r, 0, s);
    e = d.local;
    for (let u = 0; u < a.length; u += 3)
      a[u + 1] < 0 && (a.splice(u, 3), u -= 3);
    for (let u = 0, f = 0; u < d.children.length; u += 3) {
      let p = d.children[u];
      for (; f < a.length && a[f] < p; )
        f += 3;
      a.splice(f, 0, d.children[u], d.children[u + 1], d.children[u + 2]);
    }
  }
  return new Ke(e.sort(Xr), a);
}
function H0(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new Tt(i.from + e, i.to + e, i.type));
  }
  return n;
}
function Wm(t, e, n, r, i, o, s) {
  function a(l, c) {
    for (let d = 0; d < l.local.length; d++) {
      let u = l.local[d].map(r, i, c);
      u ? n.push(u) : s.onRemove && s.onRemove(l.local[d].spec);
    }
    for (let d = 0; d < l.children.length; d += 3)
      a(l.children[d + 2], l.children[d] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + o + 1);
  return n;
}
function F0(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let o = 0, s; o < t.length; o++)
    (s = t[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), t[o] = null);
  return i;
}
function U0(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function ea(t, e, n, r) {
  let i = [], o = !1;
  e.forEach((a, l) => {
    let c = F0(t, a, l + n);
    if (c) {
      o = !0;
      let d = ea(c, a, n + l + 1, r);
      d != Rt && i.push(l, l + a.nodeSize, d);
    }
  });
  let s = H0(o ? U0(t) : t, -n).sort(Xr);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || i.length ? new Ke(s, i) : Rt;
}
function Xr(t, e) {
  return t.from - e.from || t.to - e.to;
}
function bc(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let o = e[i];
        if (o.from == r.from) {
          o.to != r.to && (e == t && (e = t.slice()), e[i] = o.copy(o.from, r.to), $u(e, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, o.from), $u(e, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function $u(t, e, n) {
  for (; e < t.length && Xr(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Sl(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Rt && e.push(r);
  }), t.cursorWrapper && e.push(Ke.create(t.state.doc, [t.cursorWrapper.deco])), yr.from(e);
}
const Zm = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, Km = qt && Lr <= 11;
class Gm {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class qm {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Gm(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      qt && Lr <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Km && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Zm)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Lu(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ar(this.view);
      if (qt && Lr <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && oi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = e.focusNode; o; o = Ii(o))
      n.add(o);
    for (let o = e.anchorNode; o; o = Ii(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Lu(e) && !this.ignoreSelectionChange(r), o = -1, s = -1, a = !1, l = [];
    if (e.editable)
      for (let d = 0; d < n.length; d++) {
        let u = this.registerMutation(n[d], l);
        u && (o = o < 0 ? u.from : Math.min(u.from, o), s = s < 0 ? u.to : Math.max(u.to, s), u.typeOver && (a = !0));
      }
    if (Tn && l.length) {
      let d = l.filter((u) => u.nodeName == "BR");
      if (d.length == 2) {
        let [u, f] = d;
        u.parentNode && u.parentNode.parentNode == f.parentNode ? f.remove() : u.remove();
      } else {
        let { focusNode: u } = this.currentSelection;
        for (let f of d) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!u || Jm(e, u) != p) && f.remove();
        }
      }
    }
    let c = null;
    o < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && ja(r) && (c = uc(e)) && c.eq(le.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, ar(e), this.currentSelection.set(r), e.scrollToSelection()) : (o > -1 || i) && (o > -1 && (e.docView.markDirty(o, s), Qm(e)), this.handleDOMChange(o, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || ar(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let d = 0; d < e.addedNodes.length; d++) {
        let u = e.addedNodes[d];
        n.push(u), u.nodeType == 3 && (this.lastChangedTextNode = u);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, o = e.nextSibling;
      if (qt && Lr <= 11 && e.addedNodes.length)
        for (let d = 0; d < e.addedNodes.length; d++) {
          let { previousSibling: u, nextSibling: f } = e.addedNodes[d];
          (!u || Array.prototype.indexOf.call(e.addedNodes, u) < 0) && (i = u), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (o = f);
        }
      let s = i && i.parentNode == e.target ? St(i) + 1 : 0, a = r.localPosFromDOM(e.target, s, -1), l = o && o.parentNode == e.target ? St(o) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let zu = /* @__PURE__ */ new WeakMap(), Hu = !1;
function Qm(t) {
  if (!zu.has(t) && (zu.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = Tn, Hu)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Hu = !0;
  }
}
function Fu(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return oi(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function Ym(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return Fu(t, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? Fu(t, n) : null;
}
function Jm(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function Xm(t, e, n) {
  let { node: r, fromOffset: i, toOffset: o, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, d = l.anchorNode;
  if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (c = [{ node: d, offset: l.anchorOffset }], ja(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), It && t.input.lastKeyCode === 8)
    for (let g = o; g > i; g--) {
      let C = r.childNodes[g - 1], v = C.pmViewDesc;
      if (C.nodeName == "BR" && !v) {
        o = g;
        break;
      }
      if (!v || v.size)
        break;
    }
  let u = t.state.doc, f = t.someProp("domParser") || Tr.fromSchema(t.state.schema), p = u.resolve(s), h = null, m = f.parse(r, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: e8,
    context: p
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, C = c[1] && c[1].pos;
    C == null && (C = g), h = { anchor: g + s, head: C + s };
  }
  return { doc: m, sel: h, from: s, to: a };
}
function e8(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Ut && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || Ut && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const t8 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function n8(t, e, n, r, i) {
  let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let S = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, T = uc(t, S);
    if (T && !t.state.selection.eq(T)) {
      if (It && rr && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (j) => j(t, jr(13, "Enter"))))
        return;
      let D = t.state.tr.setSelection(T);
      S == "pointer" ? D.setMeta("pointer", !0) : S == "key" && D.scrollIntoView(), o && D.setMeta("composition", o), t.dispatch(D);
    }
    return;
  }
  let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
  e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = Xm(t, e, n), d = t.state.doc, u = d.slice(c.from, c.to), f, p;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, p = "end") : (f = t.state.selection.from, p = "start"), t.input.lastKeyCode = null;
  let h = o8(u.content, c.doc.content, c.from, f, p);
  if (h && t.input.domChangeCount++, (Di && t.input.lastIOSEnter > Date.now() - 225 || rr) && i.some((S) => S.nodeType == 1 && !t8.test(S.nodeName)) && (!h || h.endA >= h.endB) && t.someProp("handleKeyDown", (S) => S(t, jr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!h)
    if (r && l instanceof ie && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      h = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let S = Uu(t, t.state.doc, c.sel);
        if (S && !S.eq(t.state.selection)) {
          let T = t.state.tr.setSelection(S);
          o && T.setMeta("composition", o), t.dispatch(T);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && h.start == h.endB && t.state.selection instanceof ie && (h.start > t.state.selection.from && h.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? h.start = t.state.selection.from : h.endA < t.state.selection.to && h.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (h.endB += t.state.selection.to - h.endA, h.endA = t.state.selection.to)), qt && Lr <= 11 && h.endB == h.start + 1 && h.endA == h.start && h.start > c.from && c.doc.textBetween(h.start - c.from - 1, h.start - c.from + 1) == "  " && (h.start--, h.endA--, h.endB--);
  let m = c.doc.resolveNoCache(h.start - c.from), g = c.doc.resolveNoCache(h.endB - c.from), C = d.resolve(h.start), v = m.sameParent(g) && m.parent.inlineContent && C.end() >= h.endA, _;
  if ((Di && t.input.lastIOSEnter > Date.now() - 225 && (!v || i.some((S) => S.nodeName == "DIV" || S.nodeName == "P")) || !v && m.pos < c.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(c.doc.textBetween(m.pos, g.pos, "", "")) && (_ = le.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && _.head > m.pos) && t.someProp("handleKeyDown", (S) => S(t, jr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > h.start && i8(d, h.start, h.endA, m, g) && t.someProp("handleKeyDown", (S) => S(t, jr(8, "Backspace")))) {
    rr && It && t.domObserver.suppressSelectionUpdates();
    return;
  }
  It && h.endB == h.start && (t.input.lastChromeDelete = Date.now()), rr && !v && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == h.endA && (h.endB -= 2, g = c.doc.resolveNoCache(h.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(S) {
      return S(t, jr(13, "Enter"));
    });
  }, 20));
  let b = h.start, x = h.endA, y = (S) => {
    let T = S || t.state.tr.replace(b, x, c.doc.slice(h.start - c.from, h.endB - c.from));
    if (c.sel) {
      let D = Uu(t, T.doc, c.sel);
      D && !(It && t.composing && D.empty && (h.start != h.endB || t.input.lastChromeDelete < Date.now() - 100) && (D.head == b || D.head == T.mapping.map(x) - 1) || qt && D.empty && D.head == b) && T.setSelection(D);
    }
    return o && T.setMeta("composition", o), T.scrollIntoView();
  }, M;
  if (v) {
    if (m.pos == g.pos) {
      qt && Lr <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => ar(t), 20));
      let S = y(t.state.tr.delete(b, x)), T = d.resolve(h.start).marksAcross(d.resolve(h.endA));
      T && S.ensureMarks(T), t.dispatch(S);
    } else if (
      // Adding or removing a mark
      h.endA == h.endB && (M = r8(m.parent.content.cut(m.parentOffset, g.parentOffset), C.parent.content.cut(C.parentOffset, h.endA - C.start())))
    ) {
      let S = y(t.state.tr);
      M.type == "add" ? S.addMark(b, x, M.mark) : S.removeMark(b, x, M.mark), t.dispatch(S);
    } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let S = m.parent.textBetween(m.parentOffset, g.parentOffset), T = () => y(t.state.tr.insertText(S, b, x));
      t.someProp("handleTextInput", (D) => D(t, b, x, S, T)) || t.dispatch(T());
    }
  } else
    t.dispatch(y());
}
function Uu(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : fc(t, e.resolve(n.anchor), e.resolve(n.head));
}
function r8(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, o = r, s, a, l;
  for (let d = 0; d < r.length; d++)
    i = r[d].removeFromSet(i);
  for (let d = 0; d < n.length; d++)
    o = n[d].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    a = i[0], s = "add", l = (d) => d.mark(a.addToSet(d.marks));
  else if (i.length == 0 && o.length == 1)
    a = o[0], s = "remove", l = (d) => d.mark(a.removeFromSet(d.marks));
  else
    return null;
  let c = [];
  for (let d = 0; d < e.childCount; d++)
    c.push(l(e.child(d)));
  if (A.from(c).eq(t))
    return { mark: a, type: s };
}
function i8(t, e, n, r, i) {
  if (
    // The content must have shrunk
    n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Ml(r, !0, !1) < i.pos
  )
    return !1;
  let o = t.resolve(e);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = t.resolve(Ml(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || Ml(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Ml(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let o = t.node(r).maybeChild(t.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function o8(t, e, n, r, i) {
  let o = t.findDiffStart(e, n);
  if (o == null)
    return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    r -= s + l - o;
  }
  if (s < o && t.size < e.size) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, o && o < e.size && Vu(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, o && o < t.size && Vu(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function Vu(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class V0 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new xm(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Gu), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Zu(this), Wu(this), this.nodeViews = Ku(this), this.docView = xu(this.state.doc, ju(this), Sl(this), this.dom, this), this.domObserver = new qm(this, (r, i, o, s) => n8(this, r, i, o, s)), this.domObserver.start(), km(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && S1(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Gu), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let i = this.state, o = !1, s = !1;
    e.storedMarks && this.composing && (P0(this), s = !0), this.state = e;
    let a = i.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let p = Ku(this);
      a8(p, this.nodeViews) && (this.nodeViews = p, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && S1(this), this.editable = Zu(this), Wu(this);
    let l = Sl(this), c = ju(this), d = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", u = o || !this.docView.matchesNode(e.doc, c, l);
    (u || !e.selection.eq(i.selection)) && (s = !0);
    let f = d == "preserve" && s && this.dom.style.overflowAnchor == null && zg(this);
    if (s) {
      this.domObserver.stop();
      let p = u && (qt || It) && !this.composing && !i.selection.empty && !e.selection.empty && s8(i.selection, e.selection);
      if (u) {
        let h = It ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = $m(this)), (o || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = xu(e.doc, c, l, this.dom, this)), h && !this.trackWrites && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && cm(this)) ? ar(this, p) : (x0(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : f && Hg(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ne) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && bu(this, n.getBoundingClientRect(), e);
      } else
        bu(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new $0(e.slice, e.move, i < 0 ? void 0 : ne.create(this.state.doc, i));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[e];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (qt) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && Fg(this.dom), ar(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return Zg(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return m0(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return Yg(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return To(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return To(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return pc(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (Sm(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Sl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Og());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return Om(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Ut && this.root.nodeType === 11 && Rg(this.dom.ownerDocument) == this.dom && Ym(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
V0.prototype.dispatch = function(t) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, t) : this.updateState(this.state.apply(t));
};
function ju(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [Tt.node(0, t.state.doc.content.size, e)];
}
function Wu(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: Tt.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function Zu(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function s8(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function Ku(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function a8(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function Gu(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ir = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ta = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, l8 = typeof navigator < "u" && /Mac/.test(navigator.platform), c8 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Mt = 0; Mt < 10; Mt++) Ir[48 + Mt] = Ir[96 + Mt] = String(Mt);
for (var Mt = 1; Mt <= 24; Mt++) Ir[Mt + 111] = "F" + Mt;
for (var Mt = 65; Mt <= 90; Mt++)
  Ir[Mt] = String.fromCharCode(Mt + 32), ta[Mt] = String.fromCharCode(Mt);
for (var Ol in Ir) ta.hasOwnProperty(Ol) || (ta[Ol] = Ir[Ol]);
function d8(t) {
  var e = l8 && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || c8 && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? ta : Ir)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const u8 = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), f8 = typeof navigator < "u" && /Win/.test(navigator.platform);
function p8(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      u8 ? s = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function h8(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[p8(n)] = t[n];
  return e;
}
function Tl(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function g8(t) {
  return new Qe({ props: { handleKeyDown: yc(t) } });
}
function yc(t) {
  let e = h8(t);
  return function(n, r) {
    let i = d8(r), o, s = e[Tl(i, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = e[Tl(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(f8 && r.ctrlKey && r.altKey) && (o = Ir[r.keyCode]) && o != i) {
        let a = e[Tl(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const vc = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function j0(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const W0 = (t, e, n) => {
  let r = j0(t, n);
  if (!r)
    return !1;
  let i = wc(r);
  if (!i) {
    let s = r.blockRange(), a = s && ji(s);
    return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (e6(t, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Pi(o, "end") || ne.isSelectable(o)))
    for (let s = r.depth; ; s--) {
      let a = Ua(t.doc, r.before(s), r.after(s), F.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(Pi(o, "end") ? le.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : ne.create(l.doc, i.pos - o.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, m8 = (t, e, n) => {
  let r = j0(t, n);
  if (!r)
    return !1;
  let i = wc(r);
  return i ? Z0(t, i, e) : !1;
}, C8 = (t, e, n) => {
  let r = G0(t, n);
  if (!r)
    return !1;
  let i = _c(r);
  return i ? Z0(t, i, e) : !1;
};
function Z0(t, e, n) {
  let r = e.nodeBefore, i = r, o = e.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let d = i.lastChild;
    if (!d)
      return !1;
    i = d;
  }
  let s = e.nodeAfter, a = s, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let d = a.firstChild;
    if (!d)
      return !1;
    a = d;
  }
  let c = Ua(t.doc, o, l, F.empty);
  if (!c || c.from != o || c instanceof mt && c.slice.size >= l - o)
    return !1;
  if (n) {
    let d = t.tr.step(c);
    d.setSelection(ie.create(d.doc, o)), n(d.scrollIntoView());
  }
  return !0;
}
function Pi(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const K0 = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    o = wc(r);
  }
  let s = o && o.nodeBefore;
  return !s || !ne.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function wc(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function G0(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const q0 = (t, e, n) => {
  let r = G0(t, n);
  if (!r)
    return !1;
  let i = _c(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (e6(t, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Pi(o, "start") || ne.isSelectable(o))) {
    let s = Ua(t.doc, r.before(), r.after(), F.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let a = t.tr.step(s);
        a.setSelection(Pi(o, "start") ? le.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ne.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, Q0 = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    o = _c(r);
  }
  let s = o && o.nodeAfter;
  return !s || !ne.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, o.pos)).scrollIntoView()), !0);
};
function _c(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const b8 = (t, e) => {
  let n = t.selection, r = n instanceof ne, i;
  if (r) {
    if (n.node.isTextblock || !Pr(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = Fa(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let o = t.tr.join(i);
    r && o.setSelection(ne.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, y8 = (t, e) => {
  let n = t.selection, r;
  if (n instanceof ne) {
    if (n.node.isTextblock || !Pr(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = Fa(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, v8 = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), o = i && ji(i);
  return o == null ? !1 : (e && e(t.tr.lift(i, o).scrollIntoView()), !0);
}, Y0 = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Ec(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const w8 = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), s = Ec(i.contentMatchAt(o));
  if (!s || !i.canReplaceWith(o, o, s))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(le.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, J0 = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof Gt || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = Ec(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = t.tr.insert(s, o.createAndFill());
    a.setSelection(ie.create(a.doc, s + 1)), e(a.scrollIntoView());
  }
  return !0;
}, X0 = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (sr(t.doc, o))
      return e && e(t.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && ji(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
};
function _8(t) {
  return (e, n) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof ne && e.selection.node.isBlock)
      return !r.parentOffset || !sr(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let o = [], s, a, l = !1, c = !1;
    for (let p = r.depth; ; p--)
      if (r.node(p).isBlock) {
        l = r.end(p) == r.pos + (r.depth - p), c = r.start(p) == r.pos - (r.depth - p), a = Ec(r.node(p - 1).contentMatchAt(r.indexAfter(p - 1))), o.unshift(l && a ? { type: a } : null), s = p;
        break;
      } else {
        if (p == 1)
          return !1;
        o.unshift(null);
      }
    let d = e.tr;
    (e.selection instanceof ie || e.selection instanceof Gt) && d.deleteSelection();
    let u = d.mapping.map(r.pos), f = sr(d.doc, u, o.length, o);
    if (f || (o[0] = a ? { type: a } : null, f = sr(d.doc, u, o.length, o)), !f)
      return !1;
    if (d.split(u, o.length, o), !l && c && r.node(s).type != a) {
      let p = d.mapping.map(r.before(s)), h = d.doc.resolve(p);
      a && r.node(s - 1).canReplaceWith(h.index(), h.index() + 1, a) && d.setNodeMarkup(d.mapping.map(r.before(s)), a);
    }
    return n && n(d.scrollIntoView()), !0;
  };
}
const E8 = _8(), x8 = (t, e) => {
  let { $from: n, to: r } = t.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), e && e(t.tr.setSelection(ne.create(t.doc, i))), !0);
};
function k8(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, o = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(o - 1, o) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(i.isTextblock || Pr(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function e6(t, e, n, r) {
  let i = e.nodeBefore, o = e.nodeAfter, s, a, l = i.type.spec.isolating || o.type.spec.isolating;
  if (!l && k8(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let p = e.pos + o.nodeSize, h = A.empty;
      for (let C = s.length - 1; C >= 0; C--)
        h = A.from(s[C].create(null, h));
      h = A.from(i.copy(h));
      let m = t.tr.step(new yt(e.pos - 1, p, e.pos, p, new F(h, 1, 0), s.length, !0)), g = m.doc.resolve(p + 2 * s.length);
      g.nodeAfter && g.nodeAfter.type == i.type && Pr(m.doc, g.pos) && m.join(g.pos), n(m.scrollIntoView());
    }
    return !0;
  }
  let d = o.type.spec.isolating || r > 0 && l ? null : le.findFrom(e, 1), u = d && d.$from.blockRange(d.$to), f = u && ji(u);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(u, f).scrollIntoView()), !0;
  if (c && Pi(o, "start", !0) && Pi(i, "end")) {
    let p = i, h = [];
    for (; h.push(p), !p.isTextblock; )
      p = p.lastChild;
    let m = o, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (p.canReplace(p.childCount, p.childCount, m.content)) {
      if (n) {
        let C = A.empty;
        for (let _ = h.length - 1; _ >= 0; _--)
          C = A.from(h[_].copy(C));
        let v = t.tr.step(new yt(e.pos - h.length, e.pos + o.nodeSize, e.pos + g, e.pos + o.nodeSize - g, new F(C, h.length, 0), 0, !0));
        n(v.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function t6(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(e.tr.setSelection(ie.create(e.doc, t < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const S8 = t6(-1), M8 = t6(1);
function O8(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && ac(s, t, e);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function qu(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (l, c) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let d = n.doc.resolve(c), u = d.index();
            i = d.parent.canReplaceWith(u, u + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        o.setBlockType(a, l, t, e);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
function xc(...t) {
  return function(e, n, r) {
    for (let i = 0; i < t.length; i++)
      if (t[i](e, n, r))
        return !0;
    return !1;
  };
}
xc(vc, W0, K0);
xc(vc, q0, Q0);
xc(Y0, J0, X0, E8);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function T8(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o);
    if (!s)
      return !1;
    let a = r ? n.tr : null;
    return L8(a, s, t, e) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function L8(t, e, n, r = null) {
  let i = !1, o = e, s = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = s.resolve(e.start - 2);
    o = new Gs(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Gs(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), i = !0;
  }
  let a = ac(o, n, r, e);
  return a ? (t && N8(t, e, a, i, n), !0) : !1;
}
function N8(t, e, n, r, i) {
  let o = A.empty;
  for (let d = n.length - 1; d >= 0; d--)
    o = A.from(n[d].type.create(n[d].attrs, o));
  t.step(new yt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new F(o, 0, 0), n.length, !0));
  let s = 0;
  for (let d = 0; d < n.length; d++)
    n[d].type == i && (s = d + 1);
  let a = n.length - s, l = e.start + n.length - (r ? 2 : 0), c = e.parent;
  for (let d = e.startIndex, u = e.endIndex, f = !0; d < u; d++, f = !1)
    !f && sr(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(d).nodeSize;
  return t;
}
function A8(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == t);
    return o ? n ? r.node(o.depth - 1).type == t ? R8(e, n, t, o) : I8(e, n, o) : !0 : !1;
  };
}
function R8(t, e, n, r) {
  let i = t.tr, o = r.end, s = r.$to.end(r.depth);
  o < s && (i.step(new yt(o - 1, s, o, s, new F(A.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Gs(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth));
  const a = ji(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.doc.resolve(i.mapping.map(o, -1) - 1);
  return Pr(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos), e(i.scrollIntoView()), !0;
}
function I8(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let p = n.end, h = n.endIndex - 1, m = n.startIndex; h > m; h--)
    p -= i.child(h).nodeSize, r.delete(p - 1, p + 1);
  let o = r.doc.resolve(n.start), s = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == i.childCount, c = o.node(-1), d = o.index(-1);
  if (!c.canReplace(d + (a ? 0 : 1), d + 1, s.content.append(l ? A.empty : A.from(i))))
    return !1;
  let u = o.pos, f = u + s.nodeSize;
  return r.step(new yt(u - (a ? 1 : 0), f + (l ? 1 : 0), u + 1, f - 1, new F((a ? A.empty : A.from(i.copy(A.empty))).append(l ? A.empty : A.from(i.copy(A.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function D8(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, l = a.child(s - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, d = A.from(c ? t.create() : null), u = new F(A.from(t.create(null, A.from(a.type.create(null, d)))), c ? 3 : 1, 0), f = o.start, p = o.end;
      n(e.tr.step(new yt(f - (c ? 3 : 1), p, f, p, u, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Ka(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
class Ga {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: o } = r, s = this.buildProps(o);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...d) => {
      const u = l(...d)(s);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(o), u;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: s } = i, a = [], l = !!e, c = e || o.tr, d = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c), a.every((f) => f === !0)), u = {
      ...Object.fromEntries(Object.entries(r).map(([f, p]) => [f, (...m) => {
        const g = this.buildProps(c, n), C = p(...m)(g);
        return a.push(C), u;
      }])),
      run: d
    };
    return u;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, i = !1, o = e || r.tr, s = this.buildProps(o, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...d) => c(...d)({ ...s, dispatch: void 0 })])),
      chain: () => this.createChain(o, i)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: s } = i, a = {
      tr: e,
      editor: i,
      view: s,
      state: Ka({
        state: o,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...d) => c(...d)(a)]));
      }
    };
    return a;
  }
}
let P8 = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const r = (...i) => {
      this.off(e, r), n.apply(this, i);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function q(t, e, n) {
  return t.config[e] === void 0 && t.parent ? q(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? q(t.parent, e, n) : null
  }) : t.config[e];
}
function qa(t) {
  const e = t.filter((i) => i.type === "extension"), n = t.filter((i) => i.type === "node"), r = t.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function n6(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = qa(t), i = [...n, ...r], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: i
    }, l = q(s, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((d) => {
      d.types.forEach((u) => {
        Object.entries(d.attributes).forEach(([f, p]) => {
          e.push({
            type: u,
            name: f,
            attribute: {
              ...o,
              ...p
            }
          });
        });
      });
    });
  }), i.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = q(s, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([d, u]) => {
      const f = {
        ...o,
        ...u
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: s.name,
        name: d,
        attribute: f
      });
    });
  }), e;
}
function wt(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Be(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const a = o ? String(o).split(" ") : [], l = r[i] ? r[i].split(" ") : [], c = a.filter((d) => !l.includes(d));
        r[i] = [...l, ...c].join(" ");
      } else if (i === "style") {
        const a = o ? o.split(";").map((d) => d.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map((d) => d.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((d) => {
          const [u, f] = d.split(":").map((p) => p.trim());
          c.set(u, f);
        }), a.forEach((d) => {
          const [u, f] = d.split(":").map((p) => p.trim());
          c.set(u, f);
        }), r[i] = Array.from(c.entries()).map(([d, u]) => `${d}: ${u}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function M1(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => Be(n, r), {});
}
function r6(t) {
  return typeof t == "function";
}
function xe(t, e = void 0, ...n) {
  return r6(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function B8(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function $8(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function Qu(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : $8(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function Yu(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && B8(n) ? !1 : n != null)
  );
}
function z8(t, e) {
  var n;
  const r = n6(t), { nodeExtensions: i, markExtensions: o } = qa(t), s = (n = i.find((c) => q(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(i.map((c) => {
    const d = r.filter((C) => C.type === c.name), u = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((C, v) => {
      const _ = q(v, "extendNodeSchema", u);
      return {
        ...C,
        ..._ ? _(c) : {}
      };
    }, {}), p = Yu({
      ...f,
      content: xe(q(c, "content", u)),
      marks: xe(q(c, "marks", u)),
      group: xe(q(c, "group", u)),
      inline: xe(q(c, "inline", u)),
      atom: xe(q(c, "atom", u)),
      selectable: xe(q(c, "selectable", u)),
      draggable: xe(q(c, "draggable", u)),
      code: xe(q(c, "code", u)),
      whitespace: xe(q(c, "whitespace", u)),
      linebreakReplacement: xe(q(c, "linebreakReplacement", u)),
      defining: xe(q(c, "defining", u)),
      isolating: xe(q(c, "isolating", u)),
      attrs: Object.fromEntries(d.map((C) => {
        var v;
        return [C.name, { default: (v = C == null ? void 0 : C.attribute) === null || v === void 0 ? void 0 : v.default }];
      }))
    }), h = xe(q(c, "parseHTML", u));
    h && (p.parseDOM = h.map((C) => Qu(C, d)));
    const m = q(c, "renderHTML", u);
    m && (p.toDOM = (C) => m({
      node: C,
      HTMLAttributes: M1(C, d)
    }));
    const g = q(c, "renderText", u);
    return g && (p.toText = g), [c.name, p];
  })), l = Object.fromEntries(o.map((c) => {
    const d = r.filter((g) => g.type === c.name), u = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((g, C) => {
      const v = q(C, "extendMarkSchema", u);
      return {
        ...g,
        ...v ? v(c) : {}
      };
    }, {}), p = Yu({
      ...f,
      inclusive: xe(q(c, "inclusive", u)),
      excludes: xe(q(c, "excludes", u)),
      group: xe(q(c, "group", u)),
      spanning: xe(q(c, "spanning", u)),
      code: xe(q(c, "code", u)),
      attrs: Object.fromEntries(d.map((g) => {
        var C;
        return [g.name, { default: (C = g == null ? void 0 : g.attribute) === null || C === void 0 ? void 0 : C.default }];
      }))
    }), h = xe(q(c, "parseHTML", u));
    h && (p.parseDOM = h.map((g) => Qu(g, d)));
    const m = q(c, "renderHTML", u);
    return m && (p.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: M1(g, d)
    })), [c.name, p];
  }));
  return new Wh({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function Ll(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function Ju(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function kc(t, e) {
  const n = ui.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
const H8 = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (i, o, s, a) => {
    var l, c;
    const d = ((c = (l = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: i,
      pos: o,
      parent: s,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? d : d.slice(0, Math.max(0, r - o));
  }), n;
};
function Sc(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Qa {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const F8 = (t, e) => {
  if (Sc(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function ls(t) {
  var e;
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let d = !1;
  const u = H8(c) + o;
  return s.forEach((f) => {
    if (d)
      return;
    const p = F8(u, f.find);
    if (!p)
      return;
    const h = l.state.tr, m = Ka({
      state: l.state,
      transaction: h
    }), g = {
      from: r - (p[0].length - o.length),
      to: i
    }, { commands: C, chain: v, can: _ } = new Ga({
      editor: n,
      state: m
    });
    f.handler({
      state: m,
      range: g,
      match: p,
      commands: C,
      chain: v,
      can: _
    }) === null || !h.steps.length || (h.setMeta(a, {
      transform: h,
      from: r,
      to: i,
      text: o
    }), l.dispatch(h), d = !0);
  }), d;
}
function U8(t) {
  const { editor: e, rules: n } = t, r = new Qe({
    state: {
      init() {
        return null;
      },
      apply(i, o, s) {
        const a = i.getMeta(r);
        if (a)
          return a;
        const l = i.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: d } = l;
          typeof d == "string" ? d = d : d = kc(A.from(d), s.schema);
          const { from: u } = l, f = u + d.length;
          ls({
            editor: e,
            from: u,
            to: f,
            text: d,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, s, a) {
        return ls({
          editor: e,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && ls({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = i.state.selection;
        return s ? ls({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function V8(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function cs(t) {
  return V8(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Ya(t, e) {
  const n = { ...t };
  return cs(t) && cs(e) && Object.keys(e).forEach((r) => {
    cs(e[r]) && cs(t[r]) ? n[r] = Ya(t[r], e[r]) : n[r] = e[r];
  }), n;
}
class vn {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = xe(q(this, "addOptions", {
      name: this.name
    }))), this.storage = xe(q(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new vn(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Ya(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new vn(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = xe(q(n, "addOptions", {
      name: n.name
    })), n.storage = xe(q(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const s = i.marks();
      if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
function j8(t) {
  return typeof t == "number";
}
class W8 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const Z8 = (t, e, n) => {
  if (Sc(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = t, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function K8(t) {
  const { editor: e, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: a } = t, { commands: l, chain: c, can: d } = new Ga({
    editor: e,
    state: n
  }), u = [];
  return n.doc.nodesBetween(r, i, (p, h) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const m = Math.max(r, h), g = Math.min(i, h + p.content.size), C = p.textBetween(m - h, g - h, void 0, "￼");
    Z8(C, o.find, s).forEach((_) => {
      if (_.index === void 0)
        return;
      const b = m + _.index + 1, x = b + _[0].length, y = {
        from: n.tr.mapping.map(b),
        to: n.tr.mapping.map(x)
      }, M = o.handler({
        state: n,
        range: y,
        match: _,
        commands: l,
        chain: c,
        can: d,
        pasteEvent: s,
        dropEvent: a
      });
      u.push(M);
    });
  }), u.every((p) => p !== null);
}
let ds = null;
const G8 = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function q8(t) {
  const { editor: e, rules: n } = t;
  let r = null, i = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: d, from: u, to: f, rule: p, pasteEvt: h }) => {
    const m = d.tr, g = Ka({
      state: d,
      transaction: m
    });
    if (!(!K8({
      editor: e,
      state: g,
      from: Math.max(u - 1, 0),
      to: f.b - 1,
      rule: p,
      pasteEvent: h,
      dropEvent: a
    }) || !m.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
    }
  };
  return n.map((d) => new Qe({
    // we register a global drag handler to track the current drag source element
    view(u) {
      const f = (h) => {
        var m;
        r = !((m = u.dom.parentElement) === null || m === void 0) && m.contains(h.target) ? u.dom.parentElement : null, r && (ds = e);
      }, p = () => {
        ds && (ds = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", p), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", p);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (u, f) => {
          if (o = r === u.dom.parentElement, a = f, !o) {
            const p = ds;
            p && setTimeout(() => {
              const h = p.state.selection;
              h && p.commands.deleteRange({ from: h.from, to: h.to });
            }, 10);
          }
          return !1;
        },
        paste: (u, f) => {
          var p;
          const h = (p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return s = f, i = !!(h != null && h.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (u, f, p) => {
      const h = u[0], m = h.getMeta("uiEvent") === "paste" && !i, g = h.getMeta("uiEvent") === "drop" && !o, C = h.getMeta("applyPasteRules"), v = !!C;
      if (!m && !g && !v)
        return;
      if (v) {
        let { text: x } = C;
        typeof x == "string" ? x = x : x = kc(A.from(x), p.schema);
        const { from: y } = C, M = y + x.length, S = G8(x);
        return l({
          rule: d,
          state: p,
          from: y,
          to: { b: M },
          pasteEvt: S
        });
      }
      const _ = f.doc.content.findDiffStart(p.doc.content), b = f.doc.content.findDiffEnd(p.doc.content);
      if (!(!j8(_) || !b || _ === b.b))
        return l({
          rule: d,
          state: p,
          from: _,
          to: b,
          pasteEvt: s
        });
    }
  }));
}
function Q8(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class Oi {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Oi.resolve(e), this.schema = z8(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = Oi.sort(Oi.flatten(e)), r = Q8(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = q(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, i) => {
      const o = q(r, "priority") || 100, s = q(i, "priority") || 100;
      return o > s ? -1 : o < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: Ll(n.name, this.schema)
      }, i = q(n, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = Oi.sort([...this.extensions].reverse()), r = [], i = [], o = n.map((s) => {
      const a = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        editor: e,
        type: Ll(s.name, this.schema)
      }, l = [], c = q(s, "addKeyboardShortcuts", a);
      let d = {};
      if (s.type === "mark" && q(s, "exitable", a) && (d.ArrowRight = () => vn.handleExit({ editor: e, mark: s })), c) {
        const m = Object.fromEntries(Object.entries(c()).map(([g, C]) => [g, () => C({ editor: e })]));
        d = { ...d, ...m };
      }
      const u = g8(d);
      l.push(u);
      const f = q(s, "addInputRules", a);
      Ju(s, e.options.enableInputRules) && f && r.push(...f());
      const p = q(s, "addPasteRules", a);
      Ju(s, e.options.enablePasteRules) && p && i.push(...p());
      const h = q(s, "addProseMirrorPlugins", a);
      if (h) {
        const m = h();
        l.push(...m);
      }
      return l;
    }).flat();
    return [
      U8({
        editor: e,
        rules: r
      }),
      ...q8({
        editor: e,
        rules: i
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return n6(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = qa(this.extensions);
    return Object.fromEntries(n.filter((r) => !!q(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), o = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: wt(r.name, this.schema)
      }, s = q(r, "addNodeView", o);
      if (!s)
        return [];
      const a = (l, c, d, u, f) => {
        const p = M1(l, i);
        return s()({
          // pass-through
          node: l,
          view: c,
          getPos: d,
          decorations: u,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: r,
          HTMLAttributes: p
        });
      };
      return [r.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: Ll(e.name, this.schema)
      };
      e.type === "mark" && (!((n = xe(q(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const i = q(e, "onBeforeCreate", r), o = q(e, "onCreate", r), s = q(e, "onUpdate", r), a = q(e, "onSelectionUpdate", r), l = q(e, "onTransaction", r), c = q(e, "onFocus", r), d = q(e, "onBlur", r), u = q(e, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), d && this.editor.on("blur", d), u && this.editor.on("destroy", u);
    });
  }
}
class qe {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = xe(q(this, "addOptions", {
      name: this.name
    }))), this.storage = xe(q(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new qe(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Ya(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new qe({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = xe(q(n, "addOptions", {
      name: n.name
    })), n.storage = xe(q(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function i6(t, e, n) {
  const { from: r, to: i } = e, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return t.nodesBetween(r, i, (l, c, d, u) => {
    var f;
    l.isBlock && c > r && (a += o);
    const p = s == null ? void 0 : s[l.type.name];
    if (p)
      return d && (a += p({
        node: l,
        pos: c,
        parent: d,
        index: u,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, c) - c, i - c));
  }), a;
}
function Mc(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const Y8 = qe.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Qe({
        key: new ct("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: o } = i, s = Math.min(...o.map((d) => d.$from.pos)), a = Math.max(...o.map((d) => d.$to.pos)), l = Mc(n);
            return i6(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), J8 = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), X8 = (t = !1) => ({ commands: e }) => e.setContent("", t), e5 = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: s }) => {
    t.doc.nodesBetween(o.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: d } = e, u = c.resolve(d.map(l)), f = c.resolve(d.map(l + a.nodeSize)), p = u.blockRange(f);
      if (!p)
        return;
      const h = ji(p);
      if (a.type.isTextblock) {
        const { defaultType: m } = u.parent.contentMatchAt(u.index());
        e.setNodeMarkup(p.start, m);
      }
      (h || h === 0) && e.lift(p, h);
    });
  }), !0;
}, t5 = (t) => (e) => t(e), n5 = () => ({ state: t, dispatch: e }) => J0(t, e), r5 = (t, e) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const s = r.mapping.map(e);
  return r.insert(s, o.content), r.setSelection(new ie(r.doc.resolve(s - 1))), !0;
}, i5 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = t.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (e) {
        const a = i.before(o), l = i.after(o);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, o5 = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const i = wt(t, n.schema), o = e.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === i) {
      if (r) {
        const l = o.before(s), c = o.after(s);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, s5 = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: i } = t;
  return n && e.delete(r, i), !0;
}, a5 = () => ({ state: t, dispatch: e }) => vc(t, e), l5 = () => ({ commands: t }) => t.keyboardShortcut("Enter"), c5 = () => ({ state: t, dispatch: e }) => w8(t, e);
function na(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => n.strict ? e[i] === t[i] : Sc(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0;
}
function o6(t, e, n = {}) {
  return t.find((r) => r.type === e && na(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function Xu(t, e, n = {}) {
  return !!o6(t, e, n);
}
function Oc(t, e, n) {
  var r;
  if (!t || !e)
    return;
  let i = t.parent.childAfter(t.parentOffset);
  if ((!i.node || !i.node.marks.some((d) => d.type === e)) && (i = t.parent.childBefore(t.parentOffset)), !i.node || !i.node.marks.some((d) => d.type === e) || (n = n || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !o6([...i.node.marks], e, n)))
    return;
  let s = i.index, a = t.start() + i.offset, l = s + 1, c = a + i.node.nodeSize;
  for (; s > 0 && Xu([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, a -= t.parent.child(s).nodeSize;
  for (; l < t.parent.childCount && Xu([...t.parent.child(l).marks], e, n); )
    c += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function $r(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const d5 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = $r(t, r.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: d } = a;
  if (i) {
    const u = Oc(l, o, e);
    if (u && u.from <= c && u.to >= d) {
      const f = ie.create(s, u.from, u.to);
      n.setSelection(f);
    }
  }
  return !0;
}, u5 = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function Tc(t) {
  return t instanceof ie;
}
function ir(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function s6(t, e = null) {
  if (!e)
    return null;
  const n = le.atStart(t), r = le.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const i = n.from, o = r.to;
  return e === "all" ? ie.create(t, ir(0, i, o), ir(t.content.size, i, o)) : ie.create(t, ir(e, i, o), ir(e, i, o));
}
function a6() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Ja() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const f5 = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    (Ja() || a6()) && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (o && t === null && !Tc(n.state.selection))
    return s(), !0;
  const a = s6(i.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return o && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
}, p5 = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })), h5 = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), l6 = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && l6(r);
  }
  return t;
};
function us(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return l6(n);
}
function No(t, e, n) {
  if (t instanceof Or || t instanceof A)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, i = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return A.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", o), No("", e, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new Wh({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Tr.fromSchema(l).parseSlice(us(t), n.parseOptions) : Tr.fromSchema(l).parse(us(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const o = Tr.fromSchema(e);
    return n.slice ? o.parseSlice(us(t), n.parseOptions).content : o.parse(us(t), n.parseOptions);
  }
  return No("", e, n);
}
function g5(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const i = t.steps[r];
  if (!(i instanceof mt || i instanceof yt))
    return;
  const o = t.mapping.maps[r];
  let s = 0;
  o.forEach((a, l, c, d) => {
    s === 0 && (s = d);
  }), t.setSelection(le.near(t.doc.resolve(s), n));
}
const m5 = (t) => !("type" in t), C5 = (t, e, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var s;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const l = (g) => {
      o.emit("contentError", {
        editor: o,
        error: g,
        disableCollaboration: () => {
          o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      });
    }, c = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
      try {
        No(e, o.schema, {
          parseOptions: c,
          errorOnInvalidContent: !0
        });
      } catch (g) {
        l(g);
      }
    try {
      a = No(e, o.schema, {
        parseOptions: c,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : o.options.enableContentCheck
      });
    } catch (g) {
      return l(g), !1;
    }
    let { from: d, to: u } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, f = !0, p = !0;
    if ((m5(a) ? a : [a]).forEach((g) => {
      g.check(), f = f ? g.isText && g.marks.length === 0 : !1, p = p ? g.isBlock : !1;
    }), d === u && p) {
      const { parent: g } = r.doc.resolve(d);
      g.isTextblock && !g.type.spec.code && !g.childCount && (d -= 1, u += 1);
    }
    let m;
    if (f) {
      if (Array.isArray(e))
        m = e.map((g) => g.text || "").join("");
      else if (e instanceof A) {
        let g = "";
        e.forEach((C) => {
          C.text && (g += C.text);
        }), m = g;
      } else typeof e == "object" && e && e.text ? m = e.text : m = e;
      r.insertText(m, d, u);
    } else
      m = a, r.replaceWith(d, u, m);
    n.updateSelection && g5(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: d, text: m }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: d, text: m });
  }
  return !0;
}, b5 = () => ({ state: t, dispatch: e }) => b8(t, e), y5 = () => ({ state: t, dispatch: e }) => y8(t, e), v5 = () => ({ state: t, dispatch: e }) => W0(t, e), w5 = () => ({ state: t, dispatch: e }) => q0(t, e), _5 = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Fa(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, E5 = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Fa(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, x5 = () => ({ state: t, dispatch: e }) => m8(t, e), k5 = () => ({ state: t, dispatch: e }) => C8(t, e);
function c6() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function S5(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      Ja() || c6() ? s = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
const M5 = (t) => ({ editor: e, view: n, tr: r, dispatch: i }) => {
  const o = S5(t).split(/-(?!$)/), s = o.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const d = c.map(r.mapping);
    d && i && r.maybeStep(d);
  }), !0;
};
function Ao(t, e, n = {}) {
  const { from: r, to: i, empty: o } = t.selection, s = e ? wt(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, i, (u, f) => {
    if (u.isText)
      return;
    const p = Math.max(r, f), h = Math.min(i, f + u.nodeSize);
    a.push({
      node: u,
      from: p,
      to: h
    });
  });
  const l = i - r, c = a.filter((u) => s ? s.name === u.node.type.name : !0).filter((u) => na(u.node.attrs, n, { strict: !1 }));
  return o ? !!c.length : c.reduce((u, f) => u + f.to - f.from, 0) >= l;
}
const O5 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = wt(t, n.schema);
  return Ao(n, i, e) ? v8(n, r) : !1;
}, T5 = () => ({ state: t, dispatch: e }) => X0(t, e), L5 = (t) => ({ state: e, dispatch: n }) => {
  const r = wt(t, e.schema);
  return A8(r)(e, n);
}, N5 = () => ({ state: t, dispatch: e }) => Y0(t, e);
function Xa(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function ef(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
const A5 = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = Xa(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (o = wt(t, r.schema)), a === "mark" && (s = $r(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, d) => {
      o && o === c.type && n.setNodeMarkup(d, void 0, ef(c.attrs, e)), s && c.marks.length && c.marks.forEach((u) => {
        s === u.type && n.addMark(d, d + c.nodeSize, s.create(ef(u.attrs, e)));
      });
    });
  }), !0) : !1;
}, R5 = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), I5 = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new Gt(t.doc);
    t.setSelection(n);
  }
  return !0;
}, D5 = () => ({ state: t, dispatch: e }) => K0(t, e), P5 = () => ({ state: t, dispatch: e }) => Q0(t, e), B5 = () => ({ state: t, dispatch: e }) => x8(t, e), $5 = () => ({ state: t, dispatch: e }) => M8(t, e), z5 = () => ({ state: t, dispatch: e }) => S8(t, e);
function O1(t, e, n = {}, r = {}) {
  return No(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const H5 = (t, e = !1, n = {}, r = {}) => ({ editor: i, tr: o, dispatch: s, commands: a }) => {
  var l, c;
  const { doc: d } = o;
  if (n.preserveWhitespace !== "full") {
    const u = O1(t, i.schema, n, {
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
    return s && o.replaceWith(0, d.content.size, u).setMeta("preventUpdate", !e), !0;
  }
  return s && o.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: d.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck
  });
};
function d6(t, e) {
  const n = $r(e, t.schema), { from: r, to: i, empty: o } = t.selection, s = [];
  o ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function F5(t, e) {
  const n = new lc(t);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function U5(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function T1(t, e) {
  const n = [];
  return t.descendants((r, i) => {
    e(r) && n.push({
      node: r,
      pos: i
    });
  }), n;
}
function V5(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function u6(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Lc(t) {
  return (e) => u6(e.$from, t);
}
function f6(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return i6(t, n, e);
}
function j5(t, e) {
  const n = wt(e, t.schema), { from: r, to: i } = t.selection, o = [];
  t.doc.nodesBetween(r, i, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function p6(t, e) {
  const n = Xa(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? j5(t, e) : n === "mark" ? d6(t, e) : {};
}
function W5(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function Z5(t) {
  const e = W5(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((o, s) => s !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function K5(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((i, o) => {
    const s = [];
    if (i.ranges.length)
      i.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[o];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = e.slice(o).map(a, -1), d = e.slice(o).map(l), u = e.invert().map(c, -1), f = e.invert().map(d);
      r.push({
        oldRange: {
          from: u,
          to: f
        },
        newRange: {
          from: c,
          to: d
        }
      });
    });
  }), Z5(r);
}
function Nc(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((i) => {
    const o = n.resolve(t), s = Oc(o, i.type);
    s && r.push({
      mark: i,
      ...s
    });
  }) : n.nodesBetween(t, e, (i, o) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map((s) => ({
      from: o,
      to: o + i.nodeSize,
      mark: s
    })));
  }), r;
}
function Ps(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = t.find((o) => o.type === e && o.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function L1(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection, o = e ? $r(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((u) => o ? o.name === u.type.name : !0).find((u) => na(u.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (i.forEach(({ $from: u, $to: f }) => {
    const p = u.pos, h = f.pos;
    t.doc.nodesBetween(p, h, (m, g) => {
      if (!m.isText && !m.marks.length)
        return;
      const C = Math.max(p, g), v = Math.min(h, g + m.nodeSize), _ = v - C;
      s += _, a.push(...m.marks.map((b) => ({
        mark: b,
        from: C,
        to: v
      })));
    });
  }), s === 0)
    return !1;
  const l = a.filter((u) => o ? o.name === u.mark.type.name : !0).filter((u) => na(u.mark.attrs, n, { strict: !1 })).reduce((u, f) => u + f.to - f.from, 0), c = a.filter((u) => o ? u.mark.type !== o && u.mark.type.excludes(o) : !0).reduce((u, f) => u + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function G5(t, e, n = {}) {
  if (!e)
    return Ao(t, null, n) || L1(t, null, n);
  const r = Xa(e, t.schema);
  return r === "node" ? Ao(t, e, n) : r === "mark" ? L1(t, e, n) : !1;
}
function N1(t, e) {
  const { nodeExtensions: n } = qa(e), r = n.find((s) => s.name === t);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = xe(q(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function Ac(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let i = !0;
    return t.content.forEach((o) => {
      i !== !1 && (Ac(o, { ignoreWhitespace: n, checkChildren: e }) || (i = !1));
    }), i;
  }
  return !1;
}
function h6(t) {
  return t instanceof ne;
}
function g6(t, e, n) {
  const i = t.state.doc.content.size, o = ir(e, 0, i), s = ir(n, 0, i), a = t.coordsAtPos(o), l = t.coordsAtPos(s, -1), c = Math.min(a.top, l.top), d = Math.max(a.bottom, l.bottom), u = Math.min(a.left, l.left), f = Math.max(a.right, l.right), p = f - u, h = d - c, C = {
    top: c,
    bottom: d,
    left: u,
    right: f,
    width: p,
    height: h,
    x: u,
    y: c
  };
  return {
    ...C,
    toJSON: () => C
  };
}
function q5(t, e, n) {
  var r;
  const { selection: i } = e;
  let o = null;
  if (Tc(i) && (o = i.$cursor), o) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = i;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (d, u, f) => {
      if (c)
        return !1;
      if (d.isInline) {
        const p = !f || f.type.allowsMarkType(n), h = !!n.isInSet(d.marks) || !d.marks.some((m) => m.type.excludes(n));
        c = p && h;
      }
      return !c;
    }), c;
  });
}
const Q5 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, l = $r(t, r.schema);
  if (i)
    if (s) {
      const c = d6(r, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const d = c.$from.pos, u = c.$to.pos;
        r.doc.nodesBetween(d, u, (f, p) => {
          const h = Math.max(p, d), m = Math.min(p + f.nodeSize, u);
          f.marks.find((C) => C.type === l) ? f.marks.forEach((C) => {
            l === C.type && n.addMark(h, m, l.create({
              ...C.attrs,
              ...e
            }));
          }) : n.addMark(h, m, l.create(e));
        });
      });
  return q5(r, n, l);
}, Y5 = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), J5 = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = wt(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: a }) => qu(o, { ...s, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => qu(o, { ...s, ...e })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, X5 = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, i = ir(t, 0, r.content.size), o = ne.create(r, i);
    e.setSelection(o);
  }
  return !0;
}, e3 = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: i, to: o } = typeof t == "number" ? { from: t, to: t } : t, s = ie.atStart(r).from, a = ie.atEnd(r).to, l = ir(i, s, a), c = ir(o, s, a), d = ie.create(r, l, c);
    e.setSelection(d);
  }
  return !0;
}, t3 = (t) => ({ state: e, dispatch: n }) => {
  const r = wt(t, e.schema);
  return D8(r)(e, n);
};
function tf(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    t.tr.ensureMarks(r);
  }
}
const n3 = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: s } = e, { $from: a, $to: l } = o, c = i.extensionManager.attributes, d = Ps(c, a.node().type.name, a.node().attrs);
  if (o instanceof ne && o.node.isBlock)
    return !a.parentOffset || !sr(s, a.pos) ? !1 : (r && (t && tf(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const u = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : U5(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let p = u && f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0, h = sr(e.doc, e.mapping.map(a.pos), 1, p);
  if (!p && !h && sr(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (h = !0, p = f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0), r) {
    if (h && (o instanceof ie && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, p), f && !u && !a.parentOffset && a.parent.type !== f)) {
      const m = e.mapping.map(a.before()), g = e.doc.resolve(m);
      a.node(-1).canReplaceWith(g.index(), g.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && tf(n, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return h;
}, r3 = (t, e = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var s;
  const a = wt(t, r.schema), { $from: l, $to: c } = r.selection, d = r.selection.node;
  if (d && d.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const u = l.node(-1);
  if (u.type !== a)
    return !1;
  const f = o.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (i) {
      let C = A.empty;
      const v = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let S = l.depth - v; S >= l.depth - 3; S -= 1)
        C = A.from(l.node(S).copy(C));
      const _ = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, b = {
        ...Ps(f, l.node().type.name, l.node().attrs),
        ...e
      }, x = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(b)) || void 0;
      C = C.append(A.from(a.createAndFill(null, x) || void 0));
      const y = l.before(l.depth - (v - 1));
      n.replace(y, l.after(-_), new F(C, 4 - v, 0));
      let M = -1;
      n.doc.nodesBetween(y, n.doc.content.size, (S, T) => {
        if (M > -1)
          return !1;
        S.isTextblock && S.content.size === 0 && (M = T + 1);
      }), M > -1 && n.setSelection(ie.near(n.doc.resolve(M))), n.scrollIntoView();
    }
    return !0;
  }
  const p = c.pos === l.end() ? u.contentMatchAt(0).defaultType : null, h = {
    ...Ps(f, u.type.name, u.attrs),
    ...e
  }, m = {
    ...Ps(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const g = p ? [
    { type: a, attrs: h },
    { type: p, attrs: m }
  ] : [{ type: a, attrs: h }];
  if (!sr(n.doc, l.pos, 2))
    return !1;
  if (i) {
    const { selection: C, storedMarks: v } = r, { splittableMarks: _ } = o.extensionManager, b = v || C.$to.parentOffset && C.$from.marks();
    if (n.split(l.pos, 2, g).scrollIntoView(), !b || !i)
      return !0;
    const x = b.filter((y) => _.includes(y.type.name));
    n.ensureMarks(x);
  }
  return !0;
}, Nl = (t, e) => {
  const n = Lc((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Pr(t.doc, n.pos) && t.join(n.pos), !0;
}, Al = (t, e) => {
  const n = Lc((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Pr(t.doc, r) && t.join(r), !0;
}, i3 = (t, e, n, r = {}) => ({ editor: i, tr: o, state: s, dispatch: a, chain: l, commands: c, can: d }) => {
  const { extensions: u, splittableMarks: f } = i.extensionManager, p = wt(t, s.schema), h = wt(e, s.schema), { selection: m, storedMarks: g } = s, { $from: C, $to: v } = m, _ = C.blockRange(v), b = g || m.$to.parentOffset && m.$from.marks();
  if (!_)
    return !1;
  const x = Lc((y) => N1(y.type.name, u))(m);
  if (_.depth >= 1 && x && _.depth - x.depth <= 1) {
    if (x.node.type === p)
      return c.liftListItem(h);
    if (N1(x.node.type.name, u) && p.validContent(x.node.content) && a)
      return l().command(() => (o.setNodeMarkup(x.pos, p), !0)).command(() => Nl(o, p)).command(() => Al(o, p)).run();
  }
  return !n || !b || !a ? l().command(() => d().wrapInList(p, r) ? !0 : c.clearNodes()).wrapInList(p, r).command(() => Nl(o, p)).command(() => Al(o, p)).run() : l().command(() => {
    const y = d().wrapInList(p, r), M = b.filter((S) => f.includes(S.type.name));
    return o.ensureMarks(M), y ? !0 : c.clearNodes();
  }).wrapInList(p, r).command(() => Nl(o, p)).command(() => Al(o, p)).run();
}, o3 = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = $r(t, r.schema);
  return L1(r, s, e) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, e);
}, s3 = (t, e, n = {}) => ({ state: r, commands: i }) => {
  const o = wt(t, r.schema), s = wt(e, r.schema), a = Ao(r, o, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? i.setNode(s, l) : i.setNode(o, { ...l, ...n });
}, a3 = (t, e = {}) => ({ state: n, commands: r }) => {
  const i = wt(t, n.schema);
  return Ao(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, l3 = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(t))) {
      if (e) {
        const s = t.tr, a = o.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (o.text) {
          const l = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, t.schema.text(o.text, l));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, c3 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: i } = n;
  return r || e && i.forEach((o) => {
    t.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, d3 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: a } = n, l = $r(t, r.schema), { $from: c, empty: d, ranges: u } = a;
  if (!i)
    return !0;
  if (d && s) {
    let { from: f, to: p } = a;
    const h = (o = c.marks().find((g) => g.type === l)) === null || o === void 0 ? void 0 : o.attrs, m = Oc(c, l, h);
    m && (f = m.from, p = m.to), n.removeMark(f, p, l);
  } else
    u.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, u3 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = Xa(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (o = wt(t, r.schema)), a === "mark" && (s = $r(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, d = l.$to.pos;
    let u, f, p, h;
    n.selection.empty ? r.doc.nodesBetween(c, d, (m, g) => {
      o && o === m.type && (p = Math.max(g, c), h = Math.min(g + m.nodeSize, d), u = g, f = m);
    }) : r.doc.nodesBetween(c, d, (m, g) => {
      g < c && o && o === m.type && (p = Math.max(g, c), h = Math.min(g + m.nodeSize, d), u = g, f = m), g >= c && g <= d && (o && o === m.type && n.setNodeMarkup(g, void 0, {
        ...m.attrs,
        ...e
      }), s && m.marks.length && m.marks.forEach((C) => {
        if (s === C.type) {
          const v = Math.max(g, c), _ = Math.min(g + m.nodeSize, d);
          n.addMark(v, _, s.create({
            ...C.attrs,
            ...e
          }));
        }
      }));
    }), f && (u !== void 0 && n.setNodeMarkup(u, void 0, {
      ...f.attrs,
      ...e
    }), s && f.marks.length && f.marks.forEach((m) => {
      s === m.type && n.addMark(p, h, s.create({
        ...m.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, f3 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = wt(t, n.schema);
  return O8(i, e)(n, r);
}, p3 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = wt(t, n.schema);
  return T8(i, e)(n, r);
};
var h3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: J8,
  clearContent: X8,
  clearNodes: e5,
  command: t5,
  createParagraphNear: n5,
  cut: r5,
  deleteCurrentNode: i5,
  deleteNode: o5,
  deleteRange: s5,
  deleteSelection: a5,
  enter: l5,
  exitCode: c5,
  extendMarkRange: d5,
  first: u5,
  focus: f5,
  forEach: p5,
  insertContent: h5,
  insertContentAt: C5,
  joinBackward: v5,
  joinDown: y5,
  joinForward: w5,
  joinItemBackward: _5,
  joinItemForward: E5,
  joinTextblockBackward: x5,
  joinTextblockForward: k5,
  joinUp: b5,
  keyboardShortcut: M5,
  lift: O5,
  liftEmptyBlock: T5,
  liftListItem: L5,
  newlineInCode: N5,
  resetAttributes: A5,
  scrollIntoView: R5,
  selectAll: I5,
  selectNodeBackward: D5,
  selectNodeForward: P5,
  selectParentNode: B5,
  selectTextblockEnd: $5,
  selectTextblockStart: z5,
  setContent: H5,
  setMark: Q5,
  setMeta: Y5,
  setNode: J5,
  setNodeSelection: X5,
  setTextSelection: e3,
  sinkListItem: t3,
  splitBlock: n3,
  splitListItem: r3,
  toggleList: i3,
  toggleMark: o3,
  toggleNode: s3,
  toggleWrap: a3,
  undoInputRule: l3,
  unsetAllMarks: c3,
  unsetMark: d3,
  updateAttributes: u3,
  wrapIn: f3,
  wrapInList: p3
});
const g3 = qe.create({
  name: "commands",
  addCommands() {
    return {
      ...h3
    };
  }
}), m3 = qe.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Qe({
        key: new ct("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), C3 = qe.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Qe({
        key: new ct("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), b3 = new ct("focusEvents"), y3 = qe.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Qe({
        key: b3,
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), v3 = qe.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: d, $anchor: u } = l, { pos: f, parent: p } = u, h = u.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : u, m = h.parent.type.spec.isolating, g = u.pos - u.parentOffset, C = m && h.parent.childCount === 1 ? g === u.pos : le.atStart(c).from === f;
        return !d || !p.type.isTextblock || p.textContent.length || !C || C && u.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Ja() || c6() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Qe({
        key: new ct("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((m) => m.getMeta("composition")))
            return;
          const r = t.some((m) => m.docChanged) && !e.doc.eq(n.doc), i = t.some((m) => m.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: s, to: a } = e.selection, l = le.atStart(e.doc).from, c = le.atEnd(e.doc).to;
          if (o || !(s === l && a === c) || !Ac(n.doc))
            return;
          const f = n.tr, p = Ka({
            state: n,
            transaction: f
          }), { commands: h } = new Ga({
            editor: this.editor,
            state: p
          });
          if (h.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), w3 = qe.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Qe({
        key: new ct("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), _3 = qe.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Qe({
        key: new ct("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class Wr {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Wr(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Wr(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Wr(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = this.pos + r + (o ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
      if (!i && a.depth <= this.depth)
        return;
      const l = new Wr(a, this.editor, i, i ? n : null);
      i && (l.actualDepth = this.depth + 1), e.push(new Wr(a, this.editor, i, i ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (o[l] !== n[l])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      r && i.length > 0 || (s.node.type.name === e && o.every((l) => n[l] === s.node.attrs[l]) && i.push(s), !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(e, n, r))));
    }), i;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const E3 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function x3(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(i), i;
}
let k3 = class extends P8 {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: i }) => this.options.onDrop(n, r, i)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = x3(E3, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const r = r6(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let r = n;
    if ([].concat(e).forEach((o) => {
      const s = typeof o == "string" ? `${o}$` : o.key;
      r = r.filter((a) => !a.key.startsWith(s));
    }), n.length === r.length)
      return;
    const i = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const i = [...this.options.enableCoreExtensions ? [
      C3,
      Y8.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      g3,
      y3,
      v3,
      _3,
      m3,
      w3
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new Oi(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Ga({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = O1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = O1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const r = s6(n, this.options.autofocus);
    this.view = new V0(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Mi.create({
        doc: n,
        selection: r || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const o = this.view.dom;
    o.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), o = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return p6(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
    return G5(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return kc(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return f6(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...Mc(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Ac(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Wr(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function ai(t) {
  return new Qa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = xe(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = e, s = r[r.length - 1], a = r[0];
      if (s) {
        const l = a.search(/\S/), c = n.from + a.indexOf(s), d = c + s.length;
        if (Nc(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((m) => m === t.type && m !== p.mark.type)).filter((p) => p.to > c).length)
          return null;
        d < n.to && o.delete(d, n.to), c > n.from && o.delete(n.from + l, c);
        const f = n.from + l + s.length;
        o.addMark(n.from + l, f, t.type.create(i || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function m6(t) {
  return new Qa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = xe(t.getAttributes, void 0, r) || {}, { tr: o } = e, s = n.from;
      let a = n.to;
      const l = t.type.create(i);
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1]);
        let d = s + c;
        d > a ? d = a : a = d + r[1].length;
        const u = r[0][r[0].length - 1];
        o.insertText(u, s + r[0].length - 1), o.replaceWith(d, a, l);
      } else if (r[0]) {
        const c = t.type.isInline ? s : s - 1;
        o.insert(c, t.type.create(i)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    }
  });
}
function A1(t) {
  return new Qa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from), o = xe(t.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
    }
  });
}
function Ro(t) {
  return new Qa({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const o = xe(t.getAttributes, void 0, r) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c = l && ac(l, t.type, o);
      if (!c)
        return null;
      if (s.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: u, storedMarks: f } = e, { splittableMarks: p } = t.editor.extensionManager, h = f || u.$to.parentOffset && u.$from.marks();
        if (h) {
          const m = h.filter((g) => p.includes(g.type.name));
          s.ensureMarks(m);
        }
      }
      if (t.keepAttributes) {
        const u = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(u, o).run();
      }
      const d = s.doc.resolve(n.from - 1).nodeBefore;
      d && d.type === t.type && Pr(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, d)) && s.join(n.from - 1);
    }
  });
}
class nt {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = xe(q(this, "addOptions", {
      name: this.name
    }))), this.storage = xe(q(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new nt(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Ya(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new nt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = xe(q(n, "addOptions", {
      name: n.name
    })), n.storage = xe(q(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
class S3 {
  constructor(e, n, r) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...r
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, r, i, o, s, a, l;
    const { view: c } = this.editor, d = e.target, u = d.nodeType === 3 ? (n = d.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : d.closest("[data-drag-handle]");
    if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(d) || !u)
      return;
    let f = 0, p = 0;
    if (this.dom !== u) {
      const v = this.dom.getBoundingClientRect(), _ = u.getBoundingClientRect(), b = (i = e.offsetX) !== null && i !== void 0 ? i : (o = e.nativeEvent) === null || o === void 0 ? void 0 : o.offsetX, x = (s = e.offsetY) !== null && s !== void 0 ? s : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
      f = _.x - v.x + b, p = _.y - v.y + x;
    }
    const h = this.dom.cloneNode(!0);
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(h, f, p);
    const m = this.getPos();
    if (typeof m != "number")
      return;
    const g = ne.create(c.state.doc, m), C = c.state.tr.setSelection(g);
    c.dispatch(C);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const r = e.target;
    if (!(this.dom.contains(r) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))))
      return !1;
    const o = e.type.startsWith("drag"), s = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !s && !o)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, d = !!this.node.type.spec.draggable, u = ne.isSelectable(this.node), f = e.type === "copy", p = e.type === "paste", h = e.type === "cut", m = e.type === "mousedown";
    if (!d && u && o && e.target === this.dom && e.preventDefault(), d && o && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (d && l && !c && m) {
      const g = r.closest("[data-drag-handle]");
      g && (this.dom === g || this.dom.contains(g)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || s || f || p || h || m && u);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Ja() || a6()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((r) => r.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const r = this.getPos();
      return typeof r != "number" ? !1 : (n.setNodeMarkup(r, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function Dr(t) {
  return new W8({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
      const o = xe(t.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = e, a = r[r.length - 1], l = r[0];
      let c = n.to;
      if (a) {
        const d = l.search(/\S/), u = n.from + l.indexOf(a), f = u + a.length;
        if (Nc(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((g) => g === t.type && g !== h.mark.type)).filter((h) => h.to > u).length)
          return null;
        f < n.to && s.delete(f, n.to), u > n.from && s.delete(n.from + d, u), c = n.from + d + a.length, s.addMark(n.from + d, c, t.type.create(o || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
var Qt = "top", wn = "bottom", _n = "right", Yt = "left", Rc = "auto", Zo = [Qt, wn, _n, Yt], Bi = "start", Io = "end", M3 = "clippingParents", C6 = "viewport", Yi = "popper", O3 = "reference", nf = /* @__PURE__ */ Zo.reduce(function(t, e) {
  return t.concat([e + "-" + Bi, e + "-" + Io]);
}, []), b6 = /* @__PURE__ */ [].concat(Zo, [Rc]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Bi, e + "-" + Io]);
}, []), T3 = "beforeRead", L3 = "read", N3 = "afterRead", A3 = "beforeMain", R3 = "main", I3 = "afterMain", D3 = "beforeWrite", P3 = "write", B3 = "afterWrite", $3 = [T3, L3, N3, A3, R3, I3, D3, P3, B3];
function jn(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function cn(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function li(t) {
  var e = cn(t).Element;
  return t instanceof e || t instanceof Element;
}
function bn(t) {
  var e = cn(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Ic(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = cn(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function z3(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, o = e.elements[n];
    !bn(o) || !jn(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(s) {
      var a = i[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function H3(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], o = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = s.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !bn(i) || !jn(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const y6 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: z3,
  effect: H3,
  requires: ["computeStyles"]
};
function Fn(t) {
  return t.split("-")[0];
}
var ei = Math.max, ra = Math.min, $i = Math.round;
function R1() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function v6() {
  return !/^((?!chrome|android).)*safari/i.test(R1());
}
function zi(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(), i = 1, o = 1;
  e && bn(t) && (i = t.offsetWidth > 0 && $i(r.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && $i(r.height) / t.offsetHeight || 1);
  var s = li(t) ? cn(t) : window, a = s.visualViewport, l = !v6() && n, c = (r.left + (l && a ? a.offsetLeft : 0)) / i, d = (r.top + (l && a ? a.offsetTop : 0)) / o, u = r.width / i, f = r.height / o;
  return {
    width: u,
    height: f,
    top: d,
    right: c + u,
    bottom: d + f,
    left: c,
    x: c,
    y: d
  };
}
function Dc(t) {
  var e = zi(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function w6(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Ic(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function lr(t) {
  return cn(t).getComputedStyle(t);
}
function F3(t) {
  return ["table", "td", "th"].indexOf(jn(t)) >= 0;
}
function zr(t) {
  return ((li(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function el(t) {
  return jn(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (Ic(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    zr(t)
  );
}
function rf(t) {
  return !bn(t) || // https://github.com/popperjs/popper-core/issues/837
  lr(t).position === "fixed" ? null : t.offsetParent;
}
function U3(t) {
  var e = /firefox/i.test(R1()), n = /Trident/i.test(R1());
  if (n && bn(t)) {
    var r = lr(t);
    if (r.position === "fixed")
      return null;
  }
  var i = el(t);
  for (Ic(i) && (i = i.host); bn(i) && ["html", "body"].indexOf(jn(i)) < 0; ) {
    var o = lr(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Ko(t) {
  for (var e = cn(t), n = rf(t); n && F3(n) && lr(n).position === "static"; )
    n = rf(n);
  return n && (jn(n) === "html" || jn(n) === "body" && lr(n).position === "static") ? e : n || U3(t) || e;
}
function Pc(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function ho(t, e, n) {
  return ei(t, ra(e, n));
}
function V3(t, e, n) {
  var r = ho(t, e, n);
  return r > n ? n : r;
}
function _6() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function E6(t) {
  return Object.assign({}, _6(), t);
}
function x6(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var j3 = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, E6(typeof e != "number" ? e : x6(e, Zo));
};
function W3(t) {
  var e, n = t.state, r = t.name, i = t.options, o = n.elements.arrow, s = n.modifiersData.popperOffsets, a = Fn(n.placement), l = Pc(a), c = [Yt, _n].indexOf(a) >= 0, d = c ? "height" : "width";
  if (!(!o || !s)) {
    var u = j3(i.padding, n), f = Dc(o), p = l === "y" ? Qt : Yt, h = l === "y" ? wn : _n, m = n.rects.reference[d] + n.rects.reference[l] - s[l] - n.rects.popper[d], g = s[l] - n.rects.reference[l], C = Ko(o), v = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, _ = m / 2 - g / 2, b = u[p], x = v - f[d] - u[h], y = v / 2 - f[d] / 2 + _, M = ho(b, y, x), S = l;
    n.modifiersData[r] = (e = {}, e[S] = M, e.centerOffset = M - y, e);
  }
}
function Z3(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || w6(e.elements.popper, i) && (e.elements.arrow = i));
}
const K3 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: W3,
  effect: Z3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Hi(t) {
  return t.split("-")[1];
}
var G3 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function q3(t, e) {
  var n = t.x, r = t.y, i = e.devicePixelRatio || 1;
  return {
    x: $i(n * i) / i || 0,
    y: $i(r * i) / i || 0
  };
}
function of(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, o = t.variation, s = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, u = t.isFixed, f = s.x, p = f === void 0 ? 0 : f, h = s.y, m = h === void 0 ? 0 : h, g = typeof d == "function" ? d({
    x: p,
    y: m
  }) : {
    x: p,
    y: m
  };
  p = g.x, m = g.y;
  var C = s.hasOwnProperty("x"), v = s.hasOwnProperty("y"), _ = Yt, b = Qt, x = window;
  if (c) {
    var y = Ko(n), M = "clientHeight", S = "clientWidth";
    if (y === cn(n) && (y = zr(n), lr(y).position !== "static" && a === "absolute" && (M = "scrollHeight", S = "scrollWidth")), y = y, i === Qt || (i === Yt || i === _n) && o === Io) {
      b = wn;
      var T = u && y === x && x.visualViewport ? x.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        y[M]
      );
      m -= T - r.height, m *= l ? 1 : -1;
    }
    if (i === Yt || (i === Qt || i === wn) && o === Io) {
      _ = _n;
      var D = u && y === x && x.visualViewport ? x.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        y[S]
      );
      p -= D - r.width, p *= l ? 1 : -1;
    }
  }
  var j = Object.assign({
    position: a
  }, c && G3), V = d === !0 ? q3({
    x: p,
    y: m
  }, cn(n)) : {
    x: p,
    y: m
  };
  if (p = V.x, m = V.y, l) {
    var X;
    return Object.assign({}, j, (X = {}, X[b] = v ? "0" : "", X[_] = C ? "0" : "", X.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", X));
  }
  return Object.assign({}, j, (e = {}, e[b] = v ? m + "px" : "", e[_] = C ? p + "px" : "", e.transform = "", e));
}
function Q3(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, s = o === void 0 ? !0 : o, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: Fn(e.placement),
    variation: Hi(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, of(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, of(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const Y3 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Q3,
  data: {}
};
var fs = {
  passive: !0
};
function J3(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, o = i === void 0 ? !0 : i, s = r.resize, a = s === void 0 ? !0 : s, l = cn(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && c.forEach(function(d) {
    d.addEventListener("scroll", n.update, fs);
  }), a && l.addEventListener("resize", n.update, fs), function() {
    o && c.forEach(function(d) {
      d.removeEventListener("scroll", n.update, fs);
    }), a && l.removeEventListener("resize", n.update, fs);
  };
}
const X3 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: J3,
  data: {}
};
var e7 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Bs(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return e7[e];
  });
}
var t7 = {
  start: "end",
  end: "start"
};
function sf(t) {
  return t.replace(/start|end/g, function(e) {
    return t7[e];
  });
}
function Bc(t) {
  var e = cn(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function $c(t) {
  return zi(zr(t)).left + Bc(t).scrollLeft;
}
function n7(t, e) {
  var n = cn(t), r = zr(t), i = n.visualViewport, o = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    var c = v6();
    (c || !c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + $c(t),
    y: l
  };
}
function r7(t) {
  var e, n = zr(t), r = Bc(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, o = ei(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = ei(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + $c(t), l = -r.scrollTop;
  return lr(i || n).direction === "rtl" && (a += ei(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function zc(t) {
  var e = lr(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function k6(t) {
  return ["html", "body", "#document"].indexOf(jn(t)) >= 0 ? t.ownerDocument.body : bn(t) && zc(t) ? t : k6(el(t));
}
function go(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = k6(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), o = cn(r), s = i ? [o].concat(o.visualViewport || [], zc(r) ? r : []) : r, a = e.concat(s);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(go(el(s)))
  );
}
function I1(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function i7(t, e) {
  var n = zi(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function af(t, e, n) {
  return e === C6 ? I1(n7(t, n)) : li(e) ? i7(e, n) : I1(r7(zr(t)));
}
function o7(t) {
  var e = go(el(t)), n = ["absolute", "fixed"].indexOf(lr(t).position) >= 0, r = n && bn(t) ? Ko(t) : t;
  return li(r) ? e.filter(function(i) {
    return li(i) && w6(i, r) && jn(i) !== "body";
  }) : [];
}
function s7(t, e, n, r) {
  var i = e === "clippingParents" ? o7(t) : [].concat(e), o = [].concat(i, [n]), s = o[0], a = o.reduce(function(l, c) {
    var d = af(t, c, r);
    return l.top = ei(d.top, l.top), l.right = ra(d.right, l.right), l.bottom = ra(d.bottom, l.bottom), l.left = ei(d.left, l.left), l;
  }, af(t, s, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function S6(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? Fn(r) : null, o = r ? Hi(r) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case Qt:
      l = {
        x: s,
        y: e.y - n.height
      };
      break;
    case wn:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case _n:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case Yt:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = i ? Pc(i) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (o) {
      case Bi:
        l[c] = l[c] - (e[d] / 2 - n[d] / 2);
        break;
      case Io:
        l[c] = l[c] + (e[d] / 2 - n[d] / 2);
        break;
    }
  }
  return l;
}
function Do(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, o = n.strategy, s = o === void 0 ? t.strategy : o, a = n.boundary, l = a === void 0 ? M3 : a, c = n.rootBoundary, d = c === void 0 ? C6 : c, u = n.elementContext, f = u === void 0 ? Yi : u, p = n.altBoundary, h = p === void 0 ? !1 : p, m = n.padding, g = m === void 0 ? 0 : m, C = E6(typeof g != "number" ? g : x6(g, Zo)), v = f === Yi ? O3 : Yi, _ = t.rects.popper, b = t.elements[h ? v : f], x = s7(li(b) ? b : b.contextElement || zr(t.elements.popper), l, d, s), y = zi(t.elements.reference), M = S6({
    reference: y,
    element: _,
    placement: i
  }), S = I1(Object.assign({}, _, M)), T = f === Yi ? S : y, D = {
    top: x.top - T.top + C.top,
    bottom: T.bottom - x.bottom + C.bottom,
    left: x.left - T.left + C.left,
    right: T.right - x.right + C.right
  }, j = t.modifiersData.offset;
  if (f === Yi && j) {
    var V = j[i];
    Object.keys(D).forEach(function(X) {
      var de = [_n, wn].indexOf(X) >= 0 ? 1 : -1, ee = [Qt, wn].indexOf(X) >= 0 ? "y" : "x";
      D[X] += V[ee] * de;
    });
  }
  return D;
}
function a7(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, o = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? b6 : l, d = Hi(r), u = d ? a ? nf : nf.filter(function(h) {
    return Hi(h) === d;
  }) : Zo, f = u.filter(function(h) {
    return c.indexOf(h) >= 0;
  });
  f.length === 0 && (f = u);
  var p = f.reduce(function(h, m) {
    return h[m] = Do(t, {
      placement: m,
      boundary: i,
      rootBoundary: o,
      padding: s
    })[Fn(m)], h;
  }, {});
  return Object.keys(p).sort(function(h, m) {
    return p[h] - p[m];
  });
}
function l7(t) {
  if (Fn(t) === Rc)
    return [];
  var e = Bs(t);
  return [sf(t), e, sf(e)];
}
function c7(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, d = n.boundary, u = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, h = p === void 0 ? !0 : p, m = n.allowedAutoPlacements, g = e.options.placement, C = Fn(g), v = C === g, _ = l || (v || !h ? [Bs(g)] : l7(g)), b = [g].concat(_).reduce(function(pt, Re) {
      return pt.concat(Fn(Re) === Rc ? a7(e, {
        placement: Re,
        boundary: d,
        rootBoundary: u,
        padding: c,
        flipVariations: h,
        allowedAutoPlacements: m
      }) : Re);
    }, []), x = e.rects.reference, y = e.rects.popper, M = /* @__PURE__ */ new Map(), S = !0, T = b[0], D = 0; D < b.length; D++) {
      var j = b[D], V = Fn(j), X = Hi(j) === Bi, de = [Qt, wn].indexOf(V) >= 0, ee = de ? "width" : "height", J = Do(e, {
        placement: j,
        boundary: d,
        rootBoundary: u,
        altBoundary: f,
        padding: c
      }), L = de ? X ? _n : Yt : X ? wn : Qt;
      x[ee] > y[ee] && (L = Bs(L));
      var I = Bs(L), G = [];
      if (o && G.push(J[V] <= 0), a && G.push(J[L] <= 0, J[I] <= 0), G.every(function(pt) {
        return pt;
      })) {
        T = j, S = !1;
        break;
      }
      M.set(j, G);
    }
    if (S)
      for (var oe = h ? 3 : 1, me = function(Re) {
        var He = b.find(function(Jt) {
          var _t = M.get(Jt);
          if (_t)
            return _t.slice(0, Re).every(function(dn) {
              return dn;
            });
        });
        if (He)
          return T = He, "break";
      }, _e = oe; _e > 0; _e--) {
        var ze = me(_e);
        if (ze === "break") break;
      }
    e.placement !== T && (e.modifiersData[r]._skip = !0, e.placement = T, e.reset = !0);
  }
}
const d7 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: c7,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function lf(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function cf(t) {
  return [Qt, _n, wn, Yt].some(function(e) {
    return t[e] >= 0;
  });
}
function u7(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, o = e.modifiersData.preventOverflow, s = Do(e, {
    elementContext: "reference"
  }), a = Do(e, {
    altBoundary: !0
  }), l = lf(s, r), c = lf(a, i, o), d = cf(l), u = cf(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: u
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": u
  });
}
const f7 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: u7
};
function p7(t, e, n) {
  var r = Fn(t), i = [Yt, Qt].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * i, [Yt, _n].indexOf(r) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function h7(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, o = i === void 0 ? [0, 0] : i, s = b6.reduce(function(d, u) {
    return d[u] = p7(u, e.rects, o), d;
  }, {}), a = s[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = s;
}
const g7 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: h7
};
function m7(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = S6({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
const C7 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: m7,
  data: {}
};
function b7(t) {
  return t === "x" ? "y" : "x";
}
function y7(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, o = i === void 0 ? !0 : i, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, c = n.rootBoundary, d = n.altBoundary, u = n.padding, f = n.tether, p = f === void 0 ? !0 : f, h = n.tetherOffset, m = h === void 0 ? 0 : h, g = Do(e, {
    boundary: l,
    rootBoundary: c,
    padding: u,
    altBoundary: d
  }), C = Fn(e.placement), v = Hi(e.placement), _ = !v, b = Pc(C), x = b7(b), y = e.modifiersData.popperOffsets, M = e.rects.reference, S = e.rects.popper, T = typeof m == "function" ? m(Object.assign({}, e.rects, {
    placement: e.placement
  })) : m, D = typeof T == "number" ? {
    mainAxis: T,
    altAxis: T
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, T), j = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, V = {
    x: 0,
    y: 0
  };
  if (y) {
    if (o) {
      var X, de = b === "y" ? Qt : Yt, ee = b === "y" ? wn : _n, J = b === "y" ? "height" : "width", L = y[b], I = L + g[de], G = L - g[ee], oe = p ? -S[J] / 2 : 0, me = v === Bi ? M[J] : S[J], _e = v === Bi ? -S[J] : -M[J], ze = e.elements.arrow, pt = p && ze ? Dc(ze) : {
        width: 0,
        height: 0
      }, Re = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : _6(), He = Re[de], Jt = Re[ee], _t = ho(0, M[J], pt[J]), dn = _ ? M[J] / 2 - oe - _t - He - D.mainAxis : me - _t - He - D.mainAxis, Et = _ ? -M[J] / 2 + oe + _t + Jt + D.mainAxis : _e + _t + Jt + D.mainAxis, un = e.elements.arrow && Ko(e.elements.arrow), An = un ? b === "y" ? un.clientTop || 0 : un.clientLeft || 0 : 0, En = (X = j == null ? void 0 : j[b]) != null ? X : 0, Xt = L + dn - En - An, xn = L + Et - En, ge = ho(p ? ra(I, Xt) : I, L, p ? ei(G, xn) : G);
      y[b] = ge, V[b] = ge - L;
    }
    if (a) {
      var Wt, Nt = b === "x" ? Qt : Yt, ae = b === "x" ? wn : _n, Bt = y[x], De = x === "y" ? "height" : "width", Te = Bt + g[Nt], $t = Bt - g[ae], rt = [Qt, Yt].indexOf(C) !== -1, kn = (Wt = j == null ? void 0 : j[x]) != null ? Wt : 0, zt = rt ? Te : Bt - M[De] - S[De] - kn + D.altAxis, z = rt ? Bt + M[De] + S[De] - kn - D.altAxis : $t, Z = p && rt ? V3(zt, Bt, z) : ho(p ? zt : Te, Bt, p ? z : $t);
      y[x] = Z, V[x] = Z - Bt;
    }
    e.modifiersData[r] = V;
  }
}
const v7 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: y7,
  requiresIfExists: ["offset"]
};
function w7(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function _7(t) {
  return t === cn(t) || !bn(t) ? Bc(t) : w7(t);
}
function E7(t) {
  var e = t.getBoundingClientRect(), n = $i(e.width) / t.offsetWidth || 1, r = $i(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function x7(t, e, n) {
  n === void 0 && (n = !1);
  var r = bn(e), i = bn(e) && E7(e), o = zr(e), s = zi(t, i, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((jn(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  zc(o)) && (a = _7(e)), bn(e) ? (l = zi(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = $c(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function k7(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(o) {
    e.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(o);
  }
  return t.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function S7(t) {
  var e = k7(t);
  return $3.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function M7(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function O7(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var df = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function uf() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function T7(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, o = i === void 0 ? df : i;
  return function(a, l, c) {
    c === void 0 && (c = o);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, df, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, u = [], f = !1, p = {
      state: d,
      setOptions: function(C) {
        var v = typeof C == "function" ? C(d.options) : C;
        m(), d.options = Object.assign({}, o, d.options, v), d.scrollParents = {
          reference: li(a) ? go(a) : a.contextElement ? go(a.contextElement) : [],
          popper: go(l)
        };
        var _ = S7(O7([].concat(r, d.options.modifiers)));
        return d.orderedModifiers = _.filter(function(b) {
          return b.enabled;
        }), h(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var C = d.elements, v = C.reference, _ = C.popper;
          if (uf(v, _)) {
            d.rects = {
              reference: x7(v, Ko(_), d.options.strategy === "fixed"),
              popper: Dc(_)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(D) {
              return d.modifiersData[D.name] = Object.assign({}, D.data);
            });
            for (var b = 0; b < d.orderedModifiers.length; b++) {
              if (d.reset === !0) {
                d.reset = !1, b = -1;
                continue;
              }
              var x = d.orderedModifiers[b], y = x.fn, M = x.options, S = M === void 0 ? {} : M, T = x.name;
              typeof y == "function" && (d = y({
                state: d,
                options: S,
                name: T,
                instance: p
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: M7(function() {
        return new Promise(function(g) {
          p.forceUpdate(), g(d);
        });
      }),
      destroy: function() {
        m(), f = !0;
      }
    };
    if (!uf(a, l))
      return p;
    p.setOptions(c).then(function(g) {
      !f && c.onFirstUpdate && c.onFirstUpdate(g);
    });
    function h() {
      d.orderedModifiers.forEach(function(g) {
        var C = g.name, v = g.options, _ = v === void 0 ? {} : v, b = g.effect;
        if (typeof b == "function") {
          var x = b({
            state: d,
            name: C,
            instance: p,
            options: _
          }), y = function() {
          };
          u.push(x || y);
        }
      });
    }
    function m() {
      u.forEach(function(g) {
        return g();
      }), u = [];
    }
    return p;
  };
}
var L7 = [X3, C7, Y3, y6, g7, d7, v7, K3, f7], N7 = /* @__PURE__ */ T7({
  defaultModifiers: L7
}), A7 = "tippy-box", M6 = "tippy-content", R7 = "tippy-backdrop", O6 = "tippy-arrow", T6 = "tippy-svg-arrow", Vr = {
  passive: !0,
  capture: !0
}, L6 = function() {
  return document.body;
};
function I7(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function Rl(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function Hc(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function N6(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function ff(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      t(r);
    }, e);
  };
}
function D7(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(r) {
    delete n[r];
  }), n;
}
function P7(t) {
  return t.split(/\s+/).filter(Boolean);
}
function wi(t) {
  return [].concat(t);
}
function pf(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function B7(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function $7(t) {
  return t.split("-")[0];
}
function ia(t) {
  return [].slice.call(t);
}
function hf(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function mo() {
  return document.createElement("div");
}
function Po(t) {
  return ["Element", "Fragment"].some(function(e) {
    return Hc(t, e);
  });
}
function z7(t) {
  return Hc(t, "NodeList");
}
function H7(t) {
  return Hc(t, "MouseEvent");
}
function F7(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function U7(t) {
  return Po(t) ? [t] : z7(t) ? ia(t) : Array.isArray(t) ? t : ia(document.querySelectorAll(t));
}
function Il(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function gf(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function V7(t) {
  var e, n = wi(t), r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function j7(t, e) {
  var n = e.clientX, r = e.clientY;
  return t.every(function(i) {
    var o = i.popperRect, s = i.popperState, a = i.props, l = a.interactiveBorder, c = $7(s.placement), d = s.modifiersData.offset;
    if (!d)
      return !0;
    var u = c === "bottom" ? d.top.y : 0, f = c === "top" ? d.bottom.y : 0, p = c === "right" ? d.left.x : 0, h = c === "left" ? d.right.x : 0, m = o.top - r + u > l, g = r - o.bottom - f > l, C = o.left - n + p > l, v = n - o.right - h > l;
    return m || g || C || v;
  });
}
function Dl(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    t[r](i, n);
  });
}
function mf(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var zn = {
  isTouch: !1
}, Cf = 0;
function W7() {
  zn.isTouch || (zn.isTouch = !0, window.performance && document.addEventListener("mousemove", A6));
}
function A6() {
  var t = performance.now();
  t - Cf < 20 && (zn.isTouch = !1, document.removeEventListener("mousemove", A6)), Cf = t;
}
function Z7() {
  var t = document.activeElement;
  if (F7(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function K7() {
  document.addEventListener("touchstart", W7, Vr), window.addEventListener("blur", Z7);
}
var G7 = typeof window < "u" && typeof document < "u", q7 = G7 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function mi(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function bf(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function Q7(t) {
  return bf(`
  %ctippy.js

  %c` + bf(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function R6(t) {
  return [
    Q7(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var Bo;
process.env.NODE_ENV !== "production" && Y7();
function Y7() {
  Bo = /* @__PURE__ */ new Set();
}
function er(t, e) {
  if (t && !Bo.has(e)) {
    var n;
    Bo.add(e), (n = console).warn.apply(n, R6(e));
  }
}
function D1(t, e) {
  if (t && !Bo.has(e)) {
    var n;
    Bo.add(e), (n = console).error.apply(n, R6(e));
  }
}
function J7(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  D1(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), D1(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var I6 = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, X7 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, an = Object.assign({
  appendTo: L6,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, I6, X7), e9 = Object.keys(an), t9 = function(e) {
  process.env.NODE_ENV !== "production" && P6(e, []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    an[r] = e[r];
  });
};
function D6(t) {
  var e = t.plugins || [], n = e.reduce(function(r, i) {
    var o = i.name, s = i.defaultValue;
    if (o) {
      var a;
      r[o] = t[o] !== void 0 ? t[o] : (a = an[o]) != null ? a : s;
    }
    return r;
  }, {});
  return Object.assign({}, t, n);
}
function n9(t, e) {
  var n = e ? Object.keys(D6(Object.assign({}, an, {
    plugins: e
  }))) : e9, r = n.reduce(function(i, o) {
    var s = (t.getAttribute("data-tippy-" + o) || "").trim();
    if (!s)
      return i;
    if (o === "content")
      i[o] = s;
    else
      try {
        i[o] = JSON.parse(s);
      } catch {
        i[o] = s;
      }
    return i;
  }, {});
  return r;
}
function yf(t, e) {
  var n = Object.assign({}, e, {
    content: N6(e.content, [t])
  }, e.ignoreAttributes ? {} : n9(t, e.plugins));
  return n.aria = Object.assign({}, an.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function P6(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    var i = D7(an, Object.keys(I6)), o = !I7(i, r);
    o && (o = e.filter(function(s) {
      return s.name === r;
    }).length === 0), er(o, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var r9 = function() {
  return "innerHTML";
};
function P1(t, e) {
  t[r9()] = e;
}
function vf(t) {
  var e = mo();
  return t === !0 ? e.className = O6 : (e.className = T6, Po(t) ? e.appendChild(t) : P1(e, t)), e;
}
function wf(t, e) {
  Po(e.content) ? (P1(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? P1(t, e.content) : t.textContent = e.content);
}
function B1(t) {
  var e = t.firstElementChild, n = ia(e.children);
  return {
    box: e,
    content: n.find(function(r) {
      return r.classList.contains(M6);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(O6) || r.classList.contains(T6);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(R7);
    })
  };
}
function B6(t) {
  var e = mo(), n = mo();
  n.className = A7, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = mo();
  r.className = M6, r.setAttribute("data-state", "hidden"), wf(r, t.props), e.appendChild(n), n.appendChild(r), i(t.props, t.props);
  function i(o, s) {
    var a = B1(e), l = a.box, c = a.content, d = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (o.content !== s.content || o.allowHTML !== s.allowHTML) && wf(c, t.props), s.arrow ? d ? o.arrow !== s.arrow && (l.removeChild(d), l.appendChild(vf(s.arrow))) : l.appendChild(vf(s.arrow)) : d && l.removeChild(d);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
B6.$$tippy = !0;
var i9 = 1, ps = [], Pl = [];
function o9(t, e) {
  var n = yf(t, Object.assign({}, an, D6(hf(e)))), r, i, o, s = !1, a = !1, l = !1, c = !1, d, u, f, p = [], h = ff(Xt, n.interactiveDebounce), m, g = i9++, C = null, v = B7(n.plugins), _ = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: g,
    reference: t,
    popper: mo(),
    popperInstance: C,
    props: n,
    state: _,
    plugins: v,
    // methods
    clearDelayTimeouts: zt,
    setProps: z,
    setContent: Z,
    show: Ce,
    hide: Le,
    hideWithInteractivity: ot,
    enable: rt,
    disable: kn,
    unmount: en,
    destroy: Ki
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && D1(!0, "render() function has not been supplied."), b;
  var x = n.render(b), y = x.popper, M = x.onUpdate;
  y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + b.id, b.popper = y, t._tippy = b, y._tippy = b;
  var S = v.map(function(O) {
    return O.fn(b);
  }), T = t.hasAttribute("aria-expanded");
  return un(), oe(), L(), I("onCreate", [b]), n.showOnCreate && Te(), y.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), y.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && de().addEventListener("mousemove", h);
  }), b;
  function D() {
    var O = b.props.touch;
    return Array.isArray(O) ? O : [O, 0];
  }
  function j() {
    return D()[0] === "hold";
  }
  function V() {
    var O;
    return !!((O = b.props.render) != null && O.$$tippy);
  }
  function X() {
    return m || t;
  }
  function de() {
    var O = X().parentNode;
    return O ? V7(O) : document;
  }
  function ee() {
    return B1(y);
  }
  function J(O) {
    return b.state.isMounted && !b.state.isVisible || zn.isTouch || d && d.type === "focus" ? 0 : Rl(b.props.delay, O ? 0 : 1, an.delay);
  }
  function L(O) {
    O === void 0 && (O = !1), y.style.pointerEvents = b.props.interactive && !O ? "" : "none", y.style.zIndex = "" + b.props.zIndex;
  }
  function I(O, Q, ue) {
    if (ue === void 0 && (ue = !0), S.forEach(function(Se) {
      Se[O] && Se[O].apply(Se, Q);
    }), ue) {
      var Ne;
      (Ne = b.props)[O].apply(Ne, Q);
    }
  }
  function G() {
    var O = b.props.aria;
    if (O.content) {
      var Q = "aria-" + O.content, ue = y.id, Ne = wi(b.props.triggerTarget || t);
      Ne.forEach(function(Se) {
        var ht = Se.getAttribute(Q);
        if (b.state.isVisible)
          Se.setAttribute(Q, ht ? ht + " " + ue : ue);
        else {
          var Ht = ht && ht.replace(ue, "").trim();
          Ht ? Se.setAttribute(Q, Ht) : Se.removeAttribute(Q);
        }
      });
    }
  }
  function oe() {
    if (!(T || !b.props.aria.expanded)) {
      var O = wi(b.props.triggerTarget || t);
      O.forEach(function(Q) {
        b.props.interactive ? Q.setAttribute("aria-expanded", b.state.isVisible && Q === X() ? "true" : "false") : Q.removeAttribute("aria-expanded");
      });
    }
  }
  function me() {
    de().removeEventListener("mousemove", h), ps = ps.filter(function(O) {
      return O !== h;
    });
  }
  function _e(O) {
    if (!(zn.isTouch && (l || O.type === "mousedown"))) {
      var Q = O.composedPath && O.composedPath()[0] || O.target;
      if (!(b.props.interactive && mf(y, Q))) {
        if (wi(b.props.triggerTarget || t).some(function(ue) {
          return mf(ue, Q);
        })) {
          if (zn.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          I("onClickOutside", [b, O]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || He());
      }
    }
  }
  function ze() {
    l = !0;
  }
  function pt() {
    l = !1;
  }
  function Re() {
    var O = de();
    O.addEventListener("mousedown", _e, !0), O.addEventListener("touchend", _e, Vr), O.addEventListener("touchstart", pt, Vr), O.addEventListener("touchmove", ze, Vr);
  }
  function He() {
    var O = de();
    O.removeEventListener("mousedown", _e, !0), O.removeEventListener("touchend", _e, Vr), O.removeEventListener("touchstart", pt, Vr), O.removeEventListener("touchmove", ze, Vr);
  }
  function Jt(O, Q) {
    dn(O, function() {
      !b.state.isVisible && y.parentNode && y.parentNode.contains(y) && Q();
    });
  }
  function _t(O, Q) {
    dn(O, Q);
  }
  function dn(O, Q) {
    var ue = ee().box;
    function Ne(Se) {
      Se.target === ue && (Dl(ue, "remove", Ne), Q());
    }
    if (O === 0)
      return Q();
    Dl(ue, "remove", u), Dl(ue, "add", Ne), u = Ne;
  }
  function Et(O, Q, ue) {
    ue === void 0 && (ue = !1);
    var Ne = wi(b.props.triggerTarget || t);
    Ne.forEach(function(Se) {
      Se.addEventListener(O, Q, ue), p.push({
        node: Se,
        eventType: O,
        handler: Q,
        options: ue
      });
    });
  }
  function un() {
    j() && (Et("touchstart", En, {
      passive: !0
    }), Et("touchend", xn, {
      passive: !0
    })), P7(b.props.trigger).forEach(function(O) {
      if (O !== "manual")
        switch (Et(O, En), O) {
          case "mouseenter":
            Et("mouseleave", xn);
            break;
          case "focus":
            Et(q7 ? "focusout" : "blur", ge);
            break;
          case "focusin":
            Et("focusout", ge);
            break;
        }
    });
  }
  function An() {
    p.forEach(function(O) {
      var Q = O.node, ue = O.eventType, Ne = O.handler, Se = O.options;
      Q.removeEventListener(ue, Ne, Se);
    }), p = [];
  }
  function En(O) {
    var Q, ue = !1;
    if (!(!b.state.isEnabled || Wt(O) || a)) {
      var Ne = ((Q = d) == null ? void 0 : Q.type) === "focus";
      d = O, m = O.currentTarget, oe(), !b.state.isVisible && H7(O) && ps.forEach(function(Se) {
        return Se(O);
      }), O.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || s) && b.props.hideOnClick !== !1 && b.state.isVisible ? ue = !0 : Te(O), O.type === "click" && (s = !ue), ue && !Ne && $t(O);
    }
  }
  function Xt(O) {
    var Q = O.target, ue = X().contains(Q) || y.contains(Q);
    if (!(O.type === "mousemove" && ue)) {
      var Ne = De().concat(y).map(function(Se) {
        var ht, Ht = Se._tippy, cr = (ht = Ht.popperInstance) == null ? void 0 : ht.state;
        return cr ? {
          popperRect: Se.getBoundingClientRect(),
          popperState: cr,
          props: n
        } : null;
      }).filter(Boolean);
      j7(Ne, O) && (me(), $t(O));
    }
  }
  function xn(O) {
    var Q = Wt(O) || b.props.trigger.indexOf("click") >= 0 && s;
    if (!Q) {
      if (b.props.interactive) {
        b.hideWithInteractivity(O);
        return;
      }
      $t(O);
    }
  }
  function ge(O) {
    b.props.trigger.indexOf("focusin") < 0 && O.target !== X() || b.props.interactive && O.relatedTarget && y.contains(O.relatedTarget) || $t(O);
  }
  function Wt(O) {
    return zn.isTouch ? j() !== O.type.indexOf("touch") >= 0 : !1;
  }
  function Nt() {
    ae();
    var O = b.props, Q = O.popperOptions, ue = O.placement, Ne = O.offset, Se = O.getReferenceClientRect, ht = O.moveTransition, Ht = V() ? B1(y).arrow : null, cr = Se ? {
      getBoundingClientRect: Se,
      contextElement: Se.contextElement || X()
    } : t, Gi = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(N) {
        var H = N.state;
        if (V()) {
          var fe = ee(), We = fe.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Fe) {
            Fe === "placement" ? We.setAttribute("data-placement", H.placement) : H.attributes.popper["data-popper-" + Fe] ? We.setAttribute("data-" + Fe, "") : We.removeAttribute("data-" + Fe);
          }), H.attributes.popper = {};
        }
      }
    }, Zt = [{
      name: "offset",
      options: {
        offset: Ne
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !ht
      }
    }, Gi];
    V() && Ht && Zt.push({
      name: "arrow",
      options: {
        element: Ht,
        padding: 3
      }
    }), Zt.push.apply(Zt, (Q == null ? void 0 : Q.modifiers) || []), b.popperInstance = N7(cr, y, Object.assign({}, Q, {
      placement: ue,
      onFirstUpdate: f,
      modifiers: Zt
    }));
  }
  function ae() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function Bt() {
    var O = b.props.appendTo, Q, ue = X();
    b.props.interactive && O === L6 || O === "parent" ? Q = ue.parentNode : Q = N6(O, [ue]), Q.contains(y) || Q.appendChild(y), b.state.isMounted = !0, Nt(), process.env.NODE_ENV !== "production" && er(b.props.interactive && O === an.appendTo && ue.nextElementSibling !== y, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function De() {
    return ia(y.querySelectorAll("[data-tippy-root]"));
  }
  function Te(O) {
    b.clearDelayTimeouts(), O && I("onTrigger", [b, O]), Re();
    var Q = J(!0), ue = D(), Ne = ue[0], Se = ue[1];
    zn.isTouch && Ne === "hold" && Se && (Q = Se), Q ? r = setTimeout(function() {
      b.show();
    }, Q) : b.show();
  }
  function $t(O) {
    if (b.clearDelayTimeouts(), I("onUntrigger", [b, O]), !b.state.isVisible) {
      He();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(O.type) >= 0 && s)) {
      var Q = J(!1);
      Q ? i = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, Q) : o = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function rt() {
    b.state.isEnabled = !0;
  }
  function kn() {
    b.hide(), b.state.isEnabled = !1;
  }
  function zt() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o);
  }
  function z(O) {
    if (process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("setProps")), !b.state.isDestroyed) {
      I("onBeforeUpdate", [b, O]), An();
      var Q = b.props, ue = yf(t, Object.assign({}, Q, hf(O), {
        ignoreAttributes: !0
      }));
      b.props = ue, un(), Q.interactiveDebounce !== ue.interactiveDebounce && (me(), h = ff(Xt, ue.interactiveDebounce)), Q.triggerTarget && !ue.triggerTarget ? wi(Q.triggerTarget).forEach(function(Ne) {
        Ne.removeAttribute("aria-expanded");
      }) : ue.triggerTarget && t.removeAttribute("aria-expanded"), oe(), L(), M && M(Q, ue), b.popperInstance && (Nt(), De().forEach(function(Ne) {
        requestAnimationFrame(Ne._tippy.popperInstance.forceUpdate);
      })), I("onAfterUpdate", [b, O]);
    }
  }
  function Z(O) {
    b.setProps({
      content: O
    });
  }
  function Ce() {
    process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("show"));
    var O = b.state.isVisible, Q = b.state.isDestroyed, ue = !b.state.isEnabled, Ne = zn.isTouch && !b.props.touch, Se = Rl(b.props.duration, 0, an.duration);
    if (!(O || Q || ue || Ne) && !X().hasAttribute("disabled") && (I("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, V() && (y.style.visibility = "visible"), L(), Re(), b.state.isMounted || (y.style.transition = "none"), V()) {
        var ht = ee(), Ht = ht.box, cr = ht.content;
        Il([Ht, cr], 0);
      }
      f = function() {
        var Zt;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, y.offsetHeight, y.style.transition = b.props.moveTransition, V() && b.props.animation) {
            var w = ee(), N = w.box, H = w.content;
            Il([N, H], Se), gf([N, H], "visible");
          }
          G(), oe(), pf(Pl, b), (Zt = b.popperInstance) == null || Zt.forceUpdate(), I("onMount", [b]), b.props.animation && V() && _t(Se, function() {
            b.state.isShown = !0, I("onShown", [b]);
          });
        }
      }, Bt();
    }
  }
  function Le() {
    process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("hide"));
    var O = !b.state.isVisible, Q = b.state.isDestroyed, ue = !b.state.isEnabled, Ne = Rl(b.props.duration, 1, an.duration);
    if (!(O || Q || ue) && (I("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, s = !1, V() && (y.style.visibility = "hidden"), me(), He(), L(!0), V()) {
        var Se = ee(), ht = Se.box, Ht = Se.content;
        b.props.animation && (Il([ht, Ht], Ne), gf([ht, Ht], "hidden"));
      }
      G(), oe(), b.props.animation ? V() && Jt(Ne, b.unmount) : b.unmount();
    }
  }
  function ot(O) {
    process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("hideWithInteractivity")), de().addEventListener("mousemove", h), pf(ps, h), h(O);
  }
  function en() {
    process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (ae(), De().forEach(function(O) {
      O._tippy.unmount();
    }), y.parentNode && y.parentNode.removeChild(y), Pl = Pl.filter(function(O) {
      return O !== b;
    }), b.state.isMounted = !1, I("onHidden", [b]));
  }
  function Ki() {
    process.env.NODE_ENV !== "production" && er(b.state.isDestroyed, mi("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), An(), delete t._tippy, b.state.isDestroyed = !0, I("onDestroy", [b]));
  }
}
function Wi(t, e) {
  e === void 0 && (e = {});
  var n = an.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (J7(t), P6(e, n)), K7();
  var r = Object.assign({}, e, {
    plugins: n
  }), i = U7(t);
  if (process.env.NODE_ENV !== "production") {
    var o = Po(r.content), s = i.length > 1;
    er(o && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = i.reduce(function(l, c) {
    var d = c && o9(c, r);
    return d && l.push(d), l;
  }, []);
  return Po(t) ? a[0] : a;
}
Wi.defaultProps = an;
Wi.setDefaultProps = t9;
Wi.currentInput = zn;
Object.assign({}, y6, {
  effect: function(e) {
    var n = e.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
Wi.setDefaultProps({
  render: B6
});
class s9 {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: o = 250, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: c, to: d }) => {
      const { doc: u, selection: f } = l, { empty: p } = f, h = !u.textBetween(c, d).length && Tc(l.selection), m = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || m) || p || h || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), d = !(l != null && l.doc.eq(a.state.doc));
      !c && !d || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, d, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, d) => {
      var u, f, p;
      const { state: h, composing: m } = a, { selection: g } = h;
      if (m || !l && !c)
        return;
      this.createTooltip();
      const { ranges: v } = g, _ = Math.min(...v.map((y) => y.$from.pos)), b = Math.max(...v.map((y) => y.$to.pos));
      if (!((u = this.shouldShow) === null || u === void 0 ? void 0 : u.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: h,
        oldState: d,
        from: _,
        to: b
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((p = this.tippyOptions) === null || p === void 0 ? void 0 : p.getReferenceClientRect) || (() => {
          if (h6(h.selection)) {
            let y = a.nodeDOM(_);
            if (y) {
              const M = y.dataset.nodeViewWrapper ? y : y.querySelector("[data-node-view-wrapper]");
              if (M && (y = M.firstChild), y)
                return y.getBoundingClientRect();
            }
          }
          return g6(a, _, b);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = r, this.updateDelay = o, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Wi(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: r } = e, i = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const o = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, o, s, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const $6 = (t) => new Qe({
  key: typeof t.pluginKey == "string" ? new ct(t.pluginKey) : t.pluginKey,
  view: (e) => new s9({ view: e, ...t })
});
qe.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      $6({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class a9 {
  getTextContent(e) {
    return f6(e, { textSerializers: Mc(this.editor.schema) });
  }
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: d } = l, u = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent && c.parent.childCount === 0 && !this.getTextContent(c.parent);
      return !(!s.hasFocus() || !d || !u || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.editor = e, this.element = n, this.view = r, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Wi(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var r, i, o;
    const { state: s } = e, { doc: a, selection: l } = s, { from: c, to: d } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: e,
      state: s,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((o = this.tippyOptions) === null || o === void 0 ? void 0 : o.getReferenceClientRect) || (() => g6(e, c, d))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const z6 = (t) => new Qe({
  key: typeof t.pluginKey == "string" ? new ct(t.pluginKey) : t.pluginKey,
  view: (e) => new a9({ view: e, ...t })
});
qe.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      z6({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
ve({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = U(null);
    return di(() => {
      const { updateDelay: r, editor: i, pluginKey: o, shouldShow: s, tippyOptions: a } = t;
      i.registerPlugin($6({
        updateDelay: r,
        editor: i,
        element: n.value,
        pluginKey: o,
        shouldShow: s,
        tippyOptions: a
      }));
    }), $a(() => {
      const { pluginKey: r, editor: i } = t;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Rr("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
});
function _f(t) {
  return Mh((e, n) => ({
    get() {
      return e(), t;
    },
    set(r) {
      t = r, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class l9 extends k3 {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = _f(this.view.state), this.reactiveExtensionStorage = _f(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), xh(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const r = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const c9 = ve({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = U(), n = kh();
    return x4(() => {
      const r = t.editor;
      r && r.options.element && e.value && Sh(() => {
        if (!e.value || !r.options.element.firstChild)
          return;
        const i = se(e.value);
        e.value.append(...r.options.element.childNodes), r.contentComponent = n.ctx._, n && (r.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), r.setOptions({
          element: i
        }), r.createNodeViews();
      });
    }), $a(() => {
      const r = t.editor;
      r && (r.contentComponent = null, r.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return Rr("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
});
ve({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = U(null);
    return di(() => {
      const { pluginKey: r, editor: i, tippyOptions: o, shouldShow: s } = t;
      i.registerPlugin(z6({
        pluginKey: r,
        editor: i,
        element: n.value,
        tippyOptions: o,
        shouldShow: s
      }));
    }), $a(() => {
      const { pluginKey: r, editor: i } = t;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return Rr("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
});
const d9 = ve({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return Rr(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
}), Go = ve({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return Rr(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
}), u9 = (t = {}) => {
  const e = E4();
  return di(() => {
    e.value = new l9(t);
  }), $a(() => {
    var n, r, i;
    const o = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, s = o == null ? void 0 : o.cloneNode(!0);
    (r = o == null ? void 0 : o.parentNode) === null || r === void 0 || r.replaceChild(s, o), (i = e.value) === null || i === void 0 || i.destroy();
  }), e;
};
class f9 {
  constructor(e, { props: n = {}, editor: r }) {
    this.editor = r, this.component = xh(e), this.el = document.createElement("div"), this.props = Ct(n), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, r, i;
    return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (i = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || i === void 0 ? void 0 : i.proxy;
  }
  renderComponent() {
    let e = Rr(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && qd(e, this.el), { vNode: e, destroy: () => {
      this.el && qd(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, r]) => {
      this.props[n] = r;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const qo = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  },
  view: {
    type: Object,
    required: !0
  },
  innerDecorations: {
    type: Object,
    required: !0
  },
  HTMLAttributes: {
    type: Object,
    required: !0
  }
};
class p9 extends S3 {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (i = {}) => this.updateAttributes(i),
      deleteNode: () => this.deleteNode()
    }, n = this.onDragStart.bind(this);
    this.decorationClasses = U(this.getDecorationClasses());
    const r = ve({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (i) => {
        var o, s;
        return nr("onDragStart", n), nr("decorationClasses", this.decorationClasses), (s = (o = this.component).setup) === null || s === void 0 ? void 0 : s.call(o, i, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new f9(r, {
      editor: this.editor,
      props: e
    });
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection, r = this.getPos();
    if (typeof r == "number")
      if (e <= r && n >= r + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, r) {
    const i = (o) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(o);
    };
    if (typeof this.options.update == "function") {
      const o = this.node, s = this.decorations, a = this.innerDecorations;
      return this.node = e, this.decorations = n, this.innerDecorations = r, this.options.update({
        oldNode: o,
        oldDecorations: s,
        newNode: e,
        newDecorations: n,
        oldInnerDecorations: a,
        innerDecorations: r,
        updateProps: () => i({ node: e, decorations: n, innerDecorations: r })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === n && this.innerDecorations === r || (this.node = e, this.decorations = n, this.innerDecorations = r, i({ node: e, decorations: n, innerDecorations: r })), !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Qo(t, e) {
  return (n) => {
    if (!n.editor.contentComponent)
      return {};
    const r = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
    return new p9(r, n, e);
  };
}
const h9 = /^\s*>\s$/, g9 = nt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Ro({
        find: h9,
        type: this.type
      })
    ];
  }
}), m9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, C9 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, b9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, y9 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, v9 = vn.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      ai({
        find: m9,
        type: this.type
      }),
      ai({
        find: b9,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dr({
        find: C9,
        type: this.type
      }),
      Dr({
        find: y9,
        type: this.type
      })
    ];
  }
}), w9 = "listItem", Ef = "textStyle", xf = /^\s*([-+*])\s$/, H6 = nt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(w9, this.editor.getAttributes(Ef)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Ro({
      find: xf,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Ro({
      find: xf,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Ef),
      editor: this.editor
    })), [
      t
    ];
  }
}), _9 = /(^|[^`])`([^`]+)`(?!`)/, E9 = /(^|[^`])`([^`]+)`(?!`)/g, x9 = vn.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      ai({
        find: _9,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dr({
        find: E9,
        type: this.type
      })
    ];
  }
}), k9 = /^```([a-z]+)?[\s\n]$/, S9 = /^~~~([a-z]+)?[\s\n]$/, F6 = nt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, o = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Be(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: i, empty: o } = n;
        if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection(le.near(r.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      A1({
        find: k9,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      A1({
        find: S9,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Qe({
        key: new ct("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = i == null ? void 0 : i.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(ie.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), t.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), M9 = nt.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function O9(t = {}) {
  return new Qe({
    view(e) {
      return new T9(e, t);
    }
  });
}
class T9 {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (s) => {
        this[i](s);
      };
      return e.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, i = this.editorView.dom, o = i.getBoundingClientRect(), s = o.width / i.offsetWidth, a = o.height / i.offsetHeight;
    if (n) {
      let u = e.nodeBefore, f = e.nodeAfter;
      if (u || f) {
        let p = this.editorView.nodeDOM(this.cursorPos - (u ? u.nodeSize : 0));
        if (p) {
          let h = p.getBoundingClientRect(), m = u ? h.bottom : h.top;
          u && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let g = this.width / 2 * a;
          r = { left: h.left, right: h.right, top: m - g, bottom: m + g };
        }
      }
    }
    if (!r) {
      let u = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * s;
      r = { left: u.left - f, right: u.left + f, top: u.top, bottom: u.bottom };
    }
    let l = this.editorView.dom.offsetParent;
    this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let c, d;
    if (!l || l == document.body && getComputedStyle(l).position == "static")
      c = -pageXOffset, d = -pageYOffset;
    else {
      let u = l.getBoundingClientRect(), f = u.width / l.offsetWidth, p = u.height / l.offsetHeight;
      c = u.left - l.scrollLeft * f, d = u.top - l.scrollTop * p;
    }
    this.element.style.left = (r.left - c) / s + "px", this.element.style.top = (r.top - d) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, e) : i;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = n0(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
const L9 = qe.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      O9(this.options)
    ];
  }
});
class et extends le {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return et.valid(r) ? new et(r) : le.near(r);
  }
  content() {
    return F.empty;
  }
  eq(e) {
    return e instanceof et && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new et(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Fc(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !N9(e) || !A9(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && et.valid(e))
        return e;
      let i = e.pos, o = null;
      for (let s = e.depth; ; s--) {
        let a = e.node(s);
        if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
          o = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        i += n;
        let l = e.doc.resolve(i);
        if (et.valid(l))
          return l;
      }
      for (; ; ) {
        let s = n > 0 ? o.firstChild : o.lastChild;
        if (!s) {
          if (o.isAtom && !o.isText && !ne.isSelectable(o)) {
            e = e.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = s, i += n;
        let a = e.doc.resolve(i);
        if (et.valid(a))
          return a;
      }
      return null;
    }
  }
}
et.prototype.visible = !1;
et.findFrom = et.findGapCursorFrom;
le.jsonID("gapcursor", et);
class Fc {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Fc(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return et.valid(n) ? new et(n) : le.near(n);
  }
}
function N9(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function A9(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function R9() {
  return new Qe({
    props: {
      decorations: B9,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && et.valid(n) ? new et(n) : null;
      },
      handleClick: D9,
      handleKeyDown: I9,
      handleDOMEvents: { beforeinput: P9 }
    }
  });
}
const I9 = yc({
  ArrowLeft: hs("horiz", -1),
  ArrowRight: hs("horiz", 1),
  ArrowUp: hs("vert", -1),
  ArrowDown: hs("vert", 1)
});
function hs(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, o) {
    let s = r.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof ie) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = et.findGapCursorFrom(a, e, l);
    return c ? (i && i(r.tr.setSelection(new et(c))), !0) : !1;
  };
}
function D9(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!et.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ne.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new et(r))), !0);
}
function P9(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof et))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = A.empty;
  for (let s = r.length - 1; s >= 0; s--)
    i = A.from(r[s].createAndFill(null, i));
  let o = t.state.tr.replace(n.pos, n.pos, new F(i, 0, 0));
  return o.setSelection(ie.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function B9(t) {
  if (!(t.selection instanceof et))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Ke.create(t.doc, [Tt.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const $9 = qe.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      R9()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = xe(q(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), z9 = nt.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Be(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = o || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: d }) => {
            if (d && l && s) {
              const u = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(u);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), H9 = nt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Be(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => A1({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
var oa = 200, vt = function() {
};
vt.prototype.append = function(e) {
  return e.length ? (e = vt.from(e), !this.length && e || e.length < oa && this.leafAppend(e) || this.length < oa && e.leafPrepend(this) || this.appendInner(e)) : this;
};
vt.prototype.prepend = function(e) {
  return e.length ? vt.from(e).append(this) : this;
};
vt.prototype.appendInner = function(e) {
  return new F9(this, e);
};
vt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? vt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
vt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
vt.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
vt.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, s) {
    return i.push(e(o, s));
  }, n, r), i;
};
vt.from = function(e) {
  return e instanceof vt ? e : e && e.length ? new U6(e) : vt.empty;
};
var U6 = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new e(this.values.slice(i, o));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, o, s, a) {
    for (var l = o; l < s; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, o, s, a) {
    for (var l = o - 1; l >= s; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= oa)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= oa)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(vt);
vt.empty = new U6([]);
var F9 = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(i, a), o, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(vt);
const U9 = 500;
class On {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let s = e.tr, a, l, c = [], d = [];
    return this.items.forEach((u, f) => {
      if (!u.step) {
        i || (i = this.remapping(r, f + 1), o = i.maps.length), o--, d.push(u);
        return;
      }
      if (i) {
        d.push(new Pn(u.map));
        let p = u.step.map(i.slice(o)), h;
        p && s.maybeStep(p).doc && (h = s.mapping.maps[s.mapping.maps.length - 1], c.push(new Pn(h, void 0, void 0, c.length + d.length))), o--, h && i.appendMap(h, o);
      } else
        s.maybeStep(u.step);
      if (u.selection)
        return a = i ? u.selection.map(i.slice(o)) : u.selection, l = new On(this.items.slice(0, r).append(d.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let o = [], s = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let d = 0; d < e.steps.length; d++) {
      let u = e.steps[d].invert(e.docs[d]), f = new Pn(e.mapping.maps[d], u, n), p;
      (p = l && l.merge(f)) && (f = p, d ? o.pop() : a = a.slice(0, a.length - 1)), o.push(f), n && (s++, n = void 0), i || (l = f);
    }
    let c = s - r.depth;
    return c > j9 && (a = V9(a, c), s -= c), new On(a.append(o), s);
  }
  remapping(e, n) {
    let r = new So();
    return this.items.forEach((i, o) => {
      let s = i.mirrorOffset != null && o - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, s);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new On(this.items.append(e.map((n) => new Pn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = e.mapping, s = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, i);
    let l = n;
    this.items.forEach((f) => {
      let p = o.getMirror(--l);
      if (p == null)
        return;
      s = Math.min(s, p);
      let h = o.maps[p];
      if (f.step) {
        let m = e.steps[p].invert(e.docs[p]), g = f.selection && f.selection.map(o.slice(l + 1, p));
        g && a++, r.push(new Pn(h, m, g));
      } else
        r.push(new Pn(h));
    }, i);
    let c = [];
    for (let f = n; f < s; f++)
      c.push(new Pn(o.maps[f]));
    let d = this.items.slice(0, i).append(c).append(r), u = new On(d, a);
    return u.emptyItemCount() > U9 && (u = u.compress(this.items.length - r.length)), u;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= e)
        i.push(s), s.selection && o++;
      else if (s.step) {
        let l = s.step.map(n.slice(r)), c = l && l.getMap();
        if (r--, c && n.appendMap(c, r), l) {
          let d = s.selection && s.selection.map(n.slice(r));
          d && o++;
          let u = new Pn(c.invert(), l, d), f, p = i.length - 1;
          (f = i.length && i[p].merge(u)) ? i[p] = f : i.push(u);
        }
      } else s.map && r--;
    }, this.items.length, 0), new On(vt.from(i.reverse()), o);
  }
}
On.empty = new On(vt.empty, 0);
function V9(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
class Pn {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Pn(n.getMap().invert(), n, this.selection);
    }
  }
}
class mr {
  constructor(e, n, r, i, o) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const j9 = 20;
function W9(t, e, n, r) {
  let i = n.getMeta(ti), o;
  if (i)
    return i.historyState;
  n.getMeta(G9) && (t = new mr(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(ti))
    return s.getMeta(ti).redo ? new mr(t.done.addTransform(n, void 0, r, $s(e)), t.undone, kf(n.mapping.maps), t.prevTime, t.prevComposition) : new mr(t.done, t.undone.addTransform(n, void 0, r, $s(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !Z9(n, t.prevRanges)), c = s ? Bl(t.prevRanges, n.mapping) : kf(n.mapping.maps);
    return new mr(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, $s(e)), On.empty, c, n.time, a ?? t.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new mr(t.done.rebased(n, o), t.undone.rebased(n, o), Bl(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new mr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Bl(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function Z9(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < e.length; o += 2)
      r <= e[o + 1] && i >= e[o] && (n = !0);
  }), n;
}
function kf(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, i, o, s) => e.push(o, s));
  return e;
}
function Bl(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), o = e.map(t[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function K9(t, e, n) {
  let r = $s(e), i = ti.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, r);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), i, r), l = new mr(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(ti, { redo: n, historyState: l });
}
let $l = !1, Sf = null;
function $s(t) {
  let e = t.plugins;
  if (Sf != e) {
    $l = !1, Sf = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        $l = !0;
        break;
      }
  }
  return $l;
}
const ti = new ct("history"), G9 = new ct("closeHistory");
function q9(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Qe({
    key: ti,
    state: {
      init() {
        return new mr(On.empty, On.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return W9(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? j6 : r == "historyRedo" ? W6 : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function V6(t, e) {
  return (n, r) => {
    let i = ti.getState(n);
    if (!i || (t ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = K9(i, n, t);
      o && r(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const j6 = V6(!1, !0), W6 = V6(!0, !0), Q9 = qe.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => j6(t, e),
      redo: () => ({ state: t, dispatch: e }) => W6(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      q9(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), Y9 = nt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Be(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: r, $to: i } = n, o = t();
        return r.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : h6(n) ? o.insertContentAt(i.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: s, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = s.selection, d = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(ie.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(ne.create(s.doc, c.pos)) : s.setSelection(ie.create(s.doc, c.pos));
            else {
              const u = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              u && (s.insert(d, u), s.setSelection(ie.create(s.doc, d + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      m6({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), J9 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, X9 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, eC = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, tC = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, nC = vn.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      ai({
        find: J9,
        type: this.type
      }),
      ai({
        find: eC,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dr({
        find: X9,
        type: this.type
      }),
      Dr({
        find: tC,
        type: this.type
      })
    ];
  }
}), rC = nt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Be(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), iC = "listItem", Mf = "textStyle", Of = /^(\d+)\.\s$/, Z6 = nt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Be(this.options.HTMLAttributes, n), 0] : ["ol", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(iC, this.editor.getAttributes(Mf)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Ro({
      find: Of,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Ro({
      find: Of,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Mf) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), oC = nt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), sC = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, aC = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, lC = vn.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      ai({
        find: sC,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dr({
        find: aC,
        type: this.type
      })
    ];
  }
}), cC = nt.create({
  name: "text",
  group: "inline"
}), dC = qe.create({
  name: "starterKit",
  addExtensions() {
    const t = [];
    return this.options.bold !== !1 && t.push(v9.configure(this.options.bold)), this.options.blockquote !== !1 && t.push(g9.configure(this.options.blockquote)), this.options.bulletList !== !1 && t.push(H6.configure(this.options.bulletList)), this.options.code !== !1 && t.push(x9.configure(this.options.code)), this.options.codeBlock !== !1 && t.push(F6.configure(this.options.codeBlock)), this.options.document !== !1 && t.push(M9.configure(this.options.document)), this.options.dropcursor !== !1 && t.push(L9.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && t.push($9.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && t.push(z9.configure(this.options.hardBreak)), this.options.heading !== !1 && t.push(H9.configure(this.options.heading)), this.options.history !== !1 && t.push(Q9.configure(this.options.history)), this.options.horizontalRule !== !1 && t.push(Y9.configure(this.options.horizontalRule)), this.options.italic !== !1 && t.push(nC.configure(this.options.italic)), this.options.listItem !== !1 && t.push(rC.configure(this.options.listItem)), this.options.orderedList !== !1 && t.push(Z6.configure(this.options.orderedList)), this.options.paragraph !== !1 && t.push(oC.configure(this.options.paragraph)), this.options.strike !== !1 && t.push(lC.configure(this.options.strike)), this.options.text !== !1 && t.push(cC.configure(this.options.text)), t;
  }
});
function yn(t, e) {
  uC(t) && (t = "100%");
  var n = fC(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function uC(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function fC(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function pC(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function gs(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function zl(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function hC(t, e, n) {
  return {
    r: yn(t, 255) * 255,
    g: yn(e, 255) * 255,
    b: yn(n, 255) * 255
  };
}
function Hl(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function gC(t, e, n) {
  var r, i, o;
  if (t = yn(t, 360), e = yn(e, 100), n = yn(n, 100), e === 0)
    i = n, o = n, r = n;
  else {
    var s = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - s;
    r = Hl(a, s, t + 1 / 3), i = Hl(a, s, t), o = Hl(a, s, t - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: o * 255 };
}
function mC(t, e, n) {
  t = yn(t, 255), e = yn(e, 255), n = yn(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), o = 0, s = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    o = 0;
  else {
    switch (r) {
      case t:
        o = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        o = (n - t) / a + 2;
        break;
      case n:
        o = (t - e) / a + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: s };
}
function CC(t, e, n) {
  t = yn(t, 360) * 6, e = yn(e, 100), n = yn(n, 100);
  var r = Math.floor(t), i = t - r, o = n * (1 - e), s = n * (1 - i * e), a = n * (1 - (1 - i) * e), l = r % 6, c = [n, s, o, o, a, n][l], d = [a, n, n, s, o, o][l], u = [o, o, a, n, n, s][l];
  return { r: c * 255, g: d * 255, b: u * 255 };
}
function bC(t, e, n, r) {
  var i = [
    zl(Math.round(t).toString(16)),
    zl(Math.round(e).toString(16)),
    zl(Math.round(n).toString(16))
  ];
  return i.join("");
}
function Tf(t) {
  return rn(t) / 255;
}
function rn(t) {
  return parseInt(t, 16);
}
var Lf = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function Ji(t) {
  var e = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, o = null, s = !1, a = !1;
  return typeof t == "string" && (t = wC(t)), typeof t == "object" && (Gn(t.r) && Gn(t.g) && Gn(t.b) ? (e = hC(t.r, t.g, t.b), s = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : Gn(t.h) && Gn(t.s) && Gn(t.v) ? (r = gs(t.s), i = gs(t.v), e = CC(t.h, r, i), s = !0, a = "hsv") : Gn(t.h) && Gn(t.s) && Gn(t.l) && (r = gs(t.s), o = gs(t.l), e = gC(t.h, r, o), s = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = pC(n), {
    ok: s,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
var yC = "[-\\+]?\\d+%?", vC = "[-\\+]?\\d*\\.\\d+%?", kr = "(?:".concat(vC, ")|(?:").concat(yC, ")"), Fl = "[\\s|\\(]+(".concat(kr, ")[,|\\s]+(").concat(kr, ")[,|\\s]+(").concat(kr, ")\\s*\\)?"), Ul = "[\\s|\\(]+(".concat(kr, ")[,|\\s]+(").concat(kr, ")[,|\\s]+(").concat(kr, ")[,|\\s]+(").concat(kr, ")\\s*\\)?"), Mn = {
  CSS_UNIT: new RegExp(kr),
  rgb: new RegExp("rgb" + Fl),
  rgba: new RegExp("rgba" + Ul),
  hsl: new RegExp("hsl" + Fl),
  hsla: new RegExp("hsla" + Ul),
  hsv: new RegExp("hsv" + Fl),
  hsva: new RegExp("hsva" + Ul),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function wC(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  var e = !1;
  if (Lf[t])
    t = Lf[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = Mn.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = Mn.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Mn.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = Mn.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Mn.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = Mn.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Mn.hex8.exec(t), n ? {
    r: rn(n[1]),
    g: rn(n[2]),
    b: rn(n[3]),
    a: Tf(n[4]),
    format: e ? "name" : "hex8"
  } : (n = Mn.hex6.exec(t), n ? {
    r: rn(n[1]),
    g: rn(n[2]),
    b: rn(n[3]),
    format: e ? "name" : "hex"
  } : (n = Mn.hex4.exec(t), n ? {
    r: rn(n[1] + n[1]),
    g: rn(n[2] + n[2]),
    b: rn(n[3] + n[3]),
    a: Tf(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = Mn.hex3.exec(t), n ? {
    r: rn(n[1] + n[1]),
    g: rn(n[2] + n[2]),
    b: rn(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function Gn(t) {
  return !!Mn.CSS_UNIT.exec(String(t));
}
var ms = 2, Nf = 0.16, _C = 0.05, EC = 0.05, xC = 0.15, K6 = 5, G6 = 4, kC = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function Af(t) {
  var e = t.r, n = t.g, r = t.b, i = mC(e, n, r);
  return {
    h: i.h * 360,
    s: i.s,
    v: i.v
  };
}
function Cs(t) {
  var e = t.r, n = t.g, r = t.b;
  return "#".concat(bC(e, n, r));
}
function SC(t, e, n) {
  var r = n / 100, i = {
    r: (e.r - t.r) * r + t.r,
    g: (e.g - t.g) * r + t.g,
    b: (e.b - t.b) * r + t.b
  };
  return i;
}
function Rf(t, e, n) {
  var r;
  return Math.round(t.h) >= 60 && Math.round(t.h) <= 240 ? r = n ? Math.round(t.h) - ms * e : Math.round(t.h) + ms * e : r = n ? Math.round(t.h) + ms * e : Math.round(t.h) - ms * e, r < 0 ? r += 360 : r >= 360 && (r -= 360), r;
}
function If(t, e, n) {
  if (t.h === 0 && t.s === 0)
    return t.s;
  var r;
  return n ? r = t.s - Nf * e : e === G6 ? r = t.s + Nf : r = t.s + _C * e, r > 1 && (r = 1), n && e === K6 && r > 0.1 && (r = 0.1), r < 0.06 && (r = 0.06), Number(r.toFixed(2));
}
function Df(t, e, n) {
  var r;
  return n ? r = t.v + EC * e : r = t.v - xC * e, r > 1 && (r = 1), Number(r.toFixed(2));
}
function $1(t) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], r = Ji(t), i = K6; i > 0; i -= 1) {
    var o = Af(r), s = Cs(Ji({
      h: Rf(o, i, !0),
      s: If(o, i, !0),
      v: Df(o, i, !0)
    }));
    n.push(s);
  }
  n.push(Cs(r));
  for (var a = 1; a <= G6; a += 1) {
    var l = Af(r), c = Cs(Ji({
      h: Rf(l, a),
      s: If(l, a),
      v: Df(l, a)
    }));
    n.push(c);
  }
  return e.theme === "dark" ? kC.map(function(d) {
    var u = d.index, f = d.opacity, p = Cs(SC(Ji(e.backgroundColor || "#141414"), Ji(n[u]), f * 100));
    return p;
  }) : n;
}
var Vl = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, zs = {}, jl = {};
Object.keys(Vl).forEach(function(t) {
  zs[t] = $1(Vl[t]), zs[t].primary = zs[t][5], jl[t] = $1(Vl[t], {
    theme: "dark",
    backgroundColor: "#141414"
  }), jl[t].primary = jl[t][5];
});
var MC = zs.blue, OC = Symbol("iconContext"), q6 = function() {
  return rc(OC, {
    prefixCls: U("anticon"),
    rootClassName: U(""),
    csp: U()
  });
};
function Uc() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function TC(t, e) {
  return t && t.contains ? t.contains(e) : !1;
}
var Pf = "data-vc-order", LC = "vc-icon-key", z1 = /* @__PURE__ */ new Map();
function Q6() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = t.mark;
  return e ? e.startsWith("data-") ? e : "data-".concat(e) : LC;
}
function Vc(t) {
  if (t.attachTo)
    return t.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function NC(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function Y6(t) {
  return Array.from((z1.get(t) || t).children).filter(function(e) {
    return e.tagName === "STYLE";
  });
}
function J6(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Uc())
    return null;
  var n = e.csp, r = e.prepend, i = document.createElement("style");
  i.setAttribute(Pf, NC(r)), n && n.nonce && (i.nonce = n.nonce), i.innerHTML = t;
  var o = Vc(e), s = o.firstChild;
  if (r) {
    if (r === "queue") {
      var a = Y6(o).filter(function(l) {
        return ["prepend", "prependQueue"].includes(l.getAttribute(Pf));
      });
      if (a.length)
        return o.insertBefore(i, a[a.length - 1].nextSibling), i;
    }
    o.insertBefore(i, s);
  } else
    o.appendChild(i);
  return i;
}
function AC(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = Vc(e);
  return Y6(n).find(function(r) {
    return r.getAttribute(Q6(e)) === t;
  });
}
function RC(t, e) {
  var n = z1.get(t);
  if (!n || !TC(document, n)) {
    var r = J6("", e), i = r.parentNode;
    z1.set(t, i), t.removeChild(r);
  }
}
function IC(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = Vc(n);
  RC(r, n);
  var i = AC(e, n);
  if (i)
    return n.csp && n.csp.nonce && i.nonce !== n.csp.nonce && (i.nonce = n.csp.nonce), i.innerHTML !== t && (i.innerHTML = t), i;
  var o = J6(t, n);
  return o.setAttribute(Q6(n), e), o;
}
function Bf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      DC(t, i, n[i]);
    });
  }
  return t;
}
function DC(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function PC(t, e) {
  process.env.NODE_ENV !== "production" && !t && console !== void 0 && console.error("Warning: ".concat(e));
}
function BC(t, e) {
  PC(t, "[@ant-design/icons-vue] ".concat(e));
}
function $f(t) {
  return typeof t == "object" && typeof t.name == "string" && typeof t.theme == "string" && (typeof t.icon == "object" || typeof t.icon == "function");
}
function H1(t, e, n) {
  return n ? Rr(t.tag, Bf({
    key: e
  }, n, t.attrs), (t.children || []).map(function(r, i) {
    return H1(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
  })) : Rr(t.tag, Bf({
    key: e
  }, t.attrs), (t.children || []).map(function(r, i) {
    return H1(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
  }));
}
function X6(t) {
  return $1(t)[0];
}
function e2(t) {
  return t ? Array.isArray(t) ? t : [t] : [];
}
var $C = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
function t2(t) {
  return t && t.getRootNode && t.getRootNode();
}
function zC(t) {
  return Uc() ? t2(t) instanceof ShadowRoot : !1;
}
function HC(t) {
  return zC(t) ? t2(t) : null;
}
var FC = function() {
  var e = q6(), n = e.prefixCls, r = e.csp, i = kh(), o = $C;
  n && (o = o.replace(/anticon/g, n.value)), Sh(function() {
    if (Uc()) {
      var s = i.vnode.el, a = HC(s);
      IC(o, "@ant-design-vue-icons", {
        prepend: !0,
        csp: r.value,
        attachTo: a
      });
    }
  });
}, UC = ["icon", "primaryColor", "secondaryColor"];
function VC(t, e) {
  if (t == null) return {};
  var n = jC(t, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
function jC(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function Hs(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      WC(t, i, n[i]);
    });
  }
  return t;
}
function WC(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Co = Ct({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
});
function ZC(t) {
  var e = t.primaryColor, n = t.secondaryColor;
  Co.primaryColor = e, Co.secondaryColor = n || X6(e), Co.calculated = !!n;
}
function KC() {
  return Hs({}, Co);
}
var Hr = function(e, n) {
  var r = Hs({}, e, n.attrs), i = r.icon, o = r.primaryColor, s = r.secondaryColor, a = VC(r, UC), l = Co;
  if (o && (l = {
    primaryColor: o,
    secondaryColor: s || X6(o)
  }), BC($f(i), "icon should be icon definiton, but got ".concat(i)), !$f(i))
    return null;
  var c = i;
  return c && typeof c.icon == "function" && (c = Hs({}, c, {
    icon: c.icon(l.primaryColor, l.secondaryColor)
  })), H1(c.icon, "svg-".concat(c.name), Hs({}, a, {
    "data-icon": c.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
Hr.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
Hr.inheritAttrs = !1;
Hr.displayName = "IconBase";
Hr.getTwoToneColors = KC;
Hr.setTwoToneColors = ZC;
function GC(t, e) {
  return JC(t) || YC(t, e) || QC(t, e) || qC();
}
function qC() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QC(t, e) {
  if (t) {
    if (typeof t == "string") return zf(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return zf(t, e);
  }
}
function zf(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t[n];
  return r;
}
function YC(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, s, a;
    try {
      for (n = n.call(t); !(i = (s = n.next()).done) && (r.push(s.value), !(e && r.length === e)); i = !0)
        ;
    } catch (l) {
      o = !0, a = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw a;
      }
    }
    return r;
  }
}
function JC(t) {
  if (Array.isArray(t)) return t;
}
function n2(t) {
  var e = e2(t), n = GC(e, 2), r = n[0], i = n[1];
  return Hr.setTwoToneColors({
    primaryColor: r,
    secondaryColor: i
  });
}
function XC() {
  var t = Hr.getTwoToneColors();
  return t.calculated ? [t.primaryColor, t.secondaryColor] : t.primaryColor;
}
var eb = ve({
  name: "InsertStyles",
  setup: function() {
    return FC(), function() {
      return null;
    };
  }
}), tb = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function nb(t, e) {
  return sb(t) || ob(t, e) || ib(t, e) || rb();
}
function rb() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ib(t, e) {
  if (t) {
    if (typeof t == "string") return Hf(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Hf(t, e);
  }
}
function Hf(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t[n];
  return r;
}
function ob(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, s, a;
    try {
      for (n = n.call(t); !(i = (s = n.next()).done) && (r.push(s.value), !(e && r.length === e)); i = !0)
        ;
    } catch (l) {
      o = !0, a = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw a;
      }
    }
    return r;
  }
}
function sb(t) {
  if (Array.isArray(t)) return t;
}
function Ff(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      oo(t, i, n[i]);
    });
  }
  return t;
}
function oo(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function ab(t, e) {
  if (t == null) return {};
  var n = lb(t, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
function lb(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
n2(MC.primary);
var we = function(e, n) {
  var r, i = Ff({}, e, n.attrs), o = i.class, s = i.icon, a = i.spin, l = i.rotate, c = i.tabindex, d = i.twoToneColor, u = i.onClick, f = ab(i, tb), p = q6(), h = p.prefixCls, m = p.rootClassName, g = (r = {}, oo(r, m.value, !!m.value), oo(r, h.value, !0), oo(r, "".concat(h.value, "-").concat(s.name), !!s.name), oo(r, "".concat(h.value, "-spin"), !!a || s.name === "loading"), r), C = c;
  C === void 0 && u && (C = -1);
  var v = l ? {
    msTransform: "rotate(".concat(l, "deg)"),
    transform: "rotate(".concat(l, "deg)")
  } : void 0, _ = e2(d), b = nb(_, 2), x = b[0], y = b[1];
  return k("span", Ff({
    role: "img",
    "aria-label": s.name
  }, f, {
    onClick: u,
    class: [g, o],
    tabindex: C
  }), [k(Hr, {
    icon: s,
    primaryColor: x,
    secondaryColor: y,
    style: v
  }, null), k(eb, null, null)]);
};
we.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
we.displayName = "AntdIcon";
we.inheritAttrs = !1;
we.getTwoToneColor = XC;
we.setTwoToneColor = n2;
var cb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M264 230h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H264c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm496 424c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H264c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496zm144 140H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z" } }] }, name: "align-center", theme: "outlined" };
function Uf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      db(t, i, n[i]);
    });
  }
  return t;
}
function db(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var jc = function(e, n) {
  var r = Uf({}, e, n.attrs);
  return k(we, Uf({}, r, {
    icon: cb
  }), null);
};
jc.displayName = "AlignCenterOutlined";
jc.inheritAttrs = !1;
var ub = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M120 230h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm0 424h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm784 140H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z" } }] }, name: "align-left", theme: "outlined" };
function Vf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      fb(t, i, n[i]);
    });
  }
  return t;
}
function fb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var sa = function(e, n) {
  var r = Vf({}, e, n.attrs);
  return k(we, Vf({}, r, {
    icon: ub
  }), null);
};
sa.displayName = "AlignLeftOutlined";
sa.inheritAttrs = !1;
var pb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M904 158H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 424H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 212H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z" } }] }, name: "align-right", theme: "outlined" };
function jf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      hb(t, i, n[i]);
    });
  }
  return t;
}
function hb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Wc = function(e, n) {
  var r = jf({}, e, n.attrs);
  return k(we, jf({}, r, {
    icon: pb
  }), null);
};
Wc.displayName = "AlignRightOutlined";
Wc.inheritAttrs = !1;
var gb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M766.4 744.3c43.7 0 79.4-36.2 79.4-80.5 0-53.5-79.4-140.8-79.4-140.8S687 610.3 687 663.8c0 44.3 35.7 80.5 79.4 80.5zm-377.1-44.1c7.1 7.1 18.6 7.1 25.6 0l256.1-256c7.1-7.1 7.1-18.6 0-25.6l-256-256c-.6-.6-1.3-1.2-2-1.7l-78.2-78.2a9.11 9.11 0 00-12.8 0l-48 48a9.11 9.11 0 000 12.8l67.2 67.2-207.8 207.9c-7.1 7.1-7.1 18.6 0 25.6l255.9 256zm12.9-448.6l178.9 178.9H223.4l178.8-178.9zM904 816H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8z" } }] }, name: "bg-colors", theme: "outlined" };
function Wf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      mb(t, i, n[i]);
    });
  }
  return t;
}
function mb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Zc = function(e, n) {
  var r = Wf({}, e, n.attrs);
  return k(we, Wf({}, r, {
    icon: gb
  }), null);
};
Zc.displayName = "BgColorsOutlined";
Zc.inheritAttrs = !1;
var Cb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M856 376H648V168c0-8.8-7.2-16-16-16H168c-8.8 0-16 7.2-16 16v464c0 8.8 7.2 16 16 16h208v208c0 8.8 7.2 16 16 16h464c8.8 0 16-7.2 16-16V392c0-8.8-7.2-16-16-16zm-480 16v188H220V220h360v156H392c-8.8 0-16 7.2-16 16zm204 52v136H444V444h136zm224 360H444V648h188c8.8 0 16-7.2 16-16V444h156v360z" } }] }, name: "block", theme: "outlined" };
function Zf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      bb(t, i, n[i]);
    });
  }
  return t;
}
function bb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Kc = function(e, n) {
  var r = Zf({}, e, n.attrs);
  return k(we, Zf({}, r, {
    icon: Cb
  }), null);
};
Kc.displayName = "BlockOutlined";
Kc.inheritAttrs = !1;
var yb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M697.8 481.4c33.6-35 54.2-82.3 54.2-134.3v-10.2C752 229.3 663.9 142 555.3 142H259.4c-15.1 0-27.4 12.3-27.4 27.4v679.1c0 16.3 13.2 29.5 29.5 29.5h318.7c117 0 211.8-94.2 211.8-210.5v-11c0-73-37.4-137.3-94.2-175.1zM328 238h224.7c57.1 0 103.3 44.4 103.3 99.3v9.5c0 54.8-46.3 99.3-103.3 99.3H328V238zm366.6 429.4c0 62.9-51.7 113.9-115.5 113.9H328V542.7h251.1c63.8 0 115.5 51 115.5 113.9v10.8z" } }] }, name: "bold", theme: "outlined" };
function Kf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      vb(t, i, n[i]);
    });
  }
  return t;
}
function vb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Gc = function(e, n) {
  var r = Kf({}, e, n.attrs);
  return k(we, Kf({}, r, {
    icon: yb
  }), null);
};
Gc.displayName = "BoldOutlined";
Gc.inheritAttrs = !1;
var wb = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "outlined" };
function Gf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      _b(t, i, n[i]);
    });
  }
  return t;
}
function _b(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Ln = function(e, n) {
  var r = Gf({}, e, n.attrs);
  return k(we, Gf({}, r, {
    icon: wb
  }), null);
};
Ln.displayName = "CaretDownOutlined";
Ln.inheritAttrs = !1;
var Eb = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M715.8 493.5L335 165.1c-14.2-12.2-35-1.2-35 18.5v656.8c0 19.7 20.8 30.7 35 18.5l380.8-328.4c10.9-9.4 10.9-27.6 0-37z" } }] }, name: "caret-right", theme: "outlined" };
function qf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      xb(t, i, n[i]);
    });
  }
  return t;
}
function xb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var tl = function(e, n) {
  var r = qf({}, e, n.attrs);
  return k(we, qf({}, r, {
    icon: Eb
  }), null);
};
tl.displayName = "CaretRightOutlined";
tl.inheritAttrs = !1;
var kb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M899.1 869.6l-53-305.6H864c14.4 0 26-11.6 26-26V346c0-14.4-11.6-26-26-26H618V138c0-14.4-11.6-26-26-26H432c-14.4 0-26 11.6-26 26v182H160c-14.4 0-26 11.6-26 26v192c0 14.4 11.6 26 26 26h17.9l-53 305.6a25.95 25.95 0 0025.6 30.4h723c1.5 0 3-.1 4.4-.4a25.88 25.88 0 0021.2-30zM204 390h272V182h72v208h272v104H204V390zm468 440V674c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v156H416V674c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v156H202.8l45.1-260H776l45.1 260H672z" } }] }, name: "clear", theme: "outlined" };
function Qf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Sb(t, i, n[i]);
    });
  }
  return t;
}
function Sb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var qc = function(e, n) {
  var r = Qf({}, e, n.attrs);
  return k(we, Qf({}, r, {
    icon: kb
  }), null);
};
qc.displayName = "ClearOutlined";
qc.inheritAttrs = !1;
var Mb = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" };
function Yf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Ob(t, i, n[i]);
    });
  }
  return t;
}
function Ob(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Qc = function(e, n) {
  var r = Yf({}, e, n.attrs);
  return k(we, Yf({}, r, {
    icon: Mb
  }), null);
};
Qc.displayName = "CloseOutlined";
Qc.inheritAttrs = !1;
var Tb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M518.3 459a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V856c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V613.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 459z" } }, { tag: "path", attrs: { d: "M811.4 366.7C765.6 245.9 648.9 160 512.2 160S258.8 245.8 213 366.6C127.3 389.1 64 467.2 64 560c0 110.5 89.5 200 199.9 200H304c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8h-40.1c-33.7 0-65.4-13.4-89-37.7-23.5-24.2-36-56.8-34.9-90.6.9-26.4 9.9-51.2 26.2-72.1 16.7-21.3 40.1-36.8 66.1-43.7l37.9-9.9 13.9-36.6c8.6-22.8 20.6-44.1 35.7-63.4a245.6 245.6 0 0152.4-49.9c41.1-28.9 89.5-44.2 140-44.2s98.9 15.3 140 44.2c19.9 14 37.5 30.8 52.4 49.9 15.1 19.3 27.1 40.7 35.7 63.4l13.8 36.5 37.8 10C846.1 454.5 884 503.8 884 560c0 33.1-12.9 64.3-36.3 87.7a123.07 123.07 0 01-87.6 36.3H720c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h40.1C870.5 760 960 670.5 960 560c0-92.7-63.1-170.7-148.6-193.3z" } }] }, name: "cloud-upload", theme: "outlined" };
function Jf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Lb(t, i, n[i]);
    });
  }
  return t;
}
function Lb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Yo = function(e, n) {
  var r = Jf({}, e, n.attrs);
  return k(we, Jf({}, r, {
    icon: Tb
  }), null);
};
Yo.displayName = "CloudUploadOutlined";
Yo.inheritAttrs = !1;
var Nb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "code", theme: "outlined" };
function Xf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Ab(t, i, n[i]);
    });
  }
  return t;
}
function Ab(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Yc = function(e, n) {
  var r = Xf({}, e, n.attrs);
  return k(we, Xf({}, r, {
    icon: Nb
  }), null);
};
Yc.displayName = "CodeOutlined";
Yc.inheritAttrs = !1;
var Rb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" };
function ep(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Ib(t, i, n[i]);
    });
  }
  return t;
}
function Ib(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Jo = function(e, n) {
  var r = ep({}, e, n.attrs);
  return k(we, ep({}, r, {
    icon: Rb
  }), null);
};
Jo.displayName = "DeleteOutlined";
Jo.inheritAttrs = !1;
var Db = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832.6 191.4c-84.6-84.6-221.5-84.6-306 0l-96.9 96.9 51 51 96.9-96.9c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204l-96.9 96.9 51.1 51.1 96.9-96.9c84.4-84.6 84.4-221.5-.1-306.1zM446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l96.9-96.9-51.1-51.1-96.9 96.9c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l96.9-96.9-51-51-96.8 97zM260.3 209.4a8.03 8.03 0 00-11.3 0L209.4 249a8.03 8.03 0 000 11.3l554.4 554.4c3.1 3.1 8.2 3.1 11.3 0l39.6-39.6c3.1-3.1 3.1-8.2 0-11.3L260.3 209.4z" } }] }, name: "disconnect", theme: "outlined" };
function tp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Pb(t, i, n[i]);
    });
  }
  return t;
}
function Pb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var nl = function(e, n) {
  var r = tp({}, e, n.attrs);
  return k(we, tp({}, r, {
    icon: Db
  }), null);
};
nl.displayName = "DisconnectOutlined";
nl.inheritAttrs = !1;
var Bb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.3 506.3L781.7 405.6a7.23 7.23 0 00-11.7 5.7V476H548V254h64.8c6 0 9.4-7 5.7-11.7L517.7 114.7a7.14 7.14 0 00-11.3 0L405.6 242.3a7.23 7.23 0 005.7 11.7H476v222H254v-64.8c0-6-7-9.4-11.7-5.7L114.7 506.3a7.14 7.14 0 000 11.3l127.5 100.8c4.7 3.7 11.7.4 11.7-5.7V548h222v222h-64.8c-6 0-9.4 7-5.7 11.7l100.8 127.5c2.9 3.7 8.5 3.7 11.3 0l100.8-127.5c3.7-4.7.4-11.7-5.7-11.7H548V548h222v64.8c0 6 7 9.4 11.7 5.7l127.5-100.8a7.3 7.3 0 00.1-11.4z" } }] }, name: "drag", theme: "outlined" };
function np(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      $b(t, i, n[i]);
    });
  }
  return t;
}
function $b(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Jc = function(e, n) {
  var r = np({}, e, n.attrs);
  return k(we, np({}, r, {
    icon: Bb
  }), null);
};
Jc.displayName = "DragOutlined";
Jc.inheritAttrs = !1;
var zb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M342 88H120c-17.7 0-32 14.3-32 32v224c0 8.8 7.2 16 16 16h48c8.8 0 16-7.2 16-16V168h174c8.8 0 16-7.2 16-16v-48c0-8.8-7.2-16-16-16zm578 576h-48c-8.8 0-16 7.2-16 16v176H682c-8.8 0-16 7.2-16 16v48c0 8.8 7.2 16 16 16h222c17.7 0 32-14.3 32-32V680c0-8.8-7.2-16-16-16zM342 856H168V680c0-8.8-7.2-16-16-16h-48c-8.8 0-16 7.2-16 16v224c0 17.7 14.3 32 32 32h222c8.8 0 16-7.2 16-16v-48c0-8.8-7.2-16-16-16zM904 88H682c-8.8 0-16 7.2-16 16v48c0 8.8 7.2 16 16 16h174v176c0 8.8 7.2 16 16 16h48c8.8 0 16-7.2 16-16V120c0-17.7-14.3-32-32-32z" } }] }, name: "expand", theme: "outlined" };
function rp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Hb(t, i, n[i]);
    });
  }
  return t;
}
function Hb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Xc = function(e, n) {
  var r = rp({}, e, n.attrs);
  return k(we, rp({}, r, {
    icon: zb
  }), null);
};
Xc.displayName = "ExpandOutlined";
Xc.inheritAttrs = !1;
var Fb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M531.3 574.4l.3-1.4c5.8-23.9 13.1-53.7 7.4-80.7-3.8-21.3-19.5-29.6-32.9-30.2-15.8-.7-29.9 8.3-33.4 21.4-6.6 24-.7 56.8 10.1 98.6-13.6 32.4-35.3 79.5-51.2 107.5-29.6 15.3-69.3 38.9-75.2 68.7-1.2 5.5.2 12.5 3.5 18.8 3.7 7 9.6 12.4 16.5 15 3 1.1 6.6 2 10.8 2 17.6 0 46.1-14.2 84.1-79.4 5.8-1.9 11.8-3.9 17.6-5.9 27.2-9.2 55.4-18.8 80.9-23.1 28.2 15.1 60.3 24.8 82.1 24.8 21.6 0 30.1-12.8 33.3-20.5 5.6-13.5 2.9-30.5-6.2-39.6-13.2-13-45.3-16.4-95.3-10.2-24.6-15-40.7-35.4-52.4-65.8zM421.6 726.3c-13.9 20.2-24.4 30.3-30.1 34.7 6.7-12.3 19.8-25.3 30.1-34.7zm87.6-235.5c5.2 8.9 4.5 35.8.5 49.4-4.9-19.9-5.6-48.1-2.7-51.4.8.1 1.5.7 2.2 2zm-1.6 120.5c10.7 18.5 24.2 34.4 39.1 46.2-21.6 4.9-41.3 13-58.9 20.2-4.2 1.7-8.3 3.4-12.3 5 13.3-24.1 24.4-51.4 32.1-71.4zm155.6 65.5c.1.2.2.5-.4.9h-.2l-.2.3c-.8.5-9 5.3-44.3-8.6 40.6-1.9 45 7.3 45.1 7.4zm191.4-388.2L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file-pdf", theme: "outlined" };
function ip(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Ub(t, i, n[i]);
    });
  }
  return t;
}
function Ub(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var ed = function(e, n) {
  var r = ip({}, e, n.attrs);
  return k(we, ip({}, r, {
    icon: Fb
  }), null);
};
ed.displayName = "FilePdfOutlined";
ed.inheritAttrs = !1;
var Vb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M904 816H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8zm-650.3-80h85c4.2 0 8-2.7 9.3-6.8l53.7-166h219.2l53.2 166c1.3 4 5 6.8 9.3 6.8h89.1c1.1 0 2.2-.2 3.2-.5a9.7 9.7 0 006-12.4L573.6 118.6a9.9 9.9 0 00-9.2-6.6H462.1c-4.2 0-7.9 2.6-9.2 6.6L244.5 723.1c-.4 1-.5 2.1-.5 3.2-.1 5.3 4.3 9.7 9.7 9.7zm255.9-516.1h4.1l83.8 263.8H424.9l84.7-263.8z" } }] }, name: "font-colors", theme: "outlined" };
function op(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      jb(t, i, n[i]);
    });
  }
  return t;
}
function jb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var td = function(e, n) {
  var r = op({}, e, n.attrs);
  return k(we, op({}, r, {
    icon: Vb
  }), null);
};
td.displayName = "FontColorsOutlined";
td.inheritAttrs = !1;
var Wb = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M885.2 446.3l-.2-.8-112.2-285.1c-5-16.1-19.9-27.2-36.8-27.2H281.2c-17 0-32.1 11.3-36.9 27.6L139.4 443l-.3.7-.2.8c-1.3 4.9-1.7 9.9-1 14.8-.1 1.6-.2 3.2-.2 4.8V830a60.9 60.9 0 0060.8 60.8h627.2c33.5 0 60.8-27.3 60.9-60.8V464.1c0-1.3 0-2.6-.1-3.7.4-4.9 0-9.6-1.3-14.1zm-295.8-43l-.3 15.7c-.8 44.9-31.8 75.1-77.1 75.1-22.1 0-41.1-7.1-54.8-20.6S436 441.2 435.6 419l-.3-15.7H229.5L309 210h399.2l81.7 193.3H589.4zm-375 76.8h157.3c24.3 57.1 76 90.8 140.4 90.8 33.7 0 65-9.4 90.3-27.2 22.2-15.6 39.5-37.4 50.7-63.6h156.5V814H214.4V480.1z" } }] }, name: "inbox", theme: "outlined" };
function sp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Zb(t, i, n[i]);
    });
  }
  return t;
}
function Zb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var nd = function(e, n) {
  var r = sp({}, e, n.attrs);
  return k(we, sp({}, r, {
    icon: Wb
  }), null);
};
nd.displayName = "InboxOutlined";
nd.inheritAttrs = !1;
var Kb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M798 160H366c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h181.2l-156 544H229c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h432c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8H474.4l156-544H798c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z" } }] }, name: "italic", theme: "outlined" };
function ap(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Gb(t, i, n[i]);
    });
  }
  return t;
}
function Gb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var rd = function(e, n) {
  var r = ap({}, e, n.attrs);
  return k(we, ap({}, r, {
    icon: Kb
  }), null);
};
rd.displayName = "ItalicOutlined";
rd.inheritAttrs = !1;
var qb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M574 665.4a8.03 8.03 0 00-11.3 0L446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3l-39.8-39.8a8.03 8.03 0 00-11.3 0L191.4 526.5c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3L574 665.4zm258.6-474c-84.6-84.6-221.5-84.6-306 0L410.3 307.6a8.03 8.03 0 000 11.3l39.7 39.7c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204L665.3 562.6a8.03 8.03 0 000 11.3l39.8 39.8c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c84.5-84.6 84.5-221.5 0-306.1zM610.1 372.3a8.03 8.03 0 00-11.3 0L372.3 598.7a8.03 8.03 0 000 11.3l39.6 39.6c3.1 3.1 8.2 3.1 11.3 0l226.4-226.4c3.1-3.1 3.1-8.2 0-11.3l-39.5-39.6z" } }] }, name: "link", theme: "outlined" };
function lp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Qb(t, i, n[i]);
    });
  }
  return t;
}
function Qb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var id = function(e, n) {
  var r = lp({}, e, n.attrs);
  return k(we, lp({}, r, {
    icon: qb
  }), null);
};
id.displayName = "LinkOutlined";
id.inheritAttrs = !1;
var Yb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 000 13.8z" } }] }, name: "menu-fold", theme: "outlined" };
function cp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Jb(t, i, n[i]);
    });
  }
  return t;
}
function Jb(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var od = function(e, n) {
  var r = cp({}, e, n.attrs);
  return k(we, cp({}, r, {
    icon: Yb
  }), null);
};
od.displayName = "MenuFoldOutlined";
od.inheritAttrs = !1;
var Xb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z" } }] }, name: "menu", theme: "outlined" };
function dp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      ey(t, i, n[i]);
    });
  }
  return t;
}
function ey(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var sd = function(e, n) {
  var r = dp({}, e, n.attrs);
  return k(we, dp({}, r, {
    icon: Xb
  }), null);
};
sd.displayName = "MenuOutlined";
sd.inheritAttrs = !1;
var ty = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 000-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0014.4 7z" } }] }, name: "menu-unfold", theme: "outlined" };
function up(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      ny(t, i, n[i]);
    });
  }
  return t;
}
function ny(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var ad = function(e, n) {
  var r = up({}, e, n.attrs);
  return k(we, up({}, r, {
    icon: ty
  }), null);
};
ad.displayName = "MenuUnfoldOutlined";
ad.inheritAttrs = !1;
var ry = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M872 474H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h720c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "minus", theme: "outlined" };
function fp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      iy(t, i, n[i]);
    });
  }
  return t;
}
function iy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var ld = function(e, n) {
  var r = fp({}, e, n.attrs);
  return k(we, fp({}, r, {
    icon: ry
  }), null);
};
ld.displayName = "MinusOutlined";
ld.inheritAttrs = !1;
var oy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M920 760H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-568H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM216 712H100c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h72.4v20.5h-35.7c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h35.7V838H100c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h116c2.2 0 4-1.8 4-4V716c0-2.2-1.8-4-4-4zM100 188h38v120c0 2.2 1.8 4 4 4h40c2.2 0 4-1.8 4-4V152c0-4.4-3.6-8-8-8h-78c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4zm116 240H100c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4h68.4l-70.3 77.7a8.3 8.3 0 00-2.1 5.4V592c0 2.2 1.8 4 4 4h116c2.2 0 4-1.8 4-4v-36c0-2.2-1.8-4-4-4h-68.4l70.3-77.7a8.3 8.3 0 002.1-5.4V432c0-2.2-1.8-4-4-4z" } }] }, name: "ordered-list", theme: "outlined" };
function pp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      sy(t, i, n[i]);
    });
  }
  return t;
}
function sy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var cd = function(e, n) {
  var r = pp({}, e, n.attrs);
  return k(we, pp({}, r, {
    icon: oy
  }), null);
};
cd.displayName = "OrderedListOutlined";
cd.inheritAttrs = !1;
var ay = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, name: "paper-clip", theme: "outlined" };
function hp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      ly(t, i, n[i]);
    });
  }
  return t;
}
function ly(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var rl = function(e, n) {
  var r = hp({}, e, n.attrs);
  return k(we, hp({}, r, {
    icon: ay
  }), null);
};
rl.displayName = "PaperClipOutlined";
rl.inheritAttrs = !1;
var cy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2zM304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z" } }] }, name: "picture", theme: "outlined" };
function gp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      dy(t, i, n[i]);
    });
  }
  return t;
}
function dy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var dd = function(e, n) {
  var r = gp({}, e, n.attrs);
  return k(we, gp({}, r, {
    icon: cy
  }), null);
};
dd.displayName = "PictureOutlined";
dd.inheritAttrs = !1;
var uy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z" } }] }, name: "redo", theme: "outlined" };
function mp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      fy(t, i, n[i]);
    });
  }
  return t;
}
function fy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var ud = function(e, n) {
  var r = mp({}, e, n.attrs);
  return k(we, mp({}, r, {
    icon: uy
  }), null);
};
ud.displayName = "RedoOutlined";
ud.inheritAttrs = !1;
var py = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
function Cp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      hy(t, i, n[i]);
    });
  }
  return t;
}
function hy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var fd = function(e, n) {
  var r = Cp({}, e, n.attrs);
  return k(we, Cp({}, r, {
    icon: py
  }), null);
};
fd.displayName = "SearchOutlined";
fd.inheritAttrs = !1;
var gy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M952 474H569.9c-10-2-20.5-4-31.6-6-15.9-2.9-22.2-4.1-30.8-5.8-51.3-10-82.2-20-106.8-34.2-35.1-20.5-52.2-48.3-52.2-85.1 0-37 15.2-67.7 44-89 28.4-21 68.8-32.1 116.8-32.1 54.8 0 97.1 14.4 125.8 42.8 14.6 14.4 25.3 32.1 31.8 52.6 1.3 4.1 2.8 10 4.3 17.8.9 4.8 5.2 8.2 9.9 8.2h72.8c5.6 0 10.1-4.6 10.1-10.1v-1c-.7-6.8-1.3-12.1-2-16-7.3-43.5-28-81.7-59.7-110.3-44.4-40.5-109.7-61.8-188.7-61.8-72.3 0-137.4 18.1-183.3 50.9-25.6 18.4-45.4 41.2-58.6 67.7-13.5 27.1-20.3 58.4-20.3 92.9 0 29.5 5.7 54.5 17.3 76.5 8.3 15.7 19.6 29.5 34.1 42H72c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h433.2c2.1.4 3.9.8 5.9 1.2 30.9 6.2 49.5 10.4 66.6 15.2 23 6.5 40.6 13.3 55.2 21.5 35.8 20.2 53.3 49.2 53.3 89 0 35.3-15.5 66.8-43.6 88.8-30.5 23.9-75.6 36.4-130.5 36.4-43.7 0-80.7-8.5-110.2-25-29.1-16.3-49.1-39.8-59.7-69.5-.8-2.2-1.7-5.2-2.7-9-1.2-4.4-5.3-7.5-9.7-7.5h-79.7c-5.6 0-10.1 4.6-10.1 10.1v1c.2 2.3.4 4.2.6 5.7 6.5 48.8 30.3 88.8 70.7 118.8 47.1 34.8 113.4 53.2 191.8 53.2 84.2 0 154.8-19.8 204.2-57.3 25-18.9 44.2-42.2 57.1-69 13-27.1 19.7-57.9 19.7-91.5 0-31.8-5.8-58.4-17.8-81.4-5.8-11.2-13.1-21.5-21.8-30.8H952c4.4 0 8-3.6 8-8v-60a8 8 0 00-8-7.9z" } }] }, name: "strikethrough", theme: "outlined" };
function bp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      my(t, i, n[i]);
    });
  }
  return t;
}
function my(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var pd = function(e, n) {
  var r = bp({}, e, n.attrs);
  return k(we, bp({}, r, {
    icon: gy
  }), null);
};
pd.displayName = "StrikethroughOutlined";
pd.inheritAttrs = !1;
var Cy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 208H676V232h212v136zm0 224H676V432h212v160zM412 432h200v160H412V432zm200-64H412V232h200v136zm-476 64h212v160H136V432zm0-200h212v136H136V232zm0 424h212v136H136V656zm276 0h200v136H412V656zm476 136H676V656h212v136z" } }] }, name: "table", theme: "outlined" };
function yp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      by(t, i, n[i]);
    });
  }
  return t;
}
function by(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var hd = function(e, n) {
  var r = yp({}, e, n.attrs);
  return k(we, yp({}, r, {
    icon: Cy
  }), null);
};
hd.displayName = "TableOutlined";
hd.inheritAttrs = !1;
var yy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M824 804H200c-4.4 0-8 3.4-8 7.6v60.8c0 4.2 3.6 7.6 8 7.6h624c4.4 0 8-3.4 8-7.6v-60.8c0-4.2-3.6-7.6-8-7.6zm-312-76c69.4 0 134.6-27.1 183.8-76.2C745 602.7 772 537.4 772 468V156c0-6.6-5.4-12-12-12h-60c-6.6 0-12 5.4-12 12v312c0 97-79 176-176 176s-176-79-176-176V156c0-6.6-5.4-12-12-12h-60c-6.6 0-12 5.4-12 12v312c0 69.4 27.1 134.6 76.2 183.8C377.3 701 442.6 728 512 728z" } }] }, name: "underline", theme: "outlined" };
function vp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      vy(t, i, n[i]);
    });
  }
  return t;
}
function vy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var gd = function(e, n) {
  var r = vp({}, e, n.attrs);
  return k(we, vp({}, r, {
    icon: yy
  }), null);
};
gd.displayName = "UnderlineOutlined";
gd.inheritAttrs = !1;
var wy = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z" } }] }, name: "undo", theme: "outlined" };
function wp(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      _y(t, i, n[i]);
    });
  }
  return t;
}
function _y(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var md = function(e, n) {
  var r = wp({}, e, n.attrs);
  return k(we, wp({}, r, {
    icon: wy
  }), null);
};
md.displayName = "UndoOutlined";
md.inheritAttrs = !1;
var Ey = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "unordered-list", theme: "outlined" };
function _p(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      xy(t, i, n[i]);
    });
  }
  return t;
}
function xy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var Cd = function(e, n) {
  var r = _p({}, e, n.attrs);
  return k(we, _p({}, r, {
    icon: Ey
  }), null);
};
Cd.displayName = "UnorderedListOutlined";
Cd.inheritAttrs = !1;
var ky = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 302.3L784 376V224c0-35.3-28.7-64-64-64H128c-35.3 0-64 28.7-64 64v576c0 35.3 28.7 64 64 64h592c35.3 0 64-28.7 64-64V648l128 73.7c21.3 12.3 48-3.1 48-27.6V330c0-24.6-26.7-40-48-27.7zM712 792H136V232h576v560zm176-167l-104-59.8V458.9L888 399v226zM208 360h112c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H208c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }] }, name: "video-camera", theme: "outlined" };
function Ep(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Sy(t, i, n[i]);
    });
  }
  return t;
}
function Sy(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var bd = function(e, n) {
  var r = Ep({}, e, n.attrs);
  return k(we, Ep({}, r, {
    icon: ky
  }), null);
};
bd.displayName = "VideoCameraOutlined";
bd.inheritAttrs = !1;
const My = (t, e) => [
  {
    name: "UndoOutlined",
    component: md,
    tip: "撤销",
    click() {
      t.chain().focus().undo().run();
    },
    active: !1
  },
  {
    name: "RedoOutlined",
    component: ud,
    tip: "重做",
    click() {
      t.chain().focus().redo().run();
    },
    active: !1
  },
  {
    name: "DeleteOutlined",
    component: Jo,
    tip: "清除格式",
    click() {
      t.chain().focus().clearNodes().unsetAllMarks().run();
    },
    active: !1
  },
  {
    name: "bold",
    component: Gc,
    click() {
      t.chain().focus().toggleBold().run();
    },
    tip: "粗体",
    active: !1
  },
  {
    name: "underline",
    component: gd,
    click() {
      t.chain().focus().toggleUnderline().run();
    },
    tip: "下划线",
    active: !1
  },
  {
    name: "strike",
    component: pd,
    click() {
      t.chain().focus().toggleStrike().run();
    },
    tip: "删除线",
    active: !1
  },
  {
    name: "italic",
    component: rd,
    tip: "斜体",
    click() {
      t.chain().focus().toggleItalic().run();
    },
    active: !1
  },
  {
    name: "MinusOutlined",
    component: ld,
    tip: "水平线",
    click() {
      t.chain().focus().setHorizontalRule().run();
    },
    active: !1
  },
  {
    name: "MenuUnfoldOutlined",
    component: ad,
    tip: "缩进",
    click() {
      t.chain().focus().indent().run();
    },
    active: !1
  },
  {
    name: "MenuFoldOutlined",
    component: od,
    tip: "取消缩进",
    click() {
      t.chain().focus().outdent().run();
    },
    active: !1
  },
  {
    name: "blockquote",
    component: Kc,
    click() {
      t.chain().focus().toggleBlockquote().run();
    },
    tip: "引用",
    active: !1
  },
  {
    name: "codeBlock",
    component: Yc,
    click() {
      t.chain().focus().toggleCodeBlock().run();
    },
    tip: "代码块",
    active: !1
  },
  {
    name: "searchoutlined",
    component: fd,
    tip: "查找",
    click() {
      const { toggleModal: n } = e[this.name];
      n();
    },
    active: !1
  },
  {
    name: "unsetlink",
    component: nl,
    tip: "取消链接",
    click() {
      t.chain().focus().extendMarkRange("link").unsetLink().run();
    },
    active: !1
  }
], Oy = () => {
  const t = U(!1);
  return {
    closeModal: () => {
      t.value = !1;
    },
    openModal: () => {
      t.value = !0;
    },
    visible: t,
    toggleModal: () => {
      t.value = !t.value;
    }
  };
}, Ty = /* @__PURE__ */ ve({
  __name: "tool-template",
  props: {
    editor: {},
    option: {}
  },
  setup(t) {
    return (e, n) => {
      const r = ce("a-tooltip");
      return B(), ye(r, {
        placement: "top",
        "show-after": 200
      }, {
        title: R(() => [
          E("span", null, ft(e.option.tip), 1)
        ]),
        default: R(() => [
          E("div", {
            class: lt(["tool", e.editor.isActive(e.option.name) ? "tool--active" : ""]),
            onClick: n[0] || (n[0] = //@ts-ignore
            (...i) => e.option.click && e.option.click(...i)),
            onDblclick: n[1] || (n[1] = //@ts-ignore
            (...i) => e.option.dblclick && e.option.dblclick(...i))
          }, [
            (B(), ye(js(e.option.component), { style: { "font-size": "16px" } }))
          ], 34)
        ]),
        _: 1
      });
    };
  }
}), dt = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, Ly = {}, Ny = { class: "x-divider" };
function Ay(t, e) {
  return B(), he("div", Ny);
}
const Ry = /* @__PURE__ */ dt(Ly, [["render", Ay], ["__scopeId", "data-v-d1c2e2b4"]]), Iy = [
  "rgb(0, 0, 0)",
  "rgb(38, 38, 38)",
  "rgb(89, 89, 89)",
  "rgb(140, 140, 140)",
  "rgb(191, 191, 191)",
  "rgb(217, 217, 217)",
  "rgb(233, 233, 233)",
  "rgb(245, 245, 245)",
  "rgb(250, 250, 250)",
  "rgb(255, 255, 255)",
  // 10
  "rgb(225, 60, 57)",
  "rgb(231, 95, 51)",
  "rgb(235, 144, 58)",
  "rgb(245, 219, 77)",
  "rgb(114, 192, 64)",
  "rgb(89, 191, 192)",
  "rgb(66, 144, 247)",
  "rgb(54, 88, 226)",
  "rgb(106, 57, 201)",
  "rgb(216, 68, 147)",
  // 10
  "rgb(251, 233, 230)",
  "rgb(252, 237, 225)",
  "rgb(252, 239, 212)",
  "rgb(252, 251, 207)",
  "rgb(231, 246, 213)",
  "rgb(218, 244, 240)",
  "rgb(217, 237, 250)",
  "rgb(224, 232, 250)",
  "rgb(237, 225, 248)",
  "rgb(246, 226, 234)",
  // 10
  "rgb(255, 163, 158)",
  "rgb(255, 187, 150)",
  "rgb(255, 213, 145)",
  "rgb(255, 251, 143)",
  "rgb(183, 235, 143)",
  "rgb(135, 232, 222)",
  "rgb(145, 213, 255)",
  "rgb(173, 198, 255)",
  "rgb(211, 173, 247)",
  "rgb(255, 173, 210)",
  // 10
  "rgb(255, 77, 79)",
  "rgb(255, 122, 69)",
  "rgb(255, 169, 64)",
  "rgb(255, 236, 61)",
  "rgb(115, 209, 61)",
  "rgb(54, 207, 201)",
  "rgb(64, 169, 255)",
  "rgb(89, 126, 247)",
  "rgb(146, 84, 222)",
  "rgb(247, 89, 171)",
  // 10
  "rgb(207, 19, 34)",
  "rgb(212, 56, 13)",
  "rgb(212, 107, 8)",
  "rgb(212, 177, 6)",
  "rgb(56, 158, 13)",
  "rgb(8, 151, 156)",
  "rgb(9, 109, 217)",
  "rgb(29, 57, 196)",
  "rgb(83, 29, 171)",
  "rgb(196, 29, 127)",
  // 10
  "rgb(130, 0, 20)",
  "rgb(135, 20, 0)",
  "rgb(135, 56, 0)",
  "rgb(97, 71, 0)",
  "rgb(19, 82, 0)",
  "rgb(0, 71, 79)",
  "rgb(0, 58, 140)",
  "rgb(6, 17, 120)",
  "rgb(34, 7, 94)",
  "rgb(120, 6, 80)"
  // 10
], r2 = () => Iy;
function Lt(t, e) {
  Dy(t) && (t = "100%");
  const n = Py(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function bs(t) {
  return Math.min(1, Math.max(0, t));
}
function Dy(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function Py(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function i2(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function ys(t) {
  return Number(t) <= 1 ? `${Number(t) * 100}%` : t;
}
function Gr(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function By(t, e, n) {
  return {
    r: Lt(t, 255) * 255,
    g: Lt(e, 255) * 255,
    b: Lt(n, 255) * 255
  };
}
function xp(t, e, n) {
  t = Lt(t, 255), e = Lt(e, 255), n = Lt(n, 255);
  const r = Math.max(t, e, n), i = Math.min(t, e, n);
  let o = 0, s = 0;
  const a = (r + i) / 2;
  if (r === i)
    s = 0, o = 0;
  else {
    const l = r - i;
    switch (s = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case t:
        o = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        o = (n - t) / l + 2;
        break;
      case n:
        o = (t - e) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s, l: a };
}
function Wl(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function $y(t, e, n) {
  let r, i, o;
  if (t = Lt(t, 360), e = Lt(e, 100), n = Lt(n, 100), e === 0)
    i = n, o = n, r = n;
  else {
    const s = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - s;
    r = Wl(a, s, t + 1 / 3), i = Wl(a, s, t), o = Wl(a, s, t - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: o * 255 };
}
function kp(t, e, n) {
  t = Lt(t, 255), e = Lt(e, 255), n = Lt(n, 255);
  const r = Math.max(t, e, n), i = Math.min(t, e, n);
  let o = 0;
  const s = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    o = 0;
  else {
    switch (r) {
      case t:
        o = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        o = (n - t) / a + 2;
        break;
      case n:
        o = (t - e) / a + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: s };
}
function zy(t, e, n) {
  t = Lt(t, 360) * 6, e = Lt(e, 100), n = Lt(n, 100);
  const r = Math.floor(t), i = t - r, o = n * (1 - e), s = n * (1 - i * e), a = n * (1 - (1 - i) * e), l = r % 6, c = [n, s, o, o, a, n][l], d = [a, n, n, s, o, o][l], u = [o, o, a, n, n, s][l];
  return { r: c * 255, g: d * 255, b: u * 255 };
}
function Sp(t, e, n, r) {
  const i = [
    Gr(Math.round(t).toString(16)),
    Gr(Math.round(e).toString(16)),
    Gr(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function Hy(t, e, n, r, i) {
  const o = [
    Gr(Math.round(t).toString(16)),
    Gr(Math.round(e).toString(16)),
    Gr(Math.round(n).toString(16)),
    Gr(Uy(r))
  ];
  return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function Fy(t, e, n, r) {
  const i = t / 100, o = e / 100, s = n / 100, a = r / 100, l = 255 * (1 - i) * (1 - a), c = 255 * (1 - o) * (1 - a), d = 255 * (1 - s) * (1 - a);
  return { r: l, g: c, b: d };
}
function Mp(t, e, n) {
  let r = 1 - t / 255, i = 1 - e / 255, o = 1 - n / 255, s = Math.min(r, i, o);
  return s === 1 ? (r = 0, i = 0, o = 0) : (r = (r - s) / (1 - s) * 100, i = (i - s) / (1 - s) * 100, o = (o - s) / (1 - s) * 100), s *= 100, {
    c: Math.round(r),
    m: Math.round(i),
    y: Math.round(o),
    k: Math.round(s)
  };
}
function Uy(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function Op(t) {
  return on(t) / 255;
}
function on(t) {
  return parseInt(t, 16);
}
function Vy(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255
  };
}
const F1 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function jy(t) {
  let e = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, o = null, s = !1, a = !1;
  return typeof t == "string" && (t = Ky(t)), typeof t == "object" && (nn(t.r) && nn(t.g) && nn(t.b) ? (e = By(t.r, t.g, t.b), s = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : nn(t.h) && nn(t.s) && nn(t.v) ? (r = ys(t.s), i = ys(t.v), e = zy(t.h, r, i), s = !0, a = "hsv") : nn(t.h) && nn(t.s) && nn(t.l) ? (r = ys(t.s), o = ys(t.l), e = $y(t.h, r, o), s = !0, a = "hsl") : nn(t.c) && nn(t.m) && nn(t.y) && nn(t.k) && (e = Fy(t.c, t.m, t.y, t.k), s = !0, a = "cmyk"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = i2(n), {
    ok: s,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
const Wy = "[-\\+]?\\d+%?", Zy = "[-\\+]?\\d*\\.\\d+%?", Sr = "(?:" + Zy + ")|(?:" + Wy + ")", Zl = "[\\s|\\(]+(" + Sr + ")[,|\\s]+(" + Sr + ")[,|\\s]+(" + Sr + ")\\s*\\)?", vs = (
  // eslint-disable-next-line prettier/prettier
  "[\\s|\\(]+(" + Sr + ")[,|\\s]+(" + Sr + ")[,|\\s]+(" + Sr + ")[,|\\s]+(" + Sr + ")\\s*\\)?"
), pn = {
  CSS_UNIT: new RegExp(Sr),
  rgb: new RegExp("rgb" + Zl),
  rgba: new RegExp("rgba" + vs),
  hsl: new RegExp("hsl" + Zl),
  hsla: new RegExp("hsla" + vs),
  hsv: new RegExp("hsv" + Zl),
  hsva: new RegExp("hsva" + vs),
  cmyk: new RegExp("cmyk" + vs),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function Ky(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  let e = !1;
  if (F1[t])
    t = F1[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  let n = pn.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = pn.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = pn.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = pn.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = pn.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = pn.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = pn.cmyk.exec(t), n ? {
    c: n[1],
    m: n[2],
    y: n[3],
    k: n[4]
  } : (n = pn.hex8.exec(t), n ? {
    r: on(n[1]),
    g: on(n[2]),
    b: on(n[3]),
    a: Op(n[4]),
    format: e ? "name" : "hex8"
  } : (n = pn.hex6.exec(t), n ? {
    r: on(n[1]),
    g: on(n[2]),
    b: on(n[3]),
    format: e ? "name" : "hex"
  } : (n = pn.hex4.exec(t), n ? {
    r: on(n[1] + n[1]),
    g: on(n[2] + n[2]),
    b: on(n[3] + n[3]),
    a: Op(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = pn.hex3.exec(t), n ? {
    r: on(n[1] + n[1]),
    g: on(n[2] + n[2]),
    b: on(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1))))))))));
}
function nn(t) {
  return typeof t == "number" ? !Number.isNaN(t) : pn.CSS_UNIT.test(t);
}
class Oe {
  constructor(e = "", n = {}) {
    if (e instanceof Oe)
      return e;
    typeof e == "number" && (e = Vy(e)), this.originalInput = e;
    const r = jy(e);
    this.originalInput = e, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = n.format ?? r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const e = this.toRgb();
    return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const e = this.toRgb();
    let n, r, i;
    const o = e.r / 255, s = e.g / 255, a = e.b / 255;
    return o <= 0.03928 ? n = o / 12.92 : n = Math.pow((o + 0.055) / 1.055, 2.4), s <= 0.03928 ? r = s / 12.92 : r = Math.pow((s + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(e) {
    return this.a = i2(e), this.roundA = Math.round(100 * this.a) / 100, this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: e } = this.toHsl();
    return e === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const e = kp(this.r, this.g, this.b);
    return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const e = kp(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
    return this.a === 1 ? `hsv(${n}, ${r}%, ${i}%)` : `hsva(${n}, ${r}%, ${i}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const e = xp(this.r, this.g, this.b);
    return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const e = xp(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
    return this.a === 1 ? `hsl(${n}, ${r}%, ${i}%)` : `hsla(${n}, ${r}%, ${i}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(e = !1) {
    return Sp(this.r, this.g, this.b, e);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(e = !1) {
    return "#" + this.toHex(e);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(e = !1) {
    return Hy(this.r, this.g, this.b, this.a, e);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(e = !1) {
    return "#" + this.toHex8(e);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(e = !1) {
    return this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const e = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
    return this.a === 1 ? `rgb(${e}, ${n}, ${r})` : `rgba(${e}, ${n}, ${r}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const e = (n) => `${Math.round(Lt(n, 255) * 100)}%`;
    return {
      r: e(this.r),
      g: e(this.g),
      b: e(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const e = (n) => Math.round(Lt(n, 255) * 100);
    return this.a === 1 ? `rgb(${e(this.r)}%, ${e(this.g)}%, ${e(this.b)}%)` : `rgba(${e(this.r)}%, ${e(this.g)}%, ${e(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...Mp(this.r, this.g, this.b)
    };
  }
  toCmykString() {
    const { c: e, m: n, y: r, k: i } = Mp(this.r, this.g, this.b);
    return `cmyk(${e}, ${n}, ${r}, ${i})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0)
      return "transparent";
    if (this.a < 1)
      return !1;
    const e = "#" + Sp(this.r, this.g, this.b, !1);
    for (const [n, r] of Object.entries(F1))
      if (e === r)
        return n;
    return !1;
  }
  toString(e) {
    const n = !!e;
    e = e ?? this.format;
    let r = !1;
    const i = this.a < 1 && this.a >= 0;
    return !n && i && (e.startsWith("hex") || e === "name") ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), e === "cmyk" && (r = this.toCmykString()), r || this.toHexString());
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }
  clone() {
    return new Oe(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(e = 10) {
    const n = this.toHsl();
    return n.l += e / 100, n.l = bs(n.l), new Oe(n);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(e = 10) {
    const n = this.toRgb();
    return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new Oe(n);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(e = 10) {
    const n = this.toHsl();
    return n.l -= e / 100, n.l = bs(n.l), new Oe(n);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(e = 10) {
    return this.mix("white", e);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(e = 10) {
    return this.mix("black", e);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(e = 10) {
    const n = this.toHsl();
    return n.s -= e / 100, n.s = bs(n.s), new Oe(n);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(e = 10) {
    const n = this.toHsl();
    return n.s += e / 100, n.s = bs(n.s), new Oe(n);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(e) {
    const n = this.toHsl(), r = (n.h + e) % 360;
    return n.h = r < 0 ? 360 + r : r, new Oe(n);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(e, n = 50) {
    const r = this.toRgb(), i = new Oe(e).toRgb(), o = n / 100, s = {
      r: (i.r - r.r) * o + r.r,
      g: (i.g - r.g) * o + r.g,
      b: (i.b - r.b) * o + r.b,
      a: (i.a - r.a) * o + r.a
    };
    return new Oe(s);
  }
  analogous(e = 6, n = 30) {
    const r = this.toHsl(), i = 360 / n, o = [this];
    for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
      r.h = (r.h + i) % 360, o.push(new Oe(r));
    return o;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const e = this.toHsl();
    return e.h = (e.h + 180) % 360, new Oe(e);
  }
  monochromatic(e = 6) {
    const n = this.toHsv(), { h: r } = n, { s: i } = n;
    let { v: o } = n;
    const s = [], a = 1 / e;
    for (; e--; )
      s.push(new Oe({ h: r, s: i, v: o })), o = (o + a) % 1;
    return s;
  }
  splitcomplement() {
    const e = this.toHsl(), { h: n } = e;
    return [
      this,
      new Oe({ h: (n + 72) % 360, s: e.s, l: e.l }),
      new Oe({ h: (n + 216) % 360, s: e.s, l: e.l })
    ];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(e) {
    const n = this.toRgb(), r = new Oe(e).toRgb(), i = n.a + r.a * (1 - n.a);
    return new Oe({
      r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
      g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
      b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
      a: i
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(e) {
    const n = this.toHsl(), { h: r } = n, i = [this], o = 360 / e;
    for (let s = 1; s < e; s++)
      i.push(new Oe({ h: (r + s * o) % 360, s: n.s, l: n.l }));
    return i;
  }
  /**
   * compare color vs current color
   */
  equals(e) {
    const n = new Oe(e);
    return this.format === "cmyk" || n.format === "cmyk" ? this.toCmykString() === n.toCmykString() : this.toRgbString() === n.toRgbString();
  }
}
const Gy = { class: "color-picker-input-container" }, qy = { class: "picker-input" }, Qy = { class: "color-rgb-hex" }, Yy = { class: "picker-input" }, Jy = { class: "picker-input" }, Xy = { class: "picker-input" }, ev = /* @__PURE__ */ ve({
  __name: "color-input",
  props: {
    forms: {}
  },
  emits: ["emitInput"],
  setup(t, { emit: e }) {
    const n = e, r = t, i = (s) => {
      const l = s.target.value, c = /([0-9A-Fa-f]{3}){1,2}$/;
      if (l.length !== 6 || !c)
        return;
      const { h: d, s: u, v: f } = new Oe(l).toHsv();
      n("emitInput", { h: d, s: u, v: f, type: "hex" });
    }, o = (s) => {
      if (s.target.value.length !== 3)
        return;
      const { h: c, s: d, v: u } = new Oe(
        `rgb(${r.forms.r}, ${r.forms.g}, ${r.forms.b})`
      ).toHsv();
      n("emitInput", { h: c, s: d, v: u, type: "rgb" });
    };
    return (s, a) => {
      const l = ce("a-input");
      return B(), he("div", Gy, [
        E("div", qy, [
          E("div", Qy, [
            k(l, {
              value: s.forms.hex,
              "onUpdate:value": a[0] || (a[0] = (c) => s.forms.hex = c),
              maxlength: 6,
              style: { width: "80px" },
              size: "small",
              onChange: i
            }, {
              prefix: R(() => a[4] || (a[4] = [
                E("span", null, "#", -1)
              ])),
              _: 1
            }, 8, ["value"])
          ]),
          a[5] || (a[5] = E("div", { class: "color-rgb-name" }, "Hex", -1))
        ]),
        E("div", Yy, [
          E("div", null, [
            k(l, {
              value: s.forms.r,
              "onUpdate:value": a[1] || (a[1] = (c) => s.forms.r = c),
              maxlength: 3,
              size: "small",
              onChange: o
            }, null, 8, ["value"])
          ]),
          a[6] || (a[6] = E("div", { class: "color-rgb-name" }, "R", -1))
        ]),
        E("div", Jy, [
          E("div", null, [
            k(l, {
              value: s.forms.g,
              "onUpdate:value": a[2] || (a[2] = (c) => s.forms.g = c),
              maxlength: 3,
              size: "small",
              onChange: o
            }, null, 8, ["value"])
          ]),
          a[7] || (a[7] = E("div", { class: "color-rgb-name" }, "G", -1))
        ]),
        E("div", Xy, [
          E("div", null, [
            k(l, {
              value: s.forms.b,
              "onUpdate:value": a[3] || (a[3] = (c) => s.forms.b = c),
              maxlength: 3,
              size: "small",
              onChange: o
            }, null, 8, ["value"])
          ]),
          a[8] || (a[8] = E("div", { class: "color-rgb-name" }, "B", -1))
        ])
      ]);
    };
  }
}), tv = /* @__PURE__ */ dt(ev, [["__scopeId", "data-v-744ac0bb"]]), Kl = /* @__PURE__ */ ve({
  __name: "transform",
  props: {
    direction: {
      type: Object,
      default: () => ["x", "y"]
    },
    color: {
      type: Object
    },
    defaultPoint: {
      type: Object,
      default: () => ({ x: 0, y: 0 })
    },
    containerName: String
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = e, r = t, i = U(), o = rc(r.containerName), s = U(0), a = U(!1), l = U(r.defaultPoint), c = Ge(
      () => `left:${l.value.x}px;position:absolute;touch-action:none;top:${l.value.y}px;`
    ), d = (g) => {
      if (i.value) {
        const { width: b } = i.value.getBoundingClientRect();
        s.value = b / 2;
      }
      const C = o.value.getBoundingClientRect(), v = g.clientX - C.left - s.value, _ = g.clientY - C.top - s.value;
      r.direction.includes("x") && (l.value.x = v), r.direction.includes("y") && (l.value.y = _), a.value = !0, m(l.value);
    }, u = (g) => {
      if (!a.value)
        return;
      const { x: C, y: v, width: _, height: b } = o.value.getBoundingClientRect();
      let x = g.clientX - C <= 0 ? 0 : g.clientX - C > _ ? _ : g.clientX - C, y = g.clientY - v <= 0 ? 0 : g.clientY - v > b ? b : g.clientY - v;
      r.direction.includes("x") && (l.value.x = x - s.value), r.direction.includes("y") && (l.value.y = y - s.value), m({
        x,
        y
      });
    }, f = (g) => {
      a.value = !1;
    }, p = (g, C, v, _) => {
      g && g.addEventListener(C, v, _);
    }, h = () => {
      const g = { capture: !0 };
      p(o.value, "pointerdown", d, g), p(window, "pointermove", u, g), p(window, "pointerup", f, g);
    };
    di(() => {
      h();
    });
    const m = (g) => {
      n("change", {
        container: o,
        targetRef: i,
        offset: g,
        color: r.color
      });
    };
    return (g, C) => (B(), he("div", {
      ref_key: "el",
      ref: i,
      style: or(c.value)
    }, [
      Vi(g.$slots, "default")
    ], 4));
  }
}), nv = /* @__PURE__ */ ve({
  __name: "color-picker-circle",
  props: {
    size: {
      default: 16
    },
    bgColor: {
      default: "transparent"
    }
  },
  setup(t) {
    k4((o) => ({
      "1e61a2e0": r.value,
      "1e61a2fe": i.value
    }));
    const e = t, n = Ge(() => ({
      width: `${e.size}px`,
      height: `${e.size}px`,
      background: `${e.bgColor}`
    })), r = U(`${e.size}px`), i = U(`${e.size}px`);
    return (o, s) => (B(), he("div", {
      class: "color-picker-circle",
      style: or(n.value)
    }, null, 4));
  }
}), Gl = /* @__PURE__ */ dt(nv, [["__scopeId", "data-v-379dfe58"]]), Tp = ({
  container: t,
  targetRef: e,
  offset: n
}) => {
  const { width: r, height: i } = t.value.getBoundingClientRect(), o = n.x / r, s = 1 - n.y / i;
  return {
    saturation: o,
    lightness: s
  };
}, rv = ({
  container: t,
  targetRef: e,
  offset: n
}) => {
  const { width: r, height: i } = t.value.getBoundingClientRect();
  return Math.floor(360 * (n.x / r));
}, Lp = ({
  container: t,
  targetRef: e,
  offset: n
}) => {
  const { width: r, height: i } = t.value.getBoundingClientRect();
  return n.x / r <= 0 ? 0 : n.x / r;
}, iv = ({
  container: t,
  s: e,
  v: n
}) => {
  const { width: r, height: i } = t.value.getBoundingClientRect(), o = Math.floor(e * r), s = Math.floor((1 - n) * i);
  return { x: o, y: s };
}, ov = ({ container: t, h: e }) => {
  const { width: n, height: r } = t.value.getBoundingClientRect();
  return Math.floor(e / 360 * n);
}, sv = ({ container: t, s: e }) => {
  const { width: n, height: r } = t.value.getBoundingClientRect();
  return e * n;
}, av = { class: "color-picker-panel" }, lv = { class: "color-picker-panel-slide-container" }, cv = {
  class: "color-picker-panel-slide-group",
  ref: "slideGroup"
}, dv = { class: "color-picker-container" }, uv = /* @__PURE__ */ ve({
  __name: "color-picker-panel",
  props: ["forms", "panelPoint", "huePoint", "opacityPoint"],
  emits: ["changeForms", "updateColor"],
  setup(t, { expose: e, emit: n }) {
    const r = t, i = n, o = U(new Oe("white")), s = U(new Oe("red")), a = U(new Oe("#fff")), l = U(), c = U(), d = U(), u = U(), f = U(), p = U(), h = U(), m = U();
    nr("slideOpa", h), nr("panel", u), nr("container", f), nr("slideHue", p), nr("slideGroup", m);
    const g = Ge(() => ({
      backgroundColor: `hsl(${o.value.toHsl().h},100%, 50%)`,
      backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
    })), C = Ge(() => ({
      background: `linear-gradient(90deg, rgba(255, 0, 4, 0) 0%, ${o.value.toRgbString()} 100%)`
    })), v = (T) => {
      const D = o.value.toHsv(), { saturation: j, lightness: V } = Tp(T);
      o.value = new Oe({
        h: D.h,
        s: j <= 0 ? 0 : j,
        v: V >= 1 ? 1 : V,
        a: D.a
      });
      const X = Lp({
        container: h,
        targetRef: d,
        offset: r.opacityPoint
      });
      a.value = new Oe({
        h: D.h,
        s: j <= 0 ? 0 : j,
        v: V >= 1 ? 1 : V,
        a: X
      }), i("changeForms", a.value.toHex()), i("updateColor", `#${a.value.toHex()}`);
    }, _ = (T) => {
      const D = rv(T), j = s.value.toHsv(), V = a.value.toHsv(), { saturation: X, lightness: de } = Tp({
        container: f,
        targetRef: l,
        offset: r.panelPoint
      });
      o.value = new Oe({
        h: D,
        s: X <= 0 ? 0 : X,
        v: de >= 1 ? 1 : de,
        a: j.a
      }), s.value = new Oe({
        h: D,
        s: j.s,
        v: j.v,
        a: j.a
      }), a.value = new Oe({
        h: D,
        s: V.s,
        v: V.v,
        a: V.a
      }), i("updateColor", `#${a.value.toHex()}`);
    }, b = (T) => {
      const D = Lp(T), j = a.value.toHsv();
      a.value = new Oe({
        h: o.value.toHsl().h,
        s: j.s,
        v: j.v,
        a: D
      }), i("updateColor", a.value.toRgbString());
    };
    return e({
      handleColor: ({ type: T, value: D }) => T === "set" && D ? (o.value = D, null) : o.value,
      handleHueColor: ({ type: T, value: D }) => T === "set" && D ? (s.value = D, null) : s.value,
      handleOpacityColor: ({ type: T, value: D }) => T === "set" && D ? (a.value = D, null) : a.value,
      getAllContainer: () => ({
        containerRef: f,
        slideHueRef: p,
        slideOpaRef: h
      })
    }), (T, D) => (B(), he("div", av, [
      E("div", {
        class: "color-picker-panel-palette",
        style: or(g.value),
        ref_key: "containerRef",
        ref: f
      }, [
        k(Kl, {
          ref_key: "transformColor",
          ref: l,
          color: o.value,
          onChange: v,
          containerName: "container",
          parentName: "panel",
          defaultPoint: t.panelPoint
        }, {
          default: R(() => [
            k(Gl, {
              bgColor: o.value.toRgbString()
            }, null, 8, ["bgColor"])
          ]),
          _: 1
        }, 8, ["color", "defaultPoint"])
      ], 4),
      E("div", lv, [
        E("div", cv, [
          E("div", {
            class: "color-picker-panel-slide color-hue",
            ref_key: "slideHueRef",
            ref: p
          }, [
            k(Kl, {
              ref_key: "transformSlide",
              ref: c,
              color: o.value,
              containerName: "slideHue",
              direction: ["x"],
              parentName: "slideGroup",
              defaultPoint: t.huePoint,
              onChange: _
            }, {
              default: R(() => [
                k(Gl, {
                  bgColor: s.value.toRgbString(),
                  size: 8
                }, null, 8, ["bgColor"])
              ]),
              _: 1
            }, 8, ["color", "defaultPoint"])
          ], 512),
          E("div", {
            class: "color-picker-panel-slide color-opacity",
            ref_key: "slideOpaRef",
            ref: h
          }, [
            E("div", {
              class: "color-picker-slider-rail",
              style: or(C.value)
            }, [
              k(Kl, {
                ref_key: "transformOpacity",
                ref: d,
                color: o.value,
                containerName: "slideOpa",
                direction: ["x"],
                parentName: "slideGroup",
                defaultPoint: t.opacityPoint,
                onChange: b
              }, {
                default: R(() => [
                  E("div", dv, [
                    k(Gl, {
                      bgColor: a.value.toRgbString(),
                      size: 8
                    }, null, 8, ["bgColor"])
                  ])
                ]),
                _: 1
              }, 8, ["color", "defaultPoint"])
            ], 4)
          ], 512)
        ], 512),
        E("div", {
          class: "color-picker-block",
          style: or(`background:${a.value.toRgbString()}`)
        }, D[0] || (D[0] = [
          E("div", { class: "color-picker-block-inner" }, null, -1)
        ]), 4)
      ])
    ]));
  }
}), fv = /* @__PURE__ */ dt(uv, [["__scopeId", "data-v-9c36e720"]]);
function Np(t) {
  return t[0] === "#" && (t = t.substr(1)), t.length === 3 ? {
    r: parseInt(t[0] + t[0], 16),
    g: parseInt(t[1] + t[1], 16),
    b: parseInt(t[2] + t[2], 16)
  } : {
    r: parseInt(t.substr(0, 2), 16),
    g: parseInt(t.substr(2, 2), 16),
    b: parseInt(t.substr(4, 2), 16)
  };
}
const pv = { class: "color-picker" }, hv = /* @__PURE__ */ ve({
  __name: "color-picker",
  emits: ["updateColor"],
  setup(t, { emit: e }) {
    const n = e, r = U(), i = Ct({
      hex: "FFFFFF",
      r: 255,
      g: 255,
      b: 255
    }), o = Ct({
      x: -8,
      y: -8
    }), s = Ct({
      x: -4,
      y: 0
    }), a = Ct({
      x: -4,
      y: 0
    }), l = ({ h: d, s: u, v: f, type: p }) => {
      var M;
      const { containerRef: h, slideHueRef: m, slideOpaRef: g } = ((M = r.value) == null ? void 0 : M.getAllContainer()) || {}, C = iv({ container: h, s: u, v: f });
      o.x = C.x - 8, o.y = C.y - 8, s.x = ov({ container: m, h: d }) - 4, r.value.handleColor({
        type: "set",
        value: new Oe({
          h: d,
          s: u,
          v: f
        })
      });
      const _ = r.value.handleHueColor({ type: "get" }).toHsv();
      r.value.handleHueColor({
        type: "set",
        value: new Oe({
          h: d,
          s: _.s,
          v: _.v
        })
      });
      const b = r.value.handleOpacityColor({ type: "get" }), x = b.toHsv();
      r.value.handleOpacityColor({
        type: "set",
        value: new Oe({
          h: d,
          s: u,
          v: f,
          a: x.a
        })
      });
      const y = sv({ container: g, s: u });
      if (a.x = y - 4, p === "hex") {
        const { r: S, g: T, b: D } = Np(i.hex);
        i.r = S, i.g = T, i.b = D;
      }
      p === "rgb" && (i.hex = b.toHex()), n("updateColor", `#${i.hex}`);
    }, c = (d) => {
      i.hex = d;
      const { r: u, g: f, b: p } = Np(i.hex);
      i.r = u, i.g = f, i.b = p;
    };
    return (d, u) => (B(), he("div", pv, [
      k(fv, {
        ref_key: "pickerPanel",
        ref: r,
        panelPoint: o,
        huePoint: s,
        opacityPoint: a,
        onChangeForms: c,
        onUpdateColor: u[0] || (u[0] = (f) => n("updateColor", f))
      }, null, 8, ["panelPoint", "huePoint", "opacityPoint"]),
      k(tv, {
        onEmitInput: l,
        forms: i
      }, null, 8, ["forms"])
    ]));
  }
}), o2 = /* @__PURE__ */ dt(hv, [["__scopeId", "data-v-73c474e9"]]), gv = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_52">
			<rect id="svg" width="100.000000" height="100.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_52)">
		<path id="path" d="M17.04 5.94L6.95 5.94C6.39 5.94 5.94 6.39 5.94 6.95L5.94 17.04C5.94 17.6 6.39 18.05 6.95 18.05L17.04 18.05C17.6 18.05 18.05 17.6 18.05 17.04L18.05 6.95C18.05 6.39 17.6 5.94 17.04 5.94Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M6.95 5.94C6.39 5.94 5.94 6.39 5.94 6.95L5.94 17.04C5.94 17.6 6.39 18.05 6.95 18.05L17.04 18.05C17.6 18.05 18.05 17.6 18.05 17.04L18.05 6.95C18.05 6.39 17.6 5.94 17.04 5.94L6.95 5.94Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000"/>
		<path id="path" d="M9.09 15.15L9.11 15.18C9.02 15.45 8.74 15.58 8.47 15.5C8.21 15.41 8.07 15.13 8.16 14.86L8.18 14.85L9.09 15.15ZM10.19 8.84L10.18 8.81C10.26 8.54 10.54 8.41 10.81 8.49C11.07 8.58 11.21 8.86 11.12 9.13L11.1 9.14L10.19 8.84Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M8.63 15.02L10.65 8.97" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M14.2 12.35L14.18 12.33C14.18 12.05 14.4 11.83 14.68 11.83C14.96 11.83 15.18 12.05 15.18 12.33L15.16 12.35L14.2 12.35ZM15.16 15L15.18 15.02C15.18 15.3 14.96 15.52 14.68 15.52C14.4 15.52 14.18 15.3 14.18 15.02L14.2 15L15.16 15Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.68 12.33L14.68 15.02" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M14.2 10.33L14.18 10.31C14.18 10.03 14.4 9.81 14.68 9.81C14.96 9.81 15.18 10.03 15.18 10.31L15.16 10.33L14.2 10.33ZM15.16 10.63L15.18 10.65C15.18 10.93 14.96 11.15 14.68 11.15C14.4 11.15 14.18 10.93 14.18 10.65L14.2 10.63L15.16 10.63Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.68 10.31L14.68 10.65" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M10.2 9.14L10.18 9.13C10.09 8.86 10.23 8.58 10.49 8.49C10.76 8.41 11.04 8.54 11.12 8.81L11.11 8.84L10.2 9.14ZM13.12 14.85L13.14 14.86C13.23 15.13 13.09 15.41 12.83 15.5C12.56 15.58 12.28 15.45 12.19 15.18L12.21 15.15L13.12 14.85Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M10.65 8.97L12.67 15.02" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M9.33 13.48L9.31 13.5C9.03 13.5 8.81 13.28 8.81 13C8.81 12.72 9.03 12.5 9.31 12.5L9.33 12.52L9.33 13.48ZM11.98 12.52L12 12.5C12.28 12.5 12.5 12.72 12.5 13C12.5 13.28 12.28 13.5 12 13.5L11.98 13.48L11.98 12.52Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M9.31 13L12 13" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, mv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_760">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_760)">
		<path id="矢量 66" d="M4.38 5.47C4.38 5.19 4.63 4.97 4.96 4.97L19.03 4.97C19.36 4.97 19.61 5.19 19.61 5.47C19.61 5.75 19.36 5.97 19.03 5.97L4.96 5.97C4.63 5.97 4.38 5.75 4.38 5.47ZM6.88 9.82C6.88 9.54 7.13 9.32 7.46 9.32L16.53 9.32C16.86 9.32 17.11 9.54 17.11 9.82C17.11 10.1 16.86 10.32 16.53 10.32L7.46 10.32C7.13 10.32 6.88 10.1 6.88 9.82ZM7.48 13.64C7.15 13.64 6.89 13.86 6.89 14.14C6.89 14.42 7.15 14.64 7.48 14.64L16.54 14.64C16.87 14.64 17.13 14.42 17.13 14.14C17.13 13.86 16.87 13.64 16.54 13.64L7.48 13.64ZM4.37 18.52C4.37 18.24 4.63 18.02 4.95 18.02L19.02 18.02C19.35 18.02 19.6 18.24 19.6 18.52C19.6 18.8 19.35 19.02 19.02 19.02L4.95 19.02C4.63 19.02 4.37 18.8 4.37 18.52Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M4.38 5.47C4.38 5.75 4.63 5.97 4.96 5.97L19.03 5.97C19.36 5.97 19.61 5.75 19.61 5.47C19.61 5.19 19.36 4.97 19.03 4.97L4.96 4.97C4.63 4.97 4.38 5.19 4.38 5.47ZM6.88 9.82C6.88 10.1 7.13 10.32 7.46 10.32L16.53 10.32C16.86 10.32 17.11 10.1 17.11 9.82C17.11 9.54 16.86 9.32 16.53 9.32L7.46 9.32C7.13 9.32 6.88 9.54 6.88 9.82ZM6.89 14.14C6.89 14.42 7.15 14.64 7.48 14.64L16.54 14.64C16.87 14.64 17.13 14.42 17.13 14.14C17.13 13.86 16.87 13.64 16.54 13.64L7.48 13.64C7.15 13.64 6.89 13.86 6.89 14.14ZM4.37 18.52C4.37 18.8 4.63 19.02 4.95 19.02L19.02 19.02C19.35 19.02 19.6 18.8 19.6 18.52C19.6 18.24 19.35 18.02 19.02 18.02L4.95 18.02C4.63 18.02 4.37 18.24 4.37 18.52Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, Cv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_759">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_759)">
		<path id="矢量 66" d="M4.38 5.47C4.38 5.19 4.63 4.97 4.96 4.97L19.03 4.97C19.36 4.97 19.61 5.19 19.61 5.47C19.61 5.75 19.36 5.97 19.03 5.97L4.96 5.97C4.63 5.97 4.38 5.75 4.38 5.47ZM4.31 9.82C4.31 9.54 4.57 9.32 4.9 9.32L18.96 9.32C19.29 9.32 19.55 9.54 19.55 9.82C19.55 10.1 19.29 10.32 18.96 10.32L4.9 10.32C4.57 10.32 4.31 10.1 4.31 9.82ZM4.96 13.67C4.63 13.67 4.38 13.89 4.38 14.17C4.38 14.45 4.63 14.67 4.96 14.67L19.03 14.67C19.36 14.67 19.61 14.45 19.61 14.17C19.61 13.89 19.36 13.67 19.03 13.67L4.96 13.67ZM4.38 18.54C4.38 18.26 4.63 18.04 4.96 18.04L19.03 18.04C19.36 18.04 19.61 18.26 19.61 18.54C19.61 18.82 19.36 19.04 19.03 19.04L4.96 19.04C4.63 19.04 4.38 18.82 4.38 18.54Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M4.38 5.47C4.38 5.75 4.63 5.97 4.96 5.97L19.03 5.97C19.36 5.97 19.61 5.75 19.61 5.47C19.61 5.19 19.36 4.97 19.03 4.97L4.96 4.97C4.63 4.97 4.38 5.19 4.38 5.47ZM4.31 9.82C4.31 10.1 4.57 10.32 4.9 10.32L18.96 10.32C19.29 10.32 19.55 10.1 19.55 9.82C19.55 9.54 19.29 9.32 18.96 9.32L4.9 9.32C4.57 9.32 4.31 9.54 4.31 9.82ZM4.38 14.17C4.38 14.45 4.63 14.67 4.96 14.67L19.03 14.67C19.36 14.67 19.61 14.45 19.61 14.17C19.61 13.89 19.36 13.67 19.03 13.67L4.96 13.67C4.63 13.67 4.38 13.89 4.38 14.17ZM4.38 18.54C4.38 18.82 4.63 19.04 4.96 19.04L19.03 19.04C19.36 19.04 19.61 18.82 19.61 18.54C19.61 18.26 19.36 18.04 19.03 18.04L4.96 18.04C4.63 18.04 4.38 18.26 4.38 18.54Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, bv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_756">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_756)">
		<path id="矢量 66" d="M4.38 5.47C4.38 5.19 4.64 4.97 4.96 4.97L19.03 4.97C19.36 4.97 19.61 5.19 19.61 5.47C19.61 5.75 19.36 5.97 19.03 5.97L4.96 5.97C4.64 5.97 4.38 5.75 4.38 5.47ZM4.31 9.82C4.31 9.54 4.56 9.32 4.89 9.32L14.96 9.32C15.28 9.32 15.54 9.54 15.54 9.82C15.54 10.1 15.28 10.32 14.96 10.32L4.89 10.32C4.56 10.32 4.31 10.1 4.31 9.82ZM4.96 13.67C4.64 13.67 4.38 13.89 4.38 14.17C4.38 14.45 4.64 14.67 4.96 14.67L15.03 14.67C15.36 14.67 15.61 14.45 15.61 14.17C15.61 13.89 15.36 13.67 15.03 13.67L4.96 13.67ZM4.53 18.54C4.53 18.26 4.75 18.04 5.03 18.04L19.03 18.04C19.31 18.04 19.53 18.26 19.53 18.54C19.53 18.82 19.31 19.04 19.03 19.04L5.03 19.04C4.75 19.04 4.53 18.82 4.53 18.54Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M4.38 5.47C4.38 5.75 4.64 5.97 4.96 5.97L19.03 5.97C19.36 5.97 19.61 5.75 19.61 5.47C19.61 5.19 19.36 4.97 19.03 4.97L4.96 4.97C4.64 4.97 4.38 5.19 4.38 5.47ZM4.31 9.82C4.31 10.1 4.56 10.32 4.89 10.32L14.96 10.32C15.28 10.32 15.54 10.1 15.54 9.82C15.54 9.54 15.28 9.32 14.96 9.32L4.89 9.32C4.56 9.32 4.31 9.54 4.31 9.82ZM4.38 14.17C4.38 14.45 4.64 14.67 4.96 14.67L15.03 14.67C15.36 14.67 15.61 14.45 15.61 14.17C15.61 13.89 15.36 13.67 15.03 13.67L4.96 13.67C4.64 13.67 4.38 13.89 4.38 14.17ZM4.53 18.54C4.53 18.82 4.75 19.04 5.03 19.04L19.03 19.04C19.31 19.04 19.53 18.82 19.53 18.54C19.53 18.26 19.31 18.04 19.03 18.04L5.03 18.04C4.75 18.04 4.53 18.26 4.53 18.54Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, yv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_757">
			<rect id="svg" width="24.000000" height="24.000000" transform="matrix(-1 0 0 1 24 0)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_757)">
		<path id="矢量 66" d="M19.61 5.47C19.61 5.19 19.36 4.97 19.03 4.97L4.96 4.97C4.63 4.97 4.38 5.19 4.38 5.47C4.38 5.75 4.63 5.97 4.96 5.97L19.03 5.97C19.36 5.97 19.61 5.75 19.61 5.47ZM19.68 9.82C19.68 9.54 19.43 9.32 19.1 9.32L9.03 9.32C8.71 9.32 8.45 9.54 8.45 9.82C8.45 10.1 8.71 10.32 9.03 10.32L19.1 10.32C19.43 10.32 19.68 10.1 19.68 9.82ZM19.03 13.67C19.36 13.67 19.61 13.89 19.61 14.17C19.61 14.45 19.36 14.67 19.03 14.67L8.96 14.67C8.63 14.67 8.38 14.45 8.38 14.17C8.38 13.89 8.63 13.67 8.96 13.67L19.03 13.67ZM19.46 18.54C19.46 18.26 19.24 18.04 18.96 18.04L4.96 18.04C4.68 18.04 4.46 18.26 4.46 18.54C4.46 18.82 4.68 19.04 4.96 19.04L18.96 19.04C19.24 19.04 19.46 18.82 19.46 18.54Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M19.61 5.47C19.61 5.75 19.36 5.97 19.03 5.97L4.96 5.97C4.63 5.97 4.38 5.75 4.38 5.47C4.38 5.19 4.63 4.97 4.96 4.97L19.03 4.97C19.36 4.97 19.61 5.19 19.61 5.47ZM19.68 9.82C19.68 10.1 19.43 10.32 19.1 10.32L9.03 10.32C8.71 10.32 8.45 10.1 8.45 9.82C8.45 9.54 8.71 9.32 9.03 9.32L19.1 9.32C19.43 9.32 19.68 9.54 19.68 9.82ZM19.61 14.17C19.61 14.45 19.36 14.67 19.03 14.67L8.96 14.67C8.63 14.67 8.38 14.45 8.38 14.17C8.38 13.89 8.63 13.67 8.96 13.67L19.03 13.67C19.36 13.67 19.61 13.89 19.61 14.17ZM19.46 18.54C19.46 18.82 19.24 19.04 18.96 19.04L4.96 19.04C4.68 19.04 4.46 18.82 4.46 18.54C4.46 18.26 4.68 18.04 4.96 18.04L18.96 18.04C19.24 18.04 19.46 18.26 19.46 18.54Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, vv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_316">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_316)">
		<path id="矢量 53" d="M18.91 9.17C19.05 9.03 19.28 9.03 19.42 9.17C19.56 9.31 19.56 9.54 19.42 9.68L16.85 12.24C16.51 12.58 16.06 12.77 15.58 12.77C15.37 12.77 15.17 12.73 14.98 12.67L12.6 15.05C12.53 15.11 12.44 15.15 12.34 15.15L5.52 15.15C5.32 15.15 5.16 14.99 5.16 14.79L5.16 13.72C5.16 13.62 5.2 13.53 5.27 13.47L10.53 8.22C10.46 8.04 10.43 7.84 10.43 7.63C10.43 7.15 10.61 6.7 10.95 6.37L13.53 3.8C13.67 3.66 13.89 3.66 14.03 3.8C14.17 3.94 14.17 4.17 14.03 4.31L11.46 6.87C11.26 7.07 11.15 7.34 11.15 7.63C11.15 7.92 11.26 8.19 11.46 8.39L14.81 11.74C15.23 12.16 15.92 12.16 16.34 11.74L18.91 9.17ZM5.88 14.44L12.2 14.44L14.35 12.29C14.34 12.27 14.32 12.26 14.31 12.24L10.95 8.9C10.94 8.88 10.92 8.87 10.91 8.85L5.88 13.87L5.88 14.44ZM4.46 19.73C4.46 19.41 4.72 19.16 5.03 19.16L18.72 19.16C19.04 19.16 19.29 19.41 19.29 19.73C19.29 20.05 19.04 20.3 18.72 20.3L5.03 20.3C4.72 20.3 4.46 20.05 4.46 19.73Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 53" d="M18.91 9.17L16.34 11.74C15.92 12.16 15.23 12.16 14.81 11.74L11.46 8.39C11.26 8.19 11.15 7.92 11.15 7.63C11.15 7.34 11.26 7.07 11.46 6.87L14.03 4.31C14.17 4.17 14.17 3.94 14.03 3.8C13.89 3.66 13.67 3.66 13.53 3.8L10.95 6.37C10.61 6.7 10.43 7.15 10.43 7.63C10.43 7.84 10.46 8.04 10.53 8.22L5.27 13.47C5.2 13.53 5.16 13.62 5.16 13.72L5.16 14.79C5.16 14.99 5.32 15.15 5.52 15.15L12.34 15.15C12.44 15.15 12.53 15.11 12.6 15.05L14.98 12.67C15.17 12.73 15.37 12.77 15.58 12.77C16.06 12.77 16.51 12.58 16.85 12.24L19.42 9.68C19.56 9.54 19.56 9.31 19.42 9.17C19.28 9.03 19.05 9.03 18.91 9.17ZM5.88 14.44L5.88 13.87L10.91 8.85C10.92 8.87 10.94 8.88 10.95 8.9L14.31 12.24C14.32 12.26 14.34 12.27 14.35 12.29L12.2 14.44L5.88 14.44ZM4.46 19.73C4.46 20.05 4.72 20.3 5.03 20.3L18.72 20.3C19.04 20.3 19.29 20.05 19.29 19.73C19.29 19.41 19.04 19.16 18.72 19.16L5.03 19.16C4.72 19.16 4.46 19.41 4.46 19.73Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, wv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_77">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_77)">
		<path id="矢量 76" d="M5.3 17.65L5.3 6.34C5.3 6.04 5.54 5.8 5.85 5.8C6.15 5.8 6.39 6.04 6.39 6.34L6.39 17.65C6.39 17.95 6.15 18.19 5.85 18.19C5.54 18.19 5.3 17.95 5.3 17.65ZM17.64 6.06C17.54 6.04 17.45 6.03 17.35 6.03L9.76 6.03C9.66 6.03 9.57 6.04 9.48 6.06C9.4 6.08 9.32 6.11 9.24 6.14C9.16 6.17 9.09 6.21 9.02 6.26C8.95 6.3 8.88 6.36 8.82 6.42C8.75 6.49 8.7 6.56 8.65 6.63C8.6 6.7 8.56 6.77 8.53 6.85C8.5 6.92 8.47 7 8.46 7.08C8.44 7.18 8.43 7.27 8.43 7.37L8.43 9.96C8.43 10.06 8.44 10.15 8.46 10.24C8.47 10.32 8.5 10.4 8.53 10.48C8.56 10.56 8.6 10.63 8.65 10.7C8.7 10.77 8.75 10.84 8.82 10.9C8.88 10.97 8.95 11.02 9.02 11.07C9.09 11.12 9.16 11.16 9.24 11.19C9.32 11.22 9.4 11.25 9.48 11.26C9.57 11.28 9.66 11.29 9.76 11.29L17.35 11.29C17.45 11.29 17.54 11.28 17.64 11.26C17.72 11.25 17.8 11.22 17.87 11.19C17.95 11.16 18.02 11.12 18.09 11.07C18.16 11.02 18.23 10.97 18.3 10.9C18.36 10.84 18.42 10.77 18.47 10.7C18.51 10.63 18.55 10.56 18.58 10.48C18.61 10.4 18.64 10.32 18.66 10.24C18.68 10.15 18.69 10.06 18.69 9.96L18.69 7.37C18.69 7.27 18.68 7.18 18.66 7.08C18.64 7 18.61 6.92 18.58 6.85C18.55 6.77 18.51 6.7 18.47 6.63C18.42 6.56 18.36 6.49 18.3 6.42C18.23 6.36 18.16 6.3 18.09 6.26C18.02 6.21 17.95 6.17 17.87 6.14C17.8 6.11 17.72 6.08 17.64 6.06ZM9.76 7.12L17.35 7.12C17.38 7.13 17.51 7.17 17.53 7.19C17.54 7.22 17.6 7.33 17.6 7.37L17.6 9.96C17.59 9.99 17.55 10.11 17.53 10.14C17.5 10.15 17.39 10.21 17.35 10.21L9.76 10.21C9.73 10.2 9.61 10.16 9.58 10.14C9.57 10.11 9.51 10 9.51 9.96L9.51 7.37C9.52 7.34 9.56 7.22 9.58 7.19C9.61 7.17 9.73 7.13 9.76 7.12ZM17.35 12.87C17.45 12.87 17.54 12.88 17.64 12.9C17.72 12.91 17.8 12.94 17.87 12.97C17.95 13 18.02 13.04 18.09 13.09C18.16 13.14 18.23 13.19 18.3 13.26C18.36 13.32 18.42 13.39 18.46 13.46C18.51 13.53 18.55 13.6 18.58 13.68C18.61 13.76 18.64 13.84 18.66 13.92C18.68 14.01 18.69 14.1 18.69 14.2L18.69 16.8C18.69 16.89 18.68 16.99 18.66 17.08C18.64 17.16 18.61 17.24 18.58 17.31C18.55 17.39 18.51 17.46 18.46 17.53C18.42 17.61 18.36 17.67 18.3 17.74C18.23 17.8 18.16 17.86 18.09 17.91C18.02 17.95 17.95 17.99 17.87 18.02C17.8 18.05 17.72 18.08 17.64 18.1C17.54 18.12 17.45 18.13 17.35 18.13L9.76 18.13C9.66 18.13 9.57 18.12 9.48 18.1C9.4 18.08 9.32 18.05 9.24 18.02C9.16 17.99 9.09 17.95 9.02 17.91C8.95 17.86 8.88 17.8 8.82 17.74C8.75 17.67 8.7 17.61 8.65 17.53C8.6 17.46 8.56 17.39 8.53 17.31C8.5 17.24 8.47 17.16 8.46 17.08C8.44 16.99 8.43 16.89 8.43 16.8L8.43 14.2C8.43 14.1 8.44 14.01 8.46 13.92C8.47 13.84 8.5 13.76 8.53 13.68C8.56 13.6 8.6 13.53 8.65 13.46C8.7 13.39 8.75 13.32 8.82 13.26C8.88 13.19 8.95 13.14 9.02 13.09C9.09 13.04 9.16 13 9.24 12.97C9.32 12.94 9.4 12.91 9.48 12.9C9.57 12.88 9.66 12.87 9.76 12.87L17.35 12.87ZM17.35 13.95L9.76 13.95C9.73 13.96 9.61 14 9.58 14.02C9.56 14.05 9.52 14.17 9.51 14.2L9.51 16.8C9.51 16.83 9.57 16.94 9.58 16.97C9.61 16.99 9.73 17.03 9.76 17.04L17.35 17.04C17.39 17.04 17.5 16.98 17.53 16.97C17.55 16.95 17.59 16.82 17.6 16.8L17.6 14.2C17.6 14.16 17.54 14.05 17.53 14.02C17.5 14 17.38 13.96 17.35 13.95Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 76" d="M5.3 6.34C5.3 6.04 5.54 5.8 5.85 5.8C6.15 5.8 6.39 6.04 6.39 6.34L6.39 17.65C6.39 17.95 6.15 18.19 5.85 18.19C5.54 18.19 5.3 17.95 5.3 17.65L5.3 6.34ZM17.35 6.03L9.76 6.03C9.66 6.03 9.57 6.04 9.48 6.06C9.4 6.08 9.32 6.11 9.24 6.14C9.16 6.17 9.09 6.21 9.02 6.26C8.95 6.3 8.88 6.36 8.82 6.42C8.75 6.49 8.7 6.56 8.65 6.63C8.6 6.7 8.56 6.77 8.53 6.85C8.5 6.92 8.47 7 8.46 7.08C8.44 7.18 8.43 7.27 8.43 7.37L8.43 9.96C8.43 10.06 8.44 10.15 8.46 10.24C8.47 10.32 8.5 10.4 8.53 10.48C8.56 10.56 8.6 10.63 8.65 10.7C8.7 10.77 8.75 10.84 8.82 10.9C8.88 10.97 8.95 11.02 9.02 11.07C9.09 11.12 9.16 11.16 9.24 11.19C9.32 11.22 9.4 11.25 9.48 11.26C9.57 11.28 9.66 11.29 9.76 11.29L17.35 11.29C17.45 11.29 17.54 11.28 17.64 11.26C17.72 11.25 17.8 11.22 17.87 11.19C17.95 11.16 18.02 11.12 18.09 11.07C18.16 11.02 18.23 10.97 18.3 10.9C18.36 10.84 18.42 10.77 18.47 10.7C18.51 10.63 18.55 10.56 18.58 10.48C18.61 10.4 18.64 10.32 18.66 10.24C18.68 10.15 18.69 10.06 18.69 9.96L18.69 7.37C18.69 7.27 18.68 7.18 18.66 7.08C18.64 7 18.61 6.92 18.58 6.85C18.55 6.77 18.51 6.7 18.47 6.63C18.42 6.56 18.36 6.49 18.3 6.42C18.23 6.36 18.16 6.3 18.09 6.26C18.02 6.21 17.95 6.17 17.87 6.14C17.8 6.11 17.72 6.08 17.64 6.06C17.54 6.04 17.45 6.03 17.35 6.03ZM17.35 7.12C17.38 7.13 17.51 7.17 17.53 7.19C17.54 7.22 17.6 7.33 17.6 7.37L17.6 9.96C17.59 9.99 17.55 10.11 17.53 10.14C17.5 10.15 17.39 10.21 17.35 10.21L9.76 10.21C9.73 10.2 9.61 10.16 9.58 10.14C9.57 10.11 9.51 10 9.51 9.96L9.51 7.37C9.52 7.34 9.56 7.22 9.58 7.19C9.61 7.17 9.73 7.13 9.76 7.12L17.35 7.12ZM17.35 12.87L9.76 12.87C9.66 12.87 9.57 12.88 9.48 12.9C9.4 12.91 9.32 12.94 9.24 12.97C9.16 13 9.09 13.04 9.02 13.09C8.95 13.14 8.88 13.19 8.82 13.26C8.75 13.32 8.7 13.39 8.65 13.46C8.6 13.53 8.56 13.6 8.53 13.68C8.5 13.76 8.47 13.84 8.46 13.92C8.44 14.01 8.43 14.1 8.43 14.2L8.43 16.8C8.43 16.89 8.44 16.99 8.46 17.08C8.47 17.16 8.5 17.24 8.53 17.31C8.56 17.39 8.6 17.46 8.65 17.53C8.7 17.61 8.75 17.67 8.82 17.74C8.88 17.8 8.95 17.86 9.02 17.91C9.09 17.95 9.16 17.99 9.24 18.02C9.32 18.05 9.4 18.08 9.48 18.1C9.57 18.12 9.66 18.13 9.76 18.13L17.35 18.13C17.45 18.13 17.54 18.12 17.64 18.1C17.72 18.08 17.8 18.05 17.87 18.02C17.95 17.99 18.02 17.95 18.09 17.91C18.16 17.86 18.23 17.8 18.3 17.74C18.36 17.67 18.42 17.61 18.46 17.53C18.51 17.46 18.55 17.39 18.58 17.31C18.61 17.24 18.64 17.16 18.66 17.08C18.68 16.99 18.69 16.89 18.69 16.8L18.69 14.2C18.69 14.1 18.68 14.01 18.66 13.92C18.64 13.84 18.61 13.76 18.58 13.68C18.55 13.6 18.51 13.53 18.46 13.46C18.42 13.39 18.36 13.32 18.3 13.26C18.23 13.19 18.16 13.14 18.09 13.09C18.02 13.04 17.95 13 17.87 12.97C17.8 12.94 17.72 12.91 17.64 12.9C17.54 12.88 17.45 12.87 17.35 12.87ZM17.35 13.95C17.38 13.96 17.5 14 17.53 14.02C17.54 14.05 17.6 14.16 17.6 14.2L17.6 16.8C17.59 16.82 17.55 16.95 17.53 16.97C17.5 16.98 17.39 17.04 17.35 17.04L9.76 17.04C9.73 17.03 9.61 16.99 9.58 16.97C9.57 16.94 9.51 16.83 9.51 16.8L9.51 14.2C9.52 14.17 9.56 14.05 9.58 14.02C9.61 14 9.73 13.96 9.76 13.95L17.35 13.95Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
	</g>
</svg>
`, _v = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_320">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_320)">
		<path id="矢量 58" d="M16.31 8.18C16.31 8.52 16.27 8.85 16.2 9.16C16.14 9.43 16.06 9.69 15.95 9.94C15.84 10.2 15.71 10.44 15.56 10.67C15.39 10.92 15.2 11.16 14.99 11.37C14.93 11.43 14.87 11.49 14.81 11.54C14.91 11.57 15 11.61 15.09 11.65Q15.47 11.81 15.81 12.03L15.81 12.03C16.07 12.2 16.3 12.4 16.52 12.62C16.74 12.83 16.93 13.07 17.1 13.32C17.25 13.55 17.38 13.79 17.49 14.05C17.59 14.3 17.68 14.56 17.74 14.83C17.81 15.15 17.84 15.47 17.84 15.81C17.84 16.14 17.81 16.47 17.74 16.79C17.68 17.05 17.59 17.31 17.49 17.56C17.38 17.82 17.25 18.07 17.1 18.3C16.93 18.55 16.74 18.78 16.52 19C16.3 19.22 16.07 19.41 15.81 19.58L15.81 19.58Q15.47 19.8 15.09 19.96C14.84 20.07 14.58 20.16 14.31 20.22C14 20.29 13.67 20.32 13.34 20.32L6.85 20.32C6.66 20.32 6.49 20.25 6.35 20.11C6.22 19.98 6.15 19.81 6.15 19.62L6.15 12L6.15 4.37C6.15 4.18 6.22 4.01 6.35 3.88C6.49 3.74 6.66 3.67 6.85 3.67L11.8 3.67C12.14 3.67 12.46 3.71 12.77 3.77C13.04 3.83 13.3 3.92 13.56 4.03Q13.94 4.19 14.27 4.41C14.53 4.58 14.77 4.77 14.99 4.99C15.2 5.21 15.39 5.44 15.56 5.69C15.71 5.92 15.84 6.17 15.95 6.43C16.06 6.68 16.14 6.94 16.2 7.2C16.27 7.52 16.31 7.85 16.31 8.18ZM7.55 11.3L11.8 11.3C12.04 11.3 12.27 11.27 12.5 11.22C12.67 11.18 12.84 11.12 13.01 11.05C13.18 10.98 13.34 10.9 13.49 10.8C13.67 10.68 13.84 10.54 14 10.38C14.15 10.23 14.28 10.07 14.4 9.89C14.5 9.74 14.59 9.57 14.66 9.39C14.73 9.23 14.79 9.06 14.83 8.89C14.88 8.66 14.91 8.42 14.91 8.18C14.91 7.94 14.88 7.71 14.83 7.48C14.79 7.31 14.73 7.14 14.66 6.97C14.59 6.8 14.5 6.63 14.4 6.47C14.28 6.3 14.15 6.13 14 5.98C13.84 5.82 13.67 5.69 13.49 5.57C13.34 5.47 13.18 5.39 13.01 5.31C12.84 5.24 12.67 5.19 12.5 5.15C12.27 5.1 12.04 5.07 11.8 5.07L7.55 5.07L7.55 11.3ZM7.55 12.7L7.55 18.92L13.34 18.92C13.58 18.92 13.81 18.89 14.03 18.84C14.21 18.8 14.38 18.75 14.55 18.68C14.72 18.6 14.87 18.52 15.03 18.42C15.21 18.3 15.38 18.17 15.53 18.01C15.68 17.86 15.82 17.69 15.93 17.52C16.04 17.36 16.12 17.2 16.2 17.02C16.27 16.85 16.32 16.68 16.36 16.51C16.42 16.28 16.44 16.05 16.44 15.81C16.44 15.57 16.42 15.33 16.36 15.1C16.32 14.93 16.27 14.76 16.2 14.6C16.12 14.42 16.04 14.25 15.93 14.1C15.82 13.92 15.68 13.76 15.53 13.61C15.38 13.45 15.21 13.31 15.03 13.19C14.87 13.09 14.72 13.01 14.55 12.94C14.38 12.87 14.21 12.81 14.03 12.77C13.81 12.72 13.58 12.7 13.34 12.7L7.55 12.7Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Ev = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_91">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_91)">
		<path id="矢量 60" d="M8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6ZM8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17ZM8.16 19.15C8.16 18.87 8.38 18.65 8.66 18.65L20.66 18.65C20.94 18.65 21.16 18.87 21.16 19.15C21.16 19.43 20.94 19.65 20.66 19.65L8.66 19.65C8.38 19.65 8.16 19.43 8.16 19.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 60" d="M8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1ZM8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67ZM8.16 19.15C8.16 19.43 8.38 19.65 8.66 19.65L20.66 19.65C20.94 19.65 21.16 19.43 21.16 19.15C21.16 18.87 20.94 18.65 20.66 18.65L8.66 18.65C8.38 18.65 8.16 18.87 8.16 19.15Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
		<path id="矢量 46" d="M4.19 6.1C4.19 5.55 4.64 5.1 5.19 5.1C5.74 5.1 6.19 5.55 6.19 6.1C6.19 6.66 5.74 7.1 5.19 7.1C4.64 7.1 4.19 6.66 4.19 6.1ZM4.19 12.67C4.19 12.12 4.64 11.67 5.19 11.67C5.74 11.67 6.19 12.12 6.19 12.67C6.19 13.22 5.74 13.67 5.19 13.67C4.64 13.67 4.19 13.22 4.19 12.67ZM5.19 18.15C4.64 18.15 4.19 18.6 4.19 19.15C4.19 19.7 4.64 20.15 5.19 20.15C5.74 20.15 6.19 19.7 6.19 19.15C6.19 18.6 5.74 18.15 5.19 18.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, xv = `<svg width="6" height="6" viewBox="0 0 4.72144 2.89453" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs/>
	<path id="Polygon 1" d="M2.2 2.82L0.04 0.33C-0.07 0.2 0.02 0 0.2 0L4.52 0C4.69 0 4.78 0.2 4.67 0.33L2.51 2.82C2.43 2.91 2.28 2.91 2.2 2.82Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
</svg>
`, kv = `<svg width="8" height="8" viewBox="0 0 3 5.19604" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs/>
	<path id="Polygon 1" d="M3 2.59L0 5.19L0 0L3 2.59Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
</svg>
`, Sv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip216_53">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip216_53)">
		<path id="矢量 57" d="M15.16 3.67C14.96 3.65 14.79 3.69 14.64 3.81L6.93 9.61L6.93 9.61L2.31 13.09C2.16 13.21 2.07 13.36 2.04 13.55C2.02 13.75 2.06 13.92 2.18 14.07L5.02 17.85L6.17 19.38C6.24 19.46 6.32 19.53 6.42 19.58C6.52 19.63 6.62 19.65 6.73 19.65L11.4 19.65C11.45 19.65 11.49 19.65 11.53 19.64L20.65 19.62C20.99 19.62 21.25 19.36 21.25 19.02C21.25 18.69 20.99 18.42 20.65 18.42L13.19 18.42L13.5 18.17L14.99 17.14L21.17 12.48C21.32 12.36 21.42 12.21 21.44 12.02C21.47 11.82 21.42 11.65 21.31 11.5L15.62 3.94C15.5 3.79 15.35 3.7 15.16 3.67ZM14.92 5.35L8.19 10.42L13.24 16.65L14.18 15.99L19.77 11.78L14.92 5.35ZM3.72 13.79L7.07 11.26L12.12 17.49L11.16 18.25L7.08 18.25L6.14 17.01L3.72 13.79Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Mv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_9">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_9)">
		<path id="path" d="M12 5.65C11.89 5.65 11.79 5.66 11.68 5.66C11.58 5.67 11.48 5.67 11.37 5.68C11.27 5.69 11.17 5.71 11.07 5.72C10.96 5.74 10.86 5.76 10.76 5.78C10.66 5.8 10.56 5.82 10.46 5.84C10.35 5.87 10.25 5.9 10.16 5.93C10.06 5.96 9.96 5.99 9.86 6.02C9.76 6.06 9.66 6.1 9.57 6.14C9.47 6.18 9.38 6.22 9.28 6.26C9.19 6.31 9.1 6.35 9.01 6.4C8.91 6.45 8.82 6.5 8.74 6.56C8.65 6.61 8.56 6.67 8.47 6.72C8.39 6.78 8.3 6.84 8.22 6.9C8.13 6.96 8.05 7.03 7.97 7.09C7.89 7.16 7.81 7.23 7.74 7.3C7.66 7.37 7.58 7.44 7.51 7.51C7.44 7.59 7.37 7.66 7.3 7.74C7.23 7.81 7.16 7.89 7.09 7.97C7.03 8.05 6.96 8.13 6.9 8.22C6.84 8.3 6.78 8.39 6.72 8.47C6.66 8.56 6.61 8.65 6.56 8.74C6.5 8.82 6.45 8.91 6.4 9.01C6.35 9.1 6.31 9.19 6.26 9.28C6.22 9.38 6.18 9.47 6.14 9.57C6.1 9.67 6.06 9.76 6.02 9.86C5.99 9.96 5.96 10.06 5.93 10.16C5.9 10.25 5.87 10.35 5.84 10.46C5.82 10.56 5.8 10.66 5.78 10.76C5.76 10.86 5.74 10.96 5.72 11.07C5.71 11.17 5.69 11.27 5.68 11.37C5.67 11.48 5.67 11.58 5.66 11.69C5.66 11.79 5.65 11.89 5.65 12C5.65 12.1 5.66 12.2 5.66 12.31C5.67 12.41 5.67 12.51 5.68 12.62C5.69 12.72 5.71 12.82 5.72 12.93C5.74 13.03 5.76 13.13 5.78 13.23C5.8 13.34 5.82 13.44 5.84 13.54C5.87 13.64 5.9 13.74 5.93 13.84C5.96 13.94 5.99 14.04 6.02 14.13C6.06 14.23 6.1 14.33 6.14 14.42C6.18 14.52 6.22 14.61 6.26 14.71C6.31 14.8 6.35 14.89 6.4 14.99C6.45 15.08 6.5 15.17 6.56 15.26C6.61 15.35 6.66 15.43 6.72 15.52C6.78 15.61 6.84 15.69 6.9 15.77C6.96 15.86 7.03 15.94 7.09 16.02C7.16 16.1 7.23 16.18 7.3 16.26C7.37 16.33 7.44 16.41 7.51 16.48C7.58 16.55 7.66 16.63 7.74 16.7C7.81 16.77 7.89 16.83 7.97 16.9C8.05 16.96 8.13 17.03 8.22 17.09C8.3 17.15 8.39 17.21 8.47 17.27C8.56 17.33 8.65 17.38 8.74 17.44C8.82 17.49 8.91 17.54 9.01 17.59C9.1 17.64 9.19 17.69 9.28 17.73C9.38 17.77 9.47 17.82 9.57 17.86C9.66 17.9 9.76 17.93 9.86 17.97C9.96 18 10.06 18.04 10.16 18.07C10.25 18.1 10.35 18.12 10.46 18.15C10.56 18.17 10.66 18.2 10.76 18.22C10.86 18.24 10.96 18.26 11.07 18.27C11.17 18.29 11.27 18.3 11.37 18.31C11.48 18.32 11.58 18.33 11.68 18.33C11.79 18.34 11.89 18.34 12 18.34C12.1 18.34 12.2 18.34 12.31 18.33C12.41 18.33 12.51 18.32 12.62 18.31C12.72 18.3 12.82 18.29 12.93 18.27C13.03 18.25 13.13 18.24 13.23 18.22C13.33 18.2 13.44 18.17 13.54 18.15C13.64 18.12 13.74 18.1 13.84 18.07C13.94 18.04 14.03 18 14.13 17.97C14.23 17.93 14.33 17.9 14.42 17.86C14.52 17.82 14.61 17.77 14.71 17.73C14.8 17.68 14.89 17.64 14.99 17.59C15.08 17.54 15.17 17.49 15.26 17.44C15.34 17.38 15.43 17.33 15.52 17.27C15.61 17.21 15.69 17.15 15.77 17.09C15.86 17.03 15.94 16.96 16.02 16.9C16.1 16.83 16.18 16.76 16.25 16.7C16.33 16.63 16.41 16.55 16.48 16.48C16.55 16.41 16.62 16.33 16.69 16.26C16.76 16.18 16.83 16.1 16.9 16.02C16.96 15.94 17.03 15.86 17.09 15.77C17.15 15.69 17.21 15.61 17.27 15.52C17.33 15.43 17.38 15.35 17.43 15.26C17.49 15.17 17.54 15.08 17.59 14.99C17.64 14.89 17.68 14.8 17.73 14.71C17.77 14.61 17.81 14.52 17.85 14.42C17.89 14.33 17.93 14.23 17.97 14.13C18 14.03 18.03 13.94 18.06 13.84C18.09 13.74 18.12 13.64 18.15 13.54C18.17 13.44 18.19 13.34 18.21 13.23C18.23 13.13 18.25 13.03 18.27 12.93C18.28 12.82 18.3 12.72 18.31 12.62C18.32 12.51 18.32 12.41 18.33 12.31C18.33 12.2 18.34 12.1 18.34 12C18.34 11.89 18.33 11.79 18.33 11.69C18.32 11.58 18.32 11.48 18.31 11.37C18.3 11.27 18.28 11.17 18.27 11.07C18.25 10.96 18.23 10.86 18.21 10.76C18.19 10.66 18.17 10.56 18.15 10.46C18.12 10.35 18.09 10.26 18.06 10.16C18.03 10.06 18 9.96 17.97 9.86C17.93 9.76 17.89 9.67 17.85 9.57C17.81 9.47 17.77 9.38 17.73 9.29C17.68 9.19 17.64 9.1 17.59 9.01C17.54 8.92 17.49 8.83 17.43 8.74C17.38 8.65 17.33 8.56 17.27 8.47C17.21 8.39 17.15 8.3 17.09 8.22C17.03 8.14 16.96 8.05 16.9 7.97C16.83 7.89 16.76 7.81 16.69 7.74C16.62 7.66 16.55 7.59 16.48 7.51C16.41 7.44 16.33 7.37 16.25 7.3C16.18 7.23 16.1 7.16 16.02 7.09C15.94 7.03 15.86 6.96 15.77 6.9C15.69 6.84 15.61 6.78 15.52 6.72C15.43 6.67 15.34 6.61 15.26 6.56C15.17 6.5 15.08 6.45 14.99 6.4C14.89 6.35 14.8 6.31 14.71 6.26C14.61 6.22 14.52 6.18 14.42 6.14C14.33 6.1 14.23 6.06 14.13 6.03C14.03 5.99 13.94 5.96 13.84 5.93C13.74 5.9 13.64 5.87 13.54 5.84C13.44 5.82 13.33 5.8 13.23 5.78C13.13 5.76 13.03 5.74 12.93 5.72C12.82 5.71 12.72 5.69 12.62 5.68C12.51 5.67 12.41 5.67 12.31 5.66C12.2 5.66 12.1 5.65 12 5.65ZM12 6.57C12.08 6.57 12.17 6.58 12.26 6.58C12.35 6.58 12.44 6.59 12.53 6.6C12.62 6.61 12.7 6.62 12.79 6.63C12.88 6.64 12.97 6.66 13.05 6.68C13.14 6.69 13.23 6.71 13.31 6.74C13.4 6.76 13.49 6.78 13.57 6.81C13.66 6.83 13.74 6.86 13.82 6.89C13.91 6.92 13.99 6.95 14.07 6.99C14.15 7.02 14.23 7.06 14.31 7.09C14.4 7.13 14.47 7.17 14.55 7.21C14.63 7.26 14.71 7.3 14.78 7.34C14.86 7.39 14.94 7.44 15.01 7.49C15.08 7.54 15.16 7.59 15.23 7.64C15.3 7.69 15.37 7.75 15.44 7.8C15.51 7.86 15.57 7.92 15.64 7.98C15.7 8.04 15.77 8.1 15.83 8.16C15.89 8.22 15.95 8.29 16.01 8.35C16.07 8.42 16.13 8.49 16.19 8.56C16.24 8.62 16.3 8.69 16.35 8.77C16.4 8.84 16.46 8.91 16.51 8.98C16.55 9.06 16.6 9.13 16.65 9.21C16.69 9.28 16.74 9.36 16.78 9.44C16.82 9.52 16.86 9.6 16.9 9.68C16.94 9.76 16.97 9.84 17.01 9.92C17.04 10 17.07 10.09 17.1 10.17C17.13 10.25 17.16 10.34 17.19 10.42C17.21 10.51 17.24 10.59 17.26 10.68C17.28 10.76 17.3 10.85 17.32 10.94C17.33 11.03 17.35 11.11 17.36 11.2C17.37 11.29 17.38 11.38 17.39 11.46C17.4 11.55 17.41 11.64 17.41 11.73C17.42 11.82 17.42 11.91 17.42 12C17.42 12.09 17.42 12.17 17.41 12.26C17.41 12.35 17.4 12.44 17.39 12.53C17.38 12.62 17.37 12.7 17.36 12.79C17.35 12.88 17.33 12.97 17.32 13.05C17.3 13.14 17.28 13.23 17.26 13.31C17.24 13.4 17.21 13.49 17.19 13.57C17.16 13.66 17.13 13.74 17.1 13.82C17.07 13.91 17.04 13.99 17.01 14.07C16.97 14.15 16.94 14.23 16.9 14.32C16.86 14.4 16.82 14.47 16.78 14.55C16.74 14.63 16.69 14.71 16.65 14.78C16.6 14.86 16.55 14.94 16.51 15.01C16.46 15.08 16.4 15.16 16.35 15.23C16.3 15.3 16.24 15.37 16.19 15.44C16.13 15.51 16.07 15.57 16.01 15.64C15.95 15.7 15.89 15.77 15.83 15.83C15.77 15.89 15.7 15.96 15.64 16.01C15.57 16.07 15.51 16.13 15.44 16.19C15.37 16.25 15.3 16.3 15.23 16.35C15.16 16.41 15.08 16.46 15.01 16.51C14.94 16.56 14.86 16.6 14.78 16.65C14.71 16.69 14.63 16.74 14.55 16.78C14.47 16.82 14.4 16.86 14.31 16.9C14.23 16.94 14.15 16.97 14.07 17.01C13.99 17.04 13.91 17.07 13.82 17.1C13.74 17.13 13.66 17.16 13.57 17.19C13.49 17.21 13.4 17.24 13.31 17.26C13.23 17.28 13.14 17.3 13.05 17.32C12.97 17.33 12.88 17.35 12.79 17.36C12.7 17.37 12.62 17.38 12.53 17.39C12.44 17.4 12.35 17.41 12.26 17.41C12.17 17.42 12.08 17.42 12 17.42C11.91 17.42 11.82 17.42 11.73 17.41C11.64 17.41 11.55 17.4 11.46 17.39C11.38 17.38 11.29 17.37 11.2 17.36C11.11 17.35 11.03 17.33 10.94 17.32C10.85 17.3 10.76 17.28 10.68 17.26C10.59 17.24 10.51 17.21 10.42 17.19C10.34 17.16 10.25 17.13 10.17 17.1C10.09 17.07 10 17.04 9.92 17.01C9.84 16.97 9.76 16.94 9.68 16.9C9.6 16.86 9.52 16.82 9.44 16.78C9.36 16.74 9.28 16.69 9.21 16.65C9.13 16.6 9.06 16.56 8.98 16.51C8.91 16.46 8.84 16.41 8.77 16.35C8.69 16.3 8.62 16.25 8.56 16.19C8.49 16.13 8.42 16.07 8.35 16.01C8.29 15.96 8.22 15.89 8.16 15.83C8.1 15.77 8.04 15.7 7.98 15.64C7.92 15.57 7.86 15.51 7.8 15.44C7.75 15.37 7.69 15.3 7.64 15.23C7.59 15.16 7.54 15.08 7.49 15.01C7.44 14.94 7.39 14.86 7.34 14.78C7.3 14.71 7.26 14.63 7.21 14.55C7.17 14.47 7.13 14.4 7.09 14.32C7.06 14.24 7.02 14.15 6.99 14.07C6.95 13.99 6.92 13.91 6.89 13.82C6.86 13.74 6.83 13.66 6.81 13.57C6.78 13.49 6.76 13.4 6.74 13.31C6.71 13.23 6.69 13.14 6.68 13.05C6.66 12.97 6.64 12.88 6.63 12.79C6.62 12.7 6.61 12.62 6.6 12.53C6.59 12.44 6.58 12.35 6.58 12.26C6.58 12.17 6.57 12.09 6.57 12C6.57 11.91 6.58 11.82 6.58 11.73C6.58 11.64 6.59 11.55 6.6 11.46C6.61 11.38 6.62 11.29 6.63 11.2C6.64 11.11 6.66 11.03 6.68 10.94C6.69 10.85 6.71 10.76 6.74 10.68C6.76 10.59 6.78 10.51 6.81 10.42C6.83 10.34 6.86 10.25 6.89 10.17C6.92 10.09 6.95 10 6.99 9.92C7.02 9.84 7.06 9.76 7.09 9.68C7.13 9.6 7.17 9.52 7.21 9.44C7.26 9.36 7.3 9.28 7.34 9.21C7.39 9.13 7.44 9.06 7.49 8.98C7.54 8.91 7.59 8.84 7.64 8.77C7.69 8.69 7.75 8.62 7.8 8.56C7.86 8.49 7.92 8.42 7.98 8.35C8.04 8.29 8.1 8.22 8.16 8.16C8.22 8.1 8.29 8.04 8.35 7.98C8.42 7.92 8.49 7.86 8.56 7.8C8.62 7.75 8.69 7.69 8.77 7.64C8.84 7.59 8.91 7.54 8.98 7.49C9.06 7.44 9.13 7.39 9.21 7.34C9.28 7.3 9.36 7.26 9.44 7.21C9.52 7.17 9.6 7.13 9.68 7.09C9.76 7.06 9.84 7.02 9.92 6.99C10 6.95 10.09 6.92 10.17 6.89C10.25 6.86 10.34 6.83 10.42 6.81C10.51 6.78 10.59 6.76 10.68 6.74C10.76 6.71 10.85 6.69 10.94 6.68C11.03 6.66 11.11 6.64 11.2 6.63C11.29 6.62 11.38 6.61 11.46 6.6C11.55 6.59 11.64 6.58 11.73 6.58C11.82 6.58 11.91 6.57 12 6.57Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
		<path id="path" d="M11.68 5.66C11.58 5.67 11.48 5.67 11.37 5.68C11.27 5.69 11.17 5.71 11.07 5.72C10.96 5.74 10.86 5.76 10.76 5.78C10.66 5.8 10.56 5.82 10.46 5.84C10.35 5.87 10.25 5.9 10.16 5.93C10.06 5.96 9.96 5.99 9.86 6.02C9.76 6.06 9.66 6.1 9.57 6.14C9.47 6.18 9.38 6.22 9.28 6.26C9.19 6.31 9.1 6.35 9.01 6.4C8.91 6.45 8.82 6.5 8.74 6.56C8.65 6.61 8.56 6.67 8.47 6.72C8.39 6.78 8.3 6.84 8.22 6.9C8.13 6.96 8.05 7.03 7.97 7.09C7.89 7.16 7.81 7.23 7.74 7.3C7.66 7.37 7.58 7.44 7.51 7.51C7.44 7.59 7.37 7.66 7.3 7.74C7.23 7.81 7.16 7.89 7.09 7.97C7.03 8.05 6.96 8.13 6.9 8.22C6.84 8.3 6.78 8.39 6.72 8.47C6.66 8.56 6.61 8.65 6.56 8.74C6.5 8.82 6.45 8.91 6.4 9.01C6.35 9.1 6.31 9.19 6.26 9.28C6.22 9.38 6.18 9.47 6.14 9.57C6.1 9.67 6.06 9.76 6.02 9.86C5.99 9.96 5.96 10.06 5.93 10.16C5.9 10.25 5.87 10.35 5.84 10.46C5.82 10.56 5.8 10.66 5.78 10.76C5.76 10.86 5.74 10.96 5.72 11.07C5.71 11.17 5.69 11.27 5.68 11.37C5.67 11.48 5.67 11.58 5.66 11.69C5.66 11.79 5.65 11.89 5.65 12C5.65 12.1 5.66 12.2 5.66 12.31C5.67 12.41 5.67 12.51 5.68 12.62C5.69 12.72 5.71 12.82 5.72 12.93C5.74 13.03 5.76 13.13 5.78 13.23C5.8 13.34 5.82 13.44 5.84 13.54C5.87 13.64 5.9 13.74 5.93 13.84C5.96 13.94 5.99 14.04 6.02 14.13C6.06 14.23 6.1 14.33 6.14 14.42C6.18 14.52 6.22 14.61 6.26 14.71C6.31 14.8 6.35 14.89 6.4 14.99C6.45 15.08 6.5 15.17 6.56 15.26C6.61 15.35 6.66 15.43 6.72 15.52C6.78 15.61 6.84 15.69 6.9 15.77C6.96 15.86 7.03 15.94 7.09 16.02C7.16 16.1 7.23 16.18 7.3 16.26C7.37 16.33 7.44 16.41 7.51 16.48C7.58 16.55 7.66 16.63 7.74 16.7C7.81 16.77 7.89 16.83 7.97 16.9C8.05 16.96 8.13 17.03 8.22 17.09C8.3 17.15 8.39 17.21 8.47 17.27C8.56 17.33 8.65 17.38 8.74 17.44C8.82 17.49 8.91 17.54 9.01 17.59C9.1 17.64 9.19 17.69 9.28 17.73C9.38 17.77 9.47 17.82 9.57 17.86C9.66 17.9 9.76 17.93 9.86 17.97C9.96 18 10.06 18.04 10.16 18.07C10.25 18.1 10.35 18.12 10.46 18.15C10.56 18.17 10.66 18.2 10.76 18.22C10.86 18.24 10.96 18.26 11.07 18.27C11.17 18.29 11.27 18.3 11.37 18.31C11.48 18.32 11.58 18.33 11.68 18.33C11.79 18.34 11.89 18.34 12 18.34C12.1 18.34 12.2 18.34 12.31 18.33C12.41 18.33 12.51 18.32 12.62 18.31C12.72 18.3 12.82 18.29 12.93 18.27C13.03 18.25 13.13 18.24 13.23 18.22C13.33 18.2 13.44 18.17 13.54 18.15C13.64 18.12 13.74 18.1 13.84 18.07C13.94 18.04 14.03 18 14.13 17.97C14.23 17.93 14.33 17.9 14.42 17.86C14.52 17.82 14.61 17.77 14.71 17.73C14.8 17.68 14.89 17.64 14.99 17.59C15.08 17.54 15.17 17.49 15.26 17.44C15.34 17.38 15.43 17.33 15.52 17.27C15.61 17.21 15.69 17.15 15.77 17.09C15.86 17.03 15.94 16.96 16.02 16.9C16.1 16.83 16.18 16.76 16.25 16.7C16.33 16.63 16.41 16.55 16.48 16.48C16.55 16.41 16.62 16.33 16.69 16.26C16.76 16.18 16.83 16.1 16.9 16.02C16.96 15.94 17.03 15.86 17.09 15.77C17.15 15.69 17.21 15.61 17.27 15.52C17.33 15.43 17.38 15.35 17.43 15.26C17.49 15.17 17.54 15.08 17.59 14.99C17.64 14.89 17.68 14.8 17.73 14.71C17.77 14.61 17.81 14.52 17.85 14.42C17.89 14.33 17.93 14.23 17.97 14.13C18 14.03 18.03 13.94 18.06 13.84C18.09 13.74 18.12 13.64 18.15 13.54C18.17 13.44 18.19 13.34 18.21 13.23C18.23 13.13 18.25 13.03 18.27 12.93C18.28 12.82 18.3 12.72 18.31 12.62C18.32 12.51 18.32 12.41 18.33 12.31C18.33 12.2 18.34 12.1 18.34 12C18.34 11.89 18.33 11.79 18.33 11.69C18.32 11.58 18.32 11.48 18.31 11.37C18.3 11.27 18.28 11.17 18.27 11.07C18.25 10.96 18.23 10.86 18.21 10.76C18.19 10.66 18.17 10.56 18.15 10.46C18.12 10.35 18.09 10.26 18.06 10.16C18.03 10.06 18 9.96 17.97 9.86C17.93 9.76 17.89 9.67 17.85 9.57C17.81 9.47 17.77 9.38 17.73 9.29C17.68 9.19 17.64 9.1 17.59 9.01C17.54 8.92 17.49 8.83 17.43 8.74C17.38 8.65 17.33 8.56 17.27 8.47C17.21 8.39 17.15 8.3 17.09 8.22C17.03 8.14 16.96 8.05 16.9 7.97C16.83 7.89 16.76 7.81 16.69 7.74C16.62 7.66 16.55 7.59 16.48 7.51C16.41 7.44 16.33 7.37 16.25 7.3C16.18 7.23 16.1 7.16 16.02 7.09C15.94 7.03 15.86 6.96 15.77 6.9C15.69 6.84 15.61 6.78 15.52 6.72C15.43 6.67 15.34 6.61 15.26 6.56C15.17 6.5 15.08 6.45 14.99 6.4C14.89 6.35 14.8 6.31 14.71 6.26C14.61 6.22 14.52 6.18 14.42 6.14C14.33 6.1 14.23 6.06 14.13 6.03C14.03 5.99 13.94 5.96 13.84 5.93C13.74 5.9 13.64 5.87 13.54 5.84C13.44 5.82 13.33 5.8 13.23 5.78C13.13 5.76 13.03 5.74 12.93 5.72C12.82 5.71 12.72 5.69 12.62 5.68C12.51 5.67 12.41 5.67 12.31 5.66C12.2 5.66 12.1 5.65 12 5.65C11.89 5.65 11.79 5.66 11.68 5.66ZM12.26 6.58C12.35 6.58 12.44 6.59 12.53 6.6C12.62 6.61 12.7 6.62 12.79 6.63C12.88 6.64 12.97 6.66 13.05 6.68C13.14 6.69 13.23 6.71 13.31 6.74C13.4 6.76 13.49 6.78 13.57 6.81C13.66 6.83 13.74 6.86 13.82 6.89C13.91 6.92 13.99 6.95 14.07 6.99C14.15 7.02 14.23 7.06 14.31 7.09C14.4 7.13 14.47 7.17 14.55 7.21C14.63 7.26 14.71 7.3 14.78 7.34C14.86 7.39 14.94 7.44 15.01 7.49C15.08 7.54 15.16 7.59 15.23 7.64C15.3 7.69 15.37 7.75 15.44 7.8C15.51 7.86 15.57 7.92 15.64 7.98C15.7 8.04 15.77 8.1 15.83 8.16C15.89 8.22 15.95 8.29 16.01 8.35C16.07 8.42 16.13 8.49 16.19 8.56C16.24 8.62 16.3 8.69 16.35 8.77C16.4 8.84 16.46 8.91 16.51 8.98C16.55 9.06 16.6 9.13 16.65 9.21C16.69 9.28 16.74 9.36 16.78 9.44C16.82 9.52 16.86 9.6 16.9 9.68C16.94 9.76 16.97 9.84 17.01 9.92C17.04 10 17.07 10.09 17.1 10.17C17.13 10.25 17.16 10.34 17.19 10.42C17.21 10.51 17.24 10.59 17.26 10.68C17.28 10.76 17.3 10.85 17.32 10.94C17.33 11.03 17.35 11.11 17.36 11.2C17.37 11.29 17.38 11.38 17.39 11.46C17.4 11.55 17.41 11.64 17.41 11.73C17.42 11.82 17.42 11.91 17.42 12C17.42 12.09 17.42 12.17 17.41 12.26C17.41 12.35 17.4 12.44 17.39 12.53C17.38 12.62 17.37 12.7 17.36 12.79C17.35 12.88 17.33 12.97 17.32 13.05C17.3 13.14 17.28 13.23 17.26 13.31C17.24 13.4 17.21 13.49 17.19 13.57C17.16 13.66 17.13 13.74 17.1 13.82C17.07 13.91 17.04 13.99 17.01 14.07C16.97 14.15 16.94 14.23 16.9 14.32C16.86 14.4 16.82 14.47 16.78 14.55C16.74 14.63 16.69 14.71 16.65 14.78C16.6 14.86 16.55 14.94 16.51 15.01C16.46 15.08 16.4 15.16 16.35 15.23C16.3 15.3 16.24 15.37 16.19 15.44C16.13 15.51 16.07 15.57 16.01 15.64C15.95 15.7 15.89 15.77 15.83 15.83C15.77 15.89 15.7 15.96 15.64 16.01C15.57 16.07 15.51 16.13 15.44 16.19C15.37 16.25 15.3 16.3 15.23 16.35C15.16 16.41 15.08 16.46 15.01 16.51C14.94 16.56 14.86 16.6 14.78 16.65C14.71 16.69 14.63 16.74 14.55 16.78C14.47 16.82 14.4 16.86 14.31 16.9C14.23 16.94 14.15 16.97 14.07 17.01C13.99 17.04 13.91 17.07 13.82 17.1C13.74 17.13 13.66 17.16 13.57 17.19C13.49 17.21 13.4 17.24 13.31 17.26C13.23 17.28 13.14 17.3 13.05 17.32C12.97 17.33 12.88 17.35 12.79 17.36C12.7 17.37 12.62 17.38 12.53 17.39C12.44 17.4 12.35 17.41 12.26 17.41C12.17 17.42 12.08 17.42 12 17.42C11.91 17.42 11.82 17.42 11.73 17.41C11.64 17.41 11.55 17.4 11.46 17.39C11.38 17.38 11.29 17.37 11.2 17.36C11.11 17.35 11.03 17.33 10.94 17.32C10.85 17.3 10.76 17.28 10.68 17.26C10.59 17.24 10.51 17.21 10.42 17.19C10.34 17.16 10.25 17.13 10.17 17.1C10.09 17.07 10 17.04 9.92 17.01C9.84 16.97 9.76 16.94 9.68 16.9C9.6 16.86 9.52 16.82 9.44 16.78C9.36 16.74 9.28 16.69 9.21 16.65C9.13 16.6 9.06 16.56 8.98 16.51C8.91 16.46 8.84 16.41 8.77 16.35C8.69 16.3 8.62 16.25 8.56 16.19C8.49 16.13 8.42 16.07 8.35 16.01C8.29 15.96 8.22 15.89 8.16 15.83C8.1 15.77 8.04 15.7 7.98 15.64C7.92 15.57 7.86 15.51 7.8 15.44C7.75 15.37 7.69 15.3 7.64 15.23C7.59 15.16 7.54 15.08 7.49 15.01C7.44 14.94 7.39 14.86 7.34 14.78C7.3 14.71 7.26 14.63 7.21 14.55C7.17 14.47 7.13 14.4 7.09 14.32C7.06 14.24 7.02 14.15 6.99 14.07C6.95 13.99 6.92 13.91 6.89 13.82C6.86 13.74 6.83 13.66 6.81 13.57C6.78 13.49 6.76 13.4 6.74 13.31C6.71 13.23 6.69 13.14 6.68 13.05C6.66 12.97 6.64 12.88 6.63 12.79C6.62 12.7 6.61 12.62 6.6 12.53C6.59 12.44 6.58 12.35 6.58 12.26C6.58 12.17 6.57 12.09 6.57 12C6.57 11.91 6.58 11.82 6.58 11.73C6.58 11.64 6.59 11.55 6.6 11.46C6.61 11.38 6.62 11.29 6.63 11.2C6.64 11.11 6.66 11.03 6.68 10.94C6.69 10.85 6.71 10.76 6.74 10.68C6.76 10.59 6.78 10.51 6.81 10.42C6.83 10.34 6.86 10.25 6.89 10.17C6.92 10.09 6.95 10 6.99 9.92C7.02 9.84 7.06 9.76 7.09 9.68C7.13 9.6 7.17 9.52 7.21 9.44C7.26 9.36 7.3 9.28 7.34 9.21C7.39 9.13 7.44 9.06 7.49 8.98C7.54 8.91 7.59 8.84 7.64 8.77C7.69 8.69 7.75 8.62 7.8 8.56C7.86 8.49 7.92 8.42 7.98 8.35C8.04 8.29 8.1 8.22 8.16 8.16C8.22 8.1 8.29 8.04 8.35 7.98C8.42 7.92 8.49 7.86 8.56 7.8C8.62 7.75 8.69 7.69 8.77 7.64C8.84 7.59 8.91 7.54 8.98 7.49C9.06 7.44 9.13 7.39 9.21 7.34C9.28 7.3 9.36 7.26 9.44 7.21C9.52 7.17 9.6 7.13 9.68 7.09C9.76 7.06 9.84 7.02 9.92 6.99C10 6.95 10.09 6.92 10.17 6.89C10.25 6.86 10.34 6.83 10.42 6.81C10.51 6.78 10.59 6.76 10.68 6.74C10.76 6.71 10.85 6.69 10.94 6.68C11.03 6.66 11.11 6.64 11.2 6.63C11.29 6.62 11.38 6.61 11.46 6.6C11.55 6.59 11.64 6.58 11.73 6.58C11.82 6.58 11.91 6.57 12 6.57C12.08 6.57 12.17 6.58 12.26 6.58Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
		<path id="path" d="M12.22 11.74L12.22 8.52C12.22 8.49 12.22 8.46 12.21 8.43C12.21 8.4 12.2 8.37 12.19 8.34C12.17 8.32 12.16 8.29 12.14 8.26C12.13 8.24 12.11 8.22 12.09 8.19C12.06 8.17 12.04 8.15 12.02 8.14C11.99 8.12 11.96 8.11 11.94 8.09C11.91 8.08 11.88 8.07 11.85 8.07C11.82 8.06 11.79 8.06 11.76 8.06C11.73 8.06 11.7 8.06 11.67 8.07C11.64 8.07 11.61 8.08 11.58 8.09C11.56 8.11 11.53 8.12 11.51 8.14C11.48 8.15 11.46 8.17 11.44 8.19C11.41 8.22 11.4 8.24 11.38 8.26C11.36 8.29 11.35 8.32 11.34 8.34C11.32 8.37 11.32 8.4 11.31 8.43C11.3 8.46 11.3 8.49 11.3 8.52L11.3 11.83C11.3 12.29 11.67 12.66 12.13 12.66L15.44 12.66C15.47 12.66 15.5 12.65 15.53 12.65C15.56 12.64 15.59 12.63 15.61 12.62C15.64 12.61 15.67 12.59 15.69 12.58C15.72 12.56 15.74 12.54 15.76 12.52C15.78 12.5 15.8 12.48 15.82 12.45C15.84 12.43 15.85 12.4 15.86 12.37C15.87 12.34 15.88 12.32 15.89 12.29C15.89 12.26 15.9 12.23 15.9 12.2C15.9 12.17 15.89 12.14 15.89 12.11C15.88 12.08 15.87 12.05 15.86 12.02C15.85 11.99 15.84 11.97 15.82 11.94C15.8 11.92 15.78 11.89 15.76 11.87C15.74 11.85 15.72 11.83 15.69 11.81C15.67 11.8 15.64 11.78 15.61 11.77C15.59 11.76 15.56 11.75 15.53 11.75C15.5 11.74 15.47 11.74 15.44 11.74L12.22 11.74Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
		<path id="path" d="M12.22 8.52C12.22 8.49 12.22 8.46 12.21 8.43C12.21 8.4 12.2 8.37 12.19 8.34C12.17 8.32 12.16 8.29 12.14 8.26C12.13 8.24 12.11 8.22 12.09 8.19C12.06 8.17 12.04 8.15 12.02 8.14C11.99 8.12 11.96 8.11 11.94 8.09C11.91 8.08 11.88 8.07 11.85 8.07C11.82 8.06 11.79 8.06 11.76 8.06C11.73 8.06 11.7 8.06 11.67 8.07C11.64 8.07 11.61 8.08 11.58 8.09C11.56 8.11 11.53 8.12 11.51 8.14C11.48 8.15 11.46 8.17 11.44 8.19C11.41 8.22 11.4 8.24 11.38 8.26C11.36 8.29 11.35 8.32 11.34 8.34C11.32 8.37 11.32 8.4 11.31 8.43C11.3 8.46 11.3 8.49 11.3 8.52L11.3 11.83C11.3 12.29 11.67 12.66 12.13 12.66L15.44 12.66C15.47 12.66 15.5 12.65 15.53 12.65C15.56 12.64 15.59 12.63 15.61 12.62C15.64 12.61 15.67 12.59 15.69 12.58C15.72 12.56 15.74 12.54 15.76 12.52C15.78 12.5 15.8 12.48 15.82 12.45C15.84 12.43 15.85 12.4 15.86 12.37C15.87 12.34 15.88 12.32 15.89 12.29C15.89 12.26 15.9 12.23 15.9 12.2C15.9 12.17 15.89 12.14 15.89 12.11C15.88 12.08 15.87 12.05 15.86 12.02C15.85 11.99 15.84 11.97 15.82 11.94C15.8 11.92 15.78 11.89 15.76 11.87C15.74 11.85 15.72 11.83 15.69 11.81C15.67 11.8 15.64 11.78 15.61 11.77C15.59 11.76 15.56 11.75 15.53 11.75C15.5 11.74 15.47 11.74 15.44 11.74L12.22 11.74L12.22 8.52Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
	</g>
</svg>
`, Ov = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_62">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_62)">
		<path id="矢量 75" d="M11.68 17.57L6.59 17.57C6.48 17.57 6.37 17.56 6.27 17.54C6.18 17.52 6.09 17.49 6 17.45C5.91 17.42 5.83 17.37 5.75 17.32C5.66 17.26 5.59 17.2 5.51 17.13C5.44 17.05 5.37 16.97 5.32 16.89C5.27 16.81 5.22 16.73 5.18 16.64C5.15 16.55 5.12 16.46 5.1 16.37C5.08 16.26 5.06 16.15 5.06 16.04L5.06 7.78C5.06 7.67 5.08 7.56 5.1 7.46C5.12 7.37 5.15 7.28 5.18 7.19C5.22 7.1 5.27 7.02 5.32 6.94C5.37 6.85 5.44 6.77 5.51 6.7C5.59 6.63 5.66 6.56 5.75 6.51C5.83 6.46 5.91 6.41 6 6.37C6.09 6.34 6.18 6.31 6.27 6.29C6.37 6.26 6.48 6.25 6.59 6.25L17.4 6.25C17.51 6.25 17.62 6.26 17.72 6.29C17.81 6.31 17.9 6.34 17.99 6.37C18.08 6.41 18.16 6.46 18.24 6.51C18.33 6.56 18.41 6.63 18.48 6.7C18.55 6.77 18.62 6.85 18.67 6.94C18.72 7.02 18.77 7.1 18.81 7.19C18.84 7.28 18.87 7.37 18.89 7.46C18.91 7.56 18.93 7.67 18.93 7.78L18.93 12.51C18.93 12.83 18.67 13.09 18.35 13.09C18.03 13.09 17.77 12.83 17.77 12.51L17.77 11.22L6.22 11.22L6.22 16.04C6.22 16.1 6.23 16.14 6.24 16.19C6.26 16.23 6.29 16.27 6.33 16.31C6.36 16.35 6.4 16.37 6.45 16.39C6.49 16.41 6.54 16.42 6.59 16.42L11.68 16.42C12 16.42 12.25 16.67 12.25 17C12.25 17.32 12 17.57 11.68 17.57ZM6.22 10.07L17.77 10.07L17.77 7.78C17.77 7.73 17.76 7.68 17.75 7.64C17.73 7.59 17.7 7.55 17.66 7.52C17.63 7.48 17.59 7.45 17.54 7.43C17.5 7.42 17.45 7.41 17.4 7.41L6.59 7.41C6.54 7.41 6.49 7.42 6.45 7.43C6.4 7.45 6.36 7.48 6.33 7.52C6.29 7.55 6.26 7.59 6.24 7.64C6.23 7.68 6.22 7.73 6.22 7.78L6.22 10.07ZM15.47 15.07L14.49 16.04L15.47 17.02C15.63 17.18 15.63 17.45 15.47 17.61C15.3 17.78 15.04 17.78 14.88 17.61L13.6 16.34C13.52 16.26 13.48 16.16 13.48 16.04C13.48 15.93 13.52 15.83 13.6 15.75L14.88 14.48C15.04 14.31 15.3 14.31 15.47 14.48C15.63 14.64 15.63 14.9 15.47 15.07ZM16.78 14.48C16.95 14.31 17.21 14.31 17.38 14.48L18.65 15.75C18.73 15.83 18.77 15.93 18.77 16.04C18.77 16.16 18.73 16.26 18.65 16.34L17.38 17.61C17.21 17.78 16.95 17.78 16.78 17.61C16.62 17.45 16.62 17.18 16.78 17.02L17.76 16.04L16.78 15.07C16.62 14.9 16.62 14.64 16.78 14.48Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 75" d="M11.68 17.57C12 17.57 12.25 17.32 12.25 17C12.25 16.67 12 16.42 11.68 16.42L6.59 16.42C6.54 16.42 6.49 16.41 6.45 16.39C6.4 16.37 6.36 16.35 6.33 16.31C6.29 16.27 6.26 16.23 6.24 16.19C6.23 16.14 6.22 16.1 6.22 16.04L6.22 7.78C6.22 7.73 6.23 7.68 6.24 7.64C6.26 7.59 6.29 7.55 6.33 7.52C6.36 7.48 6.4 7.45 6.45 7.43C6.49 7.42 6.54 7.41 6.59 7.41L17.4 7.41C17.45 7.41 17.5 7.42 17.54 7.43C17.59 7.45 17.63 7.48 17.66 7.52C17.7 7.55 17.73 7.59 17.75 7.64C17.76 7.68 17.77 7.73 17.77 7.78L17.77 12.51C17.77 12.83 18.03 13.09 18.35 13.09C18.67 13.09 18.93 12.83 18.93 12.51L18.93 7.78C18.93 7.67 18.91 7.56 18.89 7.46C18.87 7.37 18.84 7.28 18.81 7.19C18.77 7.1 18.72 7.02 18.67 6.94C18.62 6.85 18.55 6.77 18.48 6.7C18.41 6.63 18.33 6.56 18.24 6.51C18.16 6.46 18.08 6.41 17.99 6.37C17.9 6.34 17.81 6.31 17.72 6.29C17.62 6.26 17.51 6.25 17.4 6.25L6.59 6.25C6.48 6.25 6.37 6.26 6.27 6.29C6.18 6.31 6.09 6.34 6 6.37C5.91 6.41 5.83 6.46 5.75 6.51C5.66 6.56 5.59 6.63 5.51 6.7C5.44 6.77 5.37 6.85 5.32 6.94C5.27 7.02 5.22 7.1 5.18 7.19C5.15 7.28 5.12 7.37 5.1 7.46C5.08 7.56 5.06 7.67 5.06 7.78L5.06 16.04C5.06 16.15 5.08 16.26 5.1 16.37C5.12 16.46 5.15 16.55 5.18 16.64C5.22 16.73 5.27 16.81 5.32 16.89C5.37 16.97 5.44 17.05 5.51 17.13C5.59 17.2 5.66 17.26 5.75 17.32C5.83 17.37 5.91 17.42 6 17.45C6.09 17.49 6.18 17.52 6.27 17.54C6.37 17.56 6.48 17.57 6.59 17.57L11.68 17.57ZM5.06 7.78L5.06 11.22L18.93 11.22L18.93 7.78M17.77 7.78L17.77 10.07L6.22 10.07L6.22 7.78M14.49 16.04L15.47 17.02C15.63 17.18 15.63 17.45 15.47 17.61C15.3 17.78 15.04 17.78 14.88 17.61L13.6 16.34C13.52 16.26 13.48 16.16 13.48 16.04C13.48 15.93 13.52 15.83 13.6 15.75L14.88 14.48C15.04 14.31 15.3 14.31 15.47 14.48C15.63 14.64 15.63 14.9 15.47 15.07L14.49 16.04ZM16.78 14.48C16.62 14.64 16.62 14.9 16.78 15.07L17.76 16.04L16.78 17.02C16.62 17.18 16.62 17.45 16.78 17.61C16.95 17.78 17.21 17.78 17.38 17.61L18.65 16.34C18.73 16.26 18.77 16.16 18.77 16.04C18.77 15.93 18.73 15.83 18.65 15.75L17.38 14.48C17.21 14.31 16.95 14.31 16.78 14.48Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.200000"/>
	</g>
</svg>
`, Tv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_56">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_56)">
		<path id="矢量 74" d="M10.93 19C10.66 18.95 10.48 18.69 10.53 18.42L12.8 5.4C12.85 5.12 13.11 4.94 13.38 4.99C13.66 5.04 13.84 5.3 13.79 5.57L11.51 18.59C11.46 18.87 11.21 19.05 10.93 19ZM9.75 8.76L6.19 12.45L9.74 15.87C9.94 16.06 9.95 16.37 9.75 16.57C9.56 16.77 9.25 16.78 9.04 16.59L5.14 12.82C5.04 12.73 4.99 12.61 4.99 12.47C4.98 12.33 5.03 12.21 5.13 12.11L9.03 8.07C9.23 7.87 9.54 7.86 9.74 8.05C9.94 8.25 9.95 8.56 9.75 8.76ZM14.96 8.07C14.76 7.87 14.45 7.86 14.25 8.05C14.05 8.25 14.04 8.56 14.24 8.76L17.8 12.45L14.25 15.87C14.05 16.06 14.04 16.37 14.24 16.57C14.43 16.77 14.74 16.78 14.95 16.59L18.85 12.82C18.95 12.73 19 12.61 19 12.47C19.01 12.33 18.96 12.21 18.86 12.11L14.96 8.07Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 74" d="M6.19 12.45L9.74 15.87C9.94 16.06 9.95 16.37 9.75 16.57C9.56 16.77 9.25 16.78 9.04 16.59L5.14 12.82C5.04 12.73 4.99 12.61 4.99 12.47C4.98 12.33 5.03 12.21 5.13 12.11L9.03 8.07C9.23 7.87 9.54 7.86 9.74 8.05C9.94 8.25 9.95 8.56 9.75 8.76L6.19 12.45ZM14.25 8.05C14.05 8.25 14.04 8.56 14.24 8.76L17.8 12.45L14.25 15.87C14.05 16.06 14.04 16.37 14.24 16.57C14.43 16.77 14.74 16.78 14.95 16.59L18.85 12.82C18.95 12.73 19 12.61 19 12.47C19.01 12.33 18.96 12.21 18.86 12.11L14.96 8.07C14.76 7.87 14.45 7.86 14.25 8.05ZM10.93 19C11.21 19.05 11.46 18.87 11.51 18.59L13.79 5.57C13.84 5.3 13.66 5.04 13.38 4.99C13.11 4.94 12.85 5.12 12.8 5.4L10.53 18.42C10.48 18.69 10.66 18.95 10.93 19Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
	</g>
</svg>
`, Lv = `<svg width="15.000000" height="16.000000" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs/>
	<path id="path" d="M8.17 6.27C7.81 6.35 7.39 6.31 6.92 6.13C6.45 5.96 6.12 6 5.94 6.26C5.82 6.46 5.83 6.71 5.96 7.02C6.1 7.33 6.14 7.64 6.08 7.93C6.04 8.22 5.84 8.47 5.48 8.68C5.13 8.89 4.8 9 4.5 9C3.87 9 3.29 8.88 2.74 8.64C2.2 8.41 1.72 8.09 1.31 7.68C0.9 7.27 0.58 6.79 0.35 6.25C0.11 5.7 0 5.12 0 4.5C0 3.87 0.11 3.29 0.35 2.74C0.58 2.2 0.9 1.72 1.31 1.31C1.72 0.9 2.2 0.58 2.74 0.35C3.29 0.11 3.87 0 4.5 0C5.12 0 5.7 0.11 6.25 0.35C6.79 0.58 7.27 0.9 7.68 1.31C8.09 1.72 8.41 2.2 8.64 2.74C8.88 3.29 9 3.87 9 4.5C9 5.06 8.92 5.49 8.77 5.77C8.62 6.04 8.42 6.21 8.17 6.27ZM8.35 4.5C8.35 3.96 8.25 3.46 8.05 2.99C8 2.88 7.95 2.77 7.89 2.66C7.83 2.55 7.76 2.44 7.7 2.34C7.63 2.24 7.55 2.14 7.47 2.04C7.39 1.95 7.31 1.86 7.22 1.77C7.13 1.68 7.04 1.6 6.95 1.52C6.85 1.44 6.75 1.36 6.65 1.29C6.55 1.23 6.44 1.16 6.33 1.1C6.22 1.04 6.11 0.99 6 0.94C5.53 0.74 5.03 0.64 4.5 0.64C3.96 0.64 3.46 0.74 2.99 0.94C2.88 0.99 2.77 1.04 2.66 1.1C2.55 1.16 2.44 1.23 2.34 1.29C2.24 1.36 2.14 1.44 2.04 1.52C1.95 1.6 1.86 1.68 1.77 1.77C1.68 1.86 1.6 1.95 1.52 2.04C1.44 2.14 1.36 2.24 1.29 2.34C1.23 2.44 1.16 2.55 1.1 2.66C1.04 2.77 0.99 2.88 0.94 2.99C0.74 3.46 0.64 3.96 0.64 4.5C0.64 5.03 0.74 5.53 0.94 6C0.99 6.11 1.04 6.22 1.1 6.33C1.16 6.44 1.23 6.55 1.29 6.65C1.36 6.75 1.44 6.85 1.52 6.95C1.6 7.04 1.68 7.13 1.77 7.22C1.86 7.31 1.95 7.39 2.04 7.47C2.14 7.55 2.24 7.63 2.34 7.7C2.44 7.76 2.55 7.83 2.66 7.89C2.77 7.95 2.88 8 2.99 8.05C3.46 8.25 3.96 8.35 4.5 8.35C4.7 8.35 4.89 8.29 5.06 8.15C5.24 8.02 5.36 7.87 5.41 7.71C5.49 7.35 5.45 7.05 5.3 6.82C5.14 6.59 5.17 6.25 5.39 5.79C5.56 5.59 5.75 5.48 5.97 5.46C6.19 5.44 6.42 5.45 6.64 5.49C6.88 5.54 7.11 5.58 7.35 5.64C7.58 5.69 7.8 5.68 8 5.62C8.19 5.56 8.3 5.45 8.32 5.29C8.34 5.13 8.35 4.86 8.35 4.5ZM7.07 4.5C6.89 4.5 6.74 4.43 6.61 4.3C6.49 4.18 6.42 4.03 6.42 3.85C6.42 3.68 6.49 3.53 6.61 3.4C6.74 3.27 6.89 3.21 7.07 3.21C7.24 3.21 7.39 3.27 7.52 3.4C7.65 3.53 7.71 3.68 7.71 3.85C7.71 4.03 7.65 4.18 7.52 4.3C7.39 4.43 7.24 4.5 7.07 4.5ZM5.78 2.57C5.61 2.57 5.46 2.5 5.33 2.38C5.2 2.25 5.14 2.1 5.14 1.92C5.14 1.75 5.2 1.6 5.33 1.47C5.46 1.34 5.61 1.28 5.78 1.28C5.95 1.28 6.11 1.34 6.23 1.47C6.36 1.6 6.42 1.75 6.42 1.92C6.42 2.1 6.36 2.25 6.23 2.38C6.11 2.5 5.95 2.57 5.78 2.57ZM3.21 2.57C3.04 2.57 2.88 2.5 2.76 2.38C2.63 2.25 2.57 2.1 2.57 1.92C2.57 1.75 2.63 1.6 2.76 1.47C2.88 1.34 3.04 1.28 3.21 1.28C3.38 1.28 3.53 1.34 3.66 1.47C3.79 1.6 3.85 1.75 3.85 1.92C3.85 2.1 3.79 2.25 3.66 2.38C3.53 2.5 3.38 2.57 3.21 2.57ZM1.92 4.5C1.75 4.5 1.6 4.43 1.47 4.3C1.34 4.18 1.28 4.03 1.28 3.85C1.28 3.68 1.34 3.53 1.47 3.4C1.6 3.27 1.75 3.21 1.92 3.21C2.1 3.21 2.25 3.27 2.38 3.4C2.5 3.53 2.57 3.68 2.57 3.85C2.57 4.03 2.5 4.18 2.38 4.3C2.25 4.43 2.1 4.5 1.92 4.5Z" fill="#666666" fill-opacity="1.000000" fill-rule="nonzero"/>
</svg>
`, Nv = `<svg width="14.000000" height="14.000000" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_766">
			<rect id="svg" width="14.000000" height="14.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_766)">
		<path id="path" d="M5.55 9.66L2.67 6.78C2.65 6.76 2.63 6.74 2.61 6.72C2.58 6.71 2.56 6.69 2.53 6.68C2.5 6.67 2.48 6.66 2.45 6.66C2.42 6.65 2.39 6.65 2.36 6.65C2.33 6.65 2.3 6.65 2.28 6.65C2.25 6.66 2.22 6.67 2.19 6.68C2.17 6.69 2.14 6.7 2.12 6.72C2.09 6.74 2.07 6.75 2.05 6.77C2.03 6.79 2.01 6.82 1.99 6.84C1.98 6.87 1.96 6.89 1.95 6.92C1.94 6.94 1.93 6.97 1.93 7C1.92 7.03 1.92 7.06 1.92 7.09C1.92 7.12 1.92 7.15 1.93 7.17C1.94 7.2 1.94 7.23 1.96 7.26C1.97 7.28 1.98 7.31 2 7.33C2.01 7.36 2.03 7.38 2.05 7.4L5.55 10.9L12.55 3.9C12.57 3.88 12.59 3.86 12.61 3.83C12.62 3.81 12.64 3.78 12.65 3.76C12.66 3.73 12.66 3.7 12.67 3.68C12.67 3.65 12.68 3.62 12.68 3.59C12.68 3.56 12.67 3.53 12.67 3.51C12.66 3.48 12.65 3.45 12.64 3.43C12.63 3.4 12.62 3.37 12.6 3.35C12.59 3.33 12.57 3.31 12.55 3.29C12.53 3.26 12.51 3.25 12.48 3.23C12.46 3.22 12.43 3.2 12.41 3.19C12.38 3.18 12.36 3.17 12.33 3.17C12.3 3.16 12.27 3.16 12.24 3.16C12.21 3.16 12.19 3.16 12.16 3.16C12.13 3.17 12.1 3.18 12.08 3.19C12.05 3.2 12.03 3.21 12 3.23C11.98 3.24 11.96 3.26 11.94 3.28L5.55 9.66Z" fill="#409EFF" fill-opacity="1.000000" fill-rule="nonzero"/>
	</g>
</svg>
`, Av = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_15">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_15)">
		<path id="path" d="M12.34 17.99C15.84 17.99 18.68 15.15 18.68 11.65C18.68 8.15 15.84 5.31 12.34 5.31C8.84 5.31 6 8.15 6 11.65C6 15.15 8.84 17.99 12.34 17.99Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M18.68 11.65C18.68 8.15 15.84 5.31 12.34 5.31C8.84 5.31 6 8.15 6 11.65C6 15.15 8.84 17.99 12.34 17.99C15.84 17.99 18.68 15.15 18.68 11.65Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round"/>
		<path id="path" d="M13.99 13.6L13.98 13.58C14.14 13.25 14.53 13.12 14.85 13.28C15.18 13.45 15.31 13.83 15.14 14.16L15.12 14.17L13.99 13.6ZM9.57 14.17L9.54 14.16C9.38 13.83 9.51 13.45 9.83 13.28C10.16 13.12 10.54 13.25 10.7 13.58L10.7 13.6L9.57 14.17Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.56 13.87C14.56 13.87 13.93 15.13 12.34 15.13C10.76 15.13 10.12 13.87 10.12 13.87" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M13.93 9.76L13.91 9.74C13.91 9.38 14.2 9.09 14.56 9.09C14.93 9.09 15.21 9.38 15.21 9.74L15.19 9.76L13.93 9.76ZM15.19 10.99L15.21 11.01C15.21 11.38 14.93 11.66 14.56 11.66C14.2 11.66 13.91 11.38 13.91 11.01L13.93 10.99L15.19 10.99Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.56 9.74L14.56 11.01" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round" stroke-linecap="round"/>
		<path id="path" d="M9.49 9.76L9.47 9.74C9.47 9.38 9.76 9.09 10.12 9.09C10.49 9.09 10.77 9.38 10.77 9.74L10.75 9.76L9.49 9.76ZM10.75 10.99L10.77 11.01C10.77 11.38 10.49 11.66 10.12 11.66C9.76 11.66 9.47 11.38 9.47 11.01L9.49 10.99L10.75 10.99Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M10.12 9.74L10.12 11.01" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, Rv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_60">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_60)">
		<path id="path" d="M6.98 4.84L14.14 4.84L17.72 8.42L17.72 18.44C17.72 18.83 17.4 19.15 17.01 19.15L6.98 19.15C6.59 19.15 6.27 18.83 6.27 18.44L6.27 5.55C6.27 5.16 6.59 4.84 6.98 4.84Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.14 4.84L17.72 8.42L17.72 18.44C17.72 18.83 17.4 19.15 17.01 19.15L6.98 19.15C6.59 19.15 6.27 18.83 6.27 18.44L6.27 5.55C6.27 5.16 6.59 4.84 6.98 4.84L14.14 4.84Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round"/>
		<path id="path" d="M13.95 10.33C13.84 10.24 13.73 10.16 13.61 10.08C13.49 10.01 13.36 9.94 13.23 9.88C13.1 9.83 12.97 9.78 12.83 9.74C12.7 9.7 12.56 9.67 12.42 9.65C12.28 9.63 12.14 9.62 12 9.62C11.76 9.62 11.54 9.64 11.31 9.7C11.08 9.75 10.87 9.83 10.66 9.93L10.64 9.94L10.63 9.95C10.55 9.99 10.46 10.03 10.38 10.08L10.36 10.1Q10.17 10.22 10.01 10.36Q9.97 10.39 9.94 10.43C9.82 10.53 9.89 10.72 10.04 10.74L10.88 10.88C11.04 10.9 11.16 10.74 11.1 10.6L11.09 10.57C11.04 10.47 11.09 10.35 11.19 10.32C11.41 10.24 11.64 10.2 11.88 10.19L12 10.18L12.1 10.18C12.22 10.19 12.33 10.2 12.44 10.22C12.56 10.24 12.67 10.27 12.78 10.31C12.89 10.35 12.99 10.39 13.09 10.44C13.2 10.49 13.3 10.55 13.39 10.62C13.49 10.68 13.57 10.75 13.66 10.83C13.74 10.91 13.82 10.99 13.9 11.08C13.97 11.17 14.04 11.26 14.1 11.36C14.12 11.4 14.15 11.44 14.17 11.49C14.22 11.58 14.34 11.63 14.44 11.58L14.67 11.49C14.73 11.46 14.75 11.39 14.72 11.34C14.66 11.21 14.59 11.09 14.51 10.97C14.44 10.85 14.35 10.74 14.25 10.63C14.16 10.53 14.06 10.43 13.95 10.33ZM9.21 12.16L9.37 12.19C9.48 12.21 9.55 12.31 9.54 12.42C9.53 12.5 9.53 12.58 9.53 12.66C9.53 13.19 9.7 13.7 10 14.11C10.06 14.19 10.17 14.19 10.24 14.13C10.33 14.03 10.49 14.09 10.51 14.22L10.58 14.68L10.59 14.69L10.59 14.71L10.59 14.71L10.59 14.72L10.64 15.02C10.66 15.18 10.5 15.3 10.36 15.21Q10.29 15.17 10.23 15.12L10.21 15.11C10.13 15.05 10.05 14.99 9.98 14.92L9.91 14.86L9.88 14.83C9.85 14.8 9.82 14.77 9.79 14.74C9.66 14.6 9.54 14.45 9.44 14.29Q9.37 14.17 9.3 14.04L9.3 14.04L9.3 14.04Q9.24 13.91 9.18 13.78C9.11 13.6 9.06 13.41 9.02 13.23C8.99 13.04 8.97 12.85 8.97 12.66C8.97 12.54 8.97 12.43 8.99 12.33C9 12.22 9.1 12.14 9.21 12.16ZM14.98 13.16Q14.98 13.17 14.98 13.17Q14.95 13.36 14.89 13.55L14.88 13.57C14.87 13.62 14.85 13.67 14.83 13.72L14.82 13.74C14.78 13.87 14.72 13.99 14.66 14.1C14.59 14.22 14.52 14.33 14.45 14.44C14.37 14.55 14.28 14.65 14.19 14.75C14.1 14.84 14 14.93 13.9 15.02C13.8 15.1 13.69 15.18 13.57 15.25C13.46 15.32 13.34 15.38 13.22 15.43C13.1 15.49 12.98 15.53 12.85 15.57C12.73 15.61 12.6 15.63 12.48 15.65C12.46 15.65 12.45 15.66 12.44 15.66C12.39 15.65 12.33 15.61 12.33 15.56L12.3 15.31C12.29 15.2 12.37 15.1 12.48 15.08Q12.53 15.07 12.58 15.06C12.68 15.03 12.77 15 12.87 14.97C12.96 14.93 13.06 14.89 13.15 14.84C13.24 14.8 13.32 14.74 13.41 14.68C13.49 14.63 13.57 14.56 13.65 14.49C13.72 14.43 13.79 14.35 13.86 14.28C13.93 14.2 13.99 14.12 14.04 14.03C14.07 14 14.09 13.96 14.11 13.93C14.16 13.84 14.12 13.74 14.03 13.7C13.91 13.65 13.89 13.48 14.01 13.41L14.7 12.98C14.84 12.89 15.01 12.99 14.98 13.15Q14.98 13.16 14.98 13.16Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="path" d="M14.89 13.55L14.88 13.57C14.87 13.62 14.85 13.67 14.83 13.72L14.82 13.74C14.78 13.87 14.72 13.99 14.66 14.1C14.59 14.22 14.52 14.33 14.45 14.44C14.37 14.55 14.28 14.65 14.19 14.75C14.1 14.84 14 14.93 13.9 15.02C13.8 15.1 13.69 15.18 13.57 15.25C13.46 15.32 13.34 15.38 13.22 15.43C13.1 15.49 12.98 15.53 12.85 15.57C12.73 15.61 12.6 15.63 12.48 15.65C12.46 15.65 12.45 15.66 12.44 15.66C12.39 15.65 12.33 15.61 12.33 15.56L12.3 15.31C12.29 15.2 12.37 15.1 12.48 15.08C12.51 15.07 12.54 15.07 12.58 15.06C12.68 15.03 12.77 15 12.87 14.97C12.96 14.93 13.06 14.89 13.15 14.84C13.24 14.8 13.32 14.74 13.41 14.68C13.49 14.63 13.57 14.56 13.65 14.49C13.72 14.43 13.79 14.35 13.86 14.28C13.93 14.2 13.99 14.12 14.04 14.03C14.07 14 14.09 13.96 14.11 13.93C14.16 13.84 14.12 13.74 14.03 13.7C13.91 13.65 13.89 13.48 14.01 13.41L14.7 12.98C14.84 12.89 15.01 12.99 14.98 13.15C14.96 13.28 14.93 13.42 14.89 13.55ZM9.37 12.19C9.48 12.21 9.55 12.31 9.54 12.42C9.53 12.5 9.53 12.58 9.53 12.66C9.53 13.19 9.7 13.7 10 14.11C10.06 14.19 10.17 14.19 10.24 14.13C10.33 14.03 10.49 14.09 10.51 14.22L10.58 14.68L10.59 14.69L10.59 14.71L10.59 14.71L10.59 14.72L10.64 15.02C10.66 15.18 10.5 15.3 10.36 15.21C10.32 15.18 10.27 15.15 10.23 15.12L10.21 15.11C10.13 15.05 10.05 14.99 9.98 14.92L9.91 14.86L9.88 14.83C9.85 14.8 9.82 14.77 9.79 14.74C9.66 14.6 9.54 14.45 9.44 14.29C9.34 14.12 9.25 13.95 9.18 13.78C9.11 13.6 9.06 13.41 9.02 13.23C8.99 13.04 8.97 12.85 8.97 12.66C8.97 12.54 8.97 12.43 8.99 12.33C9 12.22 9.1 12.14 9.21 12.16L9.37 12.19ZM13.95 10.33C14.06 10.43 14.16 10.53 14.25 10.63C14.35 10.74 14.44 10.85 14.51 10.97C14.59 11.09 14.66 11.21 14.72 11.34C14.75 11.39 14.73 11.46 14.67 11.49L14.44 11.58C14.34 11.63 14.22 11.58 14.17 11.49C14.15 11.44 14.12 11.4 14.1 11.36C14.04 11.26 13.97 11.17 13.9 11.08C13.82 10.99 13.74 10.91 13.66 10.83C13.57 10.75 13.49 10.68 13.39 10.62C13.3 10.55 13.2 10.49 13.09 10.44C12.99 10.39 12.89 10.35 12.78 10.31C12.67 10.27 12.56 10.24 12.44 10.22C12.33 10.2 12.22 10.19 12.1 10.18L12 10.18L11.88 10.19C11.64 10.2 11.41 10.24 11.19 10.32C11.09 10.35 11.04 10.47 11.09 10.57L11.1 10.6C11.16 10.74 11.04 10.9 10.88 10.88L10.04 10.74C9.89 10.72 9.82 10.53 9.94 10.43C10.07 10.31 10.21 10.2 10.36 10.1L10.38 10.08C10.46 10.03 10.55 9.99 10.63 9.95L10.64 9.94L10.66 9.93C10.87 9.83 11.08 9.75 11.31 9.7C11.54 9.64 11.76 9.62 12 9.62C12.14 9.62 12.28 9.63 12.42 9.65C12.56 9.67 12.7 9.7 12.83 9.74C12.97 9.78 13.1 9.83 13.23 9.88C13.36 9.94 13.49 10.01 13.61 10.08C13.73 10.16 13.84 10.24 13.95 10.33Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
	</g>
</svg>
`, Iv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip216_125">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip216_125)">
		<path id="矢量 79" d="M11.07 4.53C7.49 4.53 4.59 7.43 4.59 11.01C4.59 14.59 7.49 17.5 11.07 17.5C14.65 17.5 17.55 14.59 17.55 11.01C17.55 7.43 14.65 4.53 11.07 4.53ZM9.96 6.26C10.32 6.17 10.69 6.13 11.07 6.13C11.45 6.13 11.81 6.17 12.17 6.26C12.44 6.32 12.71 6.41 12.97 6.52C13.23 6.63 13.49 6.76 13.73 6.92C14.01 7.1 14.27 7.32 14.52 7.56C14.76 7.81 14.98 8.07 15.16 8.35C15.32 8.59 15.45 8.85 15.57 9.11C15.67 9.37 15.76 9.64 15.82 9.91C15.91 10.27 15.95 10.64 15.95 11.01C15.95 11.39 15.91 11.76 15.82 12.12C15.76 12.39 15.68 12.66 15.57 12.91C15.45 13.18 15.32 13.44 15.16 13.68C14.98 13.96 14.76 14.22 14.52 14.47C14.27 14.71 14.01 14.92 13.73 15.11C13.49 15.26 13.23 15.4 12.97 15.51C12.71 15.62 12.44 15.71 12.17 15.77C11.81 15.85 11.45 15.9 11.07 15.9C10.69 15.9 10.32 15.85 9.96 15.77C9.69 15.71 9.43 15.62 9.17 15.51C8.9 15.4 8.65 15.26 8.41 15.11C8.12 14.92 7.86 14.71 7.62 14.47C7.37 14.22 7.16 13.96 6.97 13.68C6.82 13.44 6.68 13.18 6.57 12.91C6.46 12.66 6.37 12.39 6.31 12.12C6.23 11.76 6.19 11.39 6.19 11.01C6.19 10.64 6.23 10.27 6.31 9.91C6.37 9.64 6.46 9.37 6.57 9.11C6.68 8.85 6.82 8.59 6.97 8.35C7.16 8.07 7.37 7.81 7.62 7.56C7.86 7.32 8.12 7.1 8.41 6.92C8.65 6.76 8.9 6.63 9.17 6.52C9.43 6.41 9.69 6.32 9.96 6.26Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M15.74 15.04C15.53 14.82 15.22 14.78 15.04 14.96C14.86 15.13 14.88 15.44 15.09 15.66L18.38 19.06C18.59 19.28 18.9 19.32 19.08 19.14C19.26 18.97 19.24 18.66 19.02 18.44L15.74 15.04Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M15.04 14.96C14.86 15.13 14.88 15.44 15.09 15.66L18.38 19.06C18.59 19.28 18.9 19.32 19.08 19.14C19.26 18.97 19.24 18.66 19.02 18.44L15.74 15.04C15.53 14.82 15.22 14.78 15.04 14.96Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, Dv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_313">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_313)">
		<path id="矢量 52" d="M7.3 16.03C6.92 16.03 6.66 15.65 6.8 15.3L11.18 4.06C11.31 3.73 11.63 3.51 11.99 3.51C12.35 3.51 12.67 3.73 12.8 4.06L17.17 15.26C17.32 15.63 17.04 16.03 16.64 16.03C16.41 16.03 16.19 15.88 16.11 15.66L14.7 11.82L9.25 11.82L7.8 15.68C7.72 15.89 7.52 16.03 7.3 16.03ZM11.94 4.43C11.46 5.95 10.98 7.27 10.42 8.73L9.56 11L14.39 11L13.55 8.73C12.97 7.27 12.51 5.95 12.01 4.43L11.94 4.43ZM4.19 19.88C4.19 19.55 4.45 19.28 4.79 19.28L19.2 19.28C19.54 19.28 19.8 19.55 19.8 19.88C19.8 20.22 19.54 20.48 19.2 20.48L4.79 20.48C4.45 20.48 4.19 20.22 4.19 19.88Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 52" d="M4.19 19.88C4.19 20.22 4.45 20.48 4.79 20.48L19.2 20.48C19.54 20.48 19.8 20.22 19.8 19.88C19.8 19.55 19.54 19.28 19.2 19.28L4.79 19.28C4.45 19.28 4.19 19.55 4.19 19.88ZM11.94 4.43L12.01 4.43C12.51 5.95 12.97 7.27 13.55 8.73L14.39 11L9.56 11L10.42 8.73C10.98 7.27 11.46 5.95 11.94 4.43ZM9.25 11.82L14.7 11.82L16.11 15.66C16.19 15.88 16.41 16.03 16.64 16.03C17.04 16.03 17.32 15.63 17.17 15.26L12.8 4.06C12.67 3.73 12.35 3.51 11.99 3.51C11.63 3.51 11.31 3.73 11.18 4.06L6.8 15.3C6.66 15.65 6.92 16.03 7.3 16.03C7.52 16.03 7.72 15.89 7.8 15.68L9.25 11.82Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.200000"/>
	</g>
</svg>
`, Pv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip216_48">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip216_48)">
		<path id="矢量 56" d="M3.71 4.2C3.71 4.01 3.78 3.84 3.91 3.71C4.05 3.57 4.21 3.5 4.41 3.5L15.89 3.5C16.09 3.5 16.25 3.57 16.39 3.71C16.52 3.84 16.59 4.01 16.59 4.2L16.59 6.37L19.58 6.37C19.78 6.37 19.94 6.44 20.08 6.58C20.21 6.71 20.28 6.88 20.28 7.07L20.28 13.68Q20.28 13.81 20.24 13.93Q20.2 14.04 20.11 14.14C19.99 14.27 19.85 14.35 19.67 14.37L10.44 15.56L10.44 19.79C10.44 20.18 10.13 20.49 9.74 20.49C9.35 20.49 9.04 20.18 9.04 19.79L9.04 14.95Q9.04 14.82 9.08 14.7Q9.13 14.59 9.21 14.49C9.33 14.35 9.47 14.28 9.65 14.25L18.88 13.06L18.88 7.77L16.59 7.77L16.59 10.35C16.59 10.55 16.52 10.71 16.39 10.85C16.25 10.99 16.09 11.05 15.89 11.05L4.41 11.05C4.21 11.05 4.05 10.99 3.91 10.85C3.78 10.71 3.71 10.55 3.71 10.35L3.71 4.2ZM5.11 9.65L5.11 4.9L15.19 4.9L15.19 9.65L5.11 9.65Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Bv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_1">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_1)">
		<path id="path" d="M10.91 17.35L10.91 6.5C10.91 6.43 10.9 6.36 10.89 6.29C10.88 6.22 10.85 6.15 10.83 6.09C10.8 6.02 10.77 5.96 10.73 5.9C10.69 5.84 10.64 5.78 10.59 5.73C10.54 5.68 10.49 5.64 10.43 5.6C10.37 5.56 10.31 5.53 10.24 5.5C10.17 5.47 10.11 5.45 10.04 5.44C9.97 5.42 9.9 5.42 9.83 5.42L6.57 5.42C6.5 5.42 6.43 5.42 6.36 5.44C6.29 5.45 6.22 5.47 6.16 5.5C6.09 5.53 6.03 5.56 5.97 5.6C5.91 5.64 5.85 5.68 5.8 5.73C5.75 5.78 5.71 5.84 5.67 5.9C5.63 5.96 5.6 6.02 5.57 6.09C5.54 6.15 5.52 6.22 5.51 6.29C5.49 6.36 5.49 6.43 5.49 6.5L5.49 17.35C5.49 17.42 5.49 17.49 5.51 17.56C5.52 17.63 5.54 17.7 5.57 17.77C5.6 17.83 5.63 17.89 5.67 17.95C5.71 18.01 5.75 18.07 5.8 18.12C5.85 18.17 5.91 18.21 5.97 18.25C6.03 18.29 6.09 18.33 6.16 18.35C6.22 18.38 6.29 18.4 6.36 18.41C6.43 18.43 6.5 18.44 6.57 18.44L9.83 18.44C9.9 18.44 9.97 18.43 10.04 18.41C10.11 18.4 10.17 18.38 10.24 18.35C10.31 18.33 10.37 18.29 10.43 18.25C10.49 18.21 10.54 18.17 10.59 18.12C10.64 18.07 10.69 18.01 10.73 17.95C10.77 17.89 10.8 17.83 10.83 17.77C10.85 17.7 10.88 17.63 10.89 17.56C10.9 17.49 10.91 17.42 10.91 17.35ZM6.57 6.5L9.83 6.5L9.83 17.35L6.57 17.35L6.57 6.5ZM18.5 17.35L18.5 6.5C18.5 6.43 18.5 6.36 18.48 6.29C18.47 6.22 18.45 6.15 18.42 6.09C18.39 6.02 18.36 5.96 18.32 5.9C18.28 5.84 18.24 5.78 18.19 5.73C18.14 5.68 18.08 5.64 18.02 5.6C17.96 5.56 17.9 5.53 17.84 5.5C17.77 5.47 17.7 5.45 17.63 5.44C17.56 5.42 17.49 5.42 17.42 5.42L14.16 5.42C14.09 5.42 14.02 5.42 13.95 5.44C13.88 5.45 13.82 5.47 13.75 5.5C13.68 5.53 13.62 5.56 13.56 5.6C13.5 5.64 13.45 5.68 13.4 5.73C13.35 5.78 13.3 5.84 13.26 5.9C13.22 5.96 13.19 6.02 13.16 6.09C13.14 6.15 13.11 6.22 13.1 6.29C13.09 6.36 13.08 6.43 13.08 6.5L13.08 17.35C13.08 17.42 13.09 17.49 13.1 17.56C13.11 17.63 13.14 17.7 13.16 17.77C13.19 17.83 13.22 17.89 13.26 17.95C13.3 18.01 13.35 18.07 13.4 18.12C13.45 18.17 13.5 18.21 13.56 18.25C13.62 18.29 13.68 18.33 13.75 18.35C13.82 18.38 13.88 18.4 13.95 18.41C14.02 18.43 14.09 18.44 14.16 18.44L17.42 18.44C17.49 18.44 17.56 18.43 17.63 18.41C17.7 18.4 17.77 18.38 17.84 18.35C17.9 18.33 17.96 18.29 18.02 18.25C18.08 18.21 18.14 18.17 18.19 18.12C18.24 18.07 18.28 18.01 18.32 17.95C18.36 17.89 18.39 17.83 18.42 17.77C18.45 17.7 18.47 17.63 18.48 17.56C18.5 17.49 18.5 17.42 18.5 17.35ZM14.16 6.5L17.42 6.5L17.42 17.35L14.16 17.35L14.16 6.5Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
	</g>
</svg>
`, $v = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_81">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_81)">
		<path id="矢量 39" d="M17.17 5.64L6.82 5.64C5.87 5.64 5.09 6.42 5.09 7.37L5.09 10.82C5.09 11.77 5.87 12.55 6.82 12.55L17.17 12.55C18.12 12.55 18.9 11.77 18.9 10.82L18.9 7.37C18.9 6.42 18.12 5.64 17.17 5.64ZM17.91 10.82C17.91 11.02 17.84 11.2 17.69 11.34C17.55 11.48 17.37 11.56 17.17 11.56L6.82 11.56C6.62 11.56 6.44 11.48 6.3 11.34C6.16 11.2 6.08 11.02 6.08 10.82L6.08 7.37C6.08 7.17 6.16 6.99 6.3 6.85C6.44 6.71 6.62 6.63 6.82 6.63L17.17 6.63C17.37 6.63 17.55 6.71 17.69 6.85C17.83 6.99 17.91 7.17 17.91 7.37L17.91 10.82ZM15.55 14.49L6.79 14.49C6.52 14.49 6.3 14.71 6.3 14.98C6.3 15.26 6.52 15.48 6.79 15.48L15.55 15.48C15.82 15.48 16.04 15.26 16.04 14.98C16.04 14.71 15.82 14.49 15.55 14.49ZM13.48 17.36L6.79 17.36C6.52 17.36 6.3 17.58 6.3 17.85C6.3 18.13 6.52 18.35 6.79 18.35L13.48 18.35C13.75 18.35 13.97 18.13 13.97 17.85C13.97 17.58 13.75 17.36 13.48 17.36Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
		<path id="矢量 39" d="M6.82 5.64C5.87 5.64 5.09 6.42 5.09 7.37L5.09 10.82C5.09 11.77 5.87 12.55 6.82 12.55L17.17 12.55C18.12 12.55 18.9 11.77 18.9 10.82L18.9 7.37C18.9 6.42 18.12 5.64 17.17 5.64L6.82 5.64ZM17.69 11.34C17.55 11.48 17.37 11.56 17.17 11.56L6.82 11.56C6.62 11.56 6.44 11.48 6.3 11.34C6.16 11.2 6.08 11.02 6.08 10.82L6.08 7.37C6.08 7.17 6.16 6.99 6.3 6.85C6.44 6.71 6.62 6.63 6.82 6.63L17.17 6.63C17.37 6.63 17.55 6.71 17.69 6.85C17.83 6.99 17.91 7.17 17.91 7.37L17.91 10.82C17.91 11.02 17.84 11.2 17.69 11.34ZM6.79 14.49C6.52 14.49 6.3 14.71 6.3 14.98C6.3 15.26 6.52 15.48 6.79 15.48L15.55 15.48C15.82 15.48 16.04 15.26 16.04 14.98C16.04 14.71 15.82 14.49 15.55 14.49L6.79 14.49ZM6.79 17.36C6.52 17.36 6.3 17.58 6.3 17.85C6.3 18.13 6.52 18.35 6.79 18.35L13.48 18.35C13.75 18.35 13.97 18.13 13.97 17.85C13.97 17.58 13.75 17.36 13.48 17.36L6.79 17.36Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.250000"/>
	</g>
</svg>
`, zv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_7">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_7)">
		<path id="path" d="M18.98 11.32L19 11.3C19.39 11.3 19.7 11.6 19.7 12C19.7 12.39 19.39 12.7 19 12.7L18.98 12.67L18.98 11.32ZM6.01 12.67L6 12.7C5.6 12.7 5.29 12.39 5.29 12C5.29 11.6 5.6 11.3 6 11.3L6.01 11.32L6.01 12.67Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M19 12L6 12" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.400000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, Hv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_325">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_325)">
		<path id="矢量 50" d="M10.33 4.5L17 4.5M6.99 19.51L13.66 19.51M9.91 19.51L14.08 4.48" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.400000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, Fv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_146">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_146)">
		<path id="矢量 67" d="M9.93 5.47C9.93 5.19 10.19 4.97 10.52 4.97L19.58 4.97C19.91 4.97 20.17 5.19 20.17 5.47C20.17 5.75 19.91 5.97 19.58 5.97L10.52 5.97C10.19 5.97 9.93 5.75 9.93 5.47ZM9.93 9.82C9.93 9.54 10.19 9.32 10.52 9.32L16.58 9.32C16.91 9.32 17.17 9.54 17.17 9.82C17.17 10.1 16.91 10.32 16.58 10.32L10.52 10.32C10.19 10.32 9.93 10.1 9.93 9.82ZM10.52 13.67C10.19 13.67 9.93 13.89 9.93 14.17C9.93 14.45 10.19 14.67 10.52 14.67L19.58 14.67C19.91 14.67 20.17 14.45 20.17 14.17C20.17 13.89 19.91 13.67 19.58 13.67L10.52 13.67ZM9.93 18.52C9.93 18.24 10.15 18.02 10.43 18.02L16.43 18.02C16.71 18.02 16.93 18.24 16.93 18.52C16.93 18.8 16.71 19.02 16.43 19.02L10.43 19.02C10.15 19.02 9.93 18.8 9.93 18.52Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 67" d="M9.93 5.47C9.93 5.75 10.19 5.97 10.52 5.97L19.58 5.97C19.91 5.97 20.17 5.75 20.17 5.47C20.17 5.19 19.91 4.97 19.58 4.97L10.52 4.97C10.19 4.97 9.93 5.19 9.93 5.47ZM9.93 9.82C9.93 10.1 10.19 10.32 10.52 10.32L16.58 10.32C16.91 10.32 17.17 10.1 17.17 9.82C17.17 9.54 16.91 9.32 16.58 9.32L10.52 9.32C10.19 9.32 9.93 9.54 9.93 9.82ZM9.93 14.17C9.93 14.45 10.19 14.67 10.52 14.67L19.58 14.67C19.91 14.67 20.17 14.45 20.17 14.17C20.17 13.89 19.91 13.67 19.58 13.67L10.52 13.67C10.19 13.67 9.93 13.89 9.93 14.17ZM9.93 18.52C9.93 18.8 10.15 19.02 10.43 19.02L16.43 19.02C16.71 19.02 16.93 18.8 16.93 18.52C16.93 18.24 16.71 18.02 16.43 18.02L10.43 18.02C10.15 18.02 9.93 18.24 9.93 18.52Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
		<path id="矢量 69" d="M7.04 5.64L8.06 6.65C8.22 6.81 8.47 6.81 8.63 6.65C8.79 6.5 8.79 6.25 8.63 6.09L6.83 4.29C6.75 4.21 6.65 4.17 6.54 4.17C6.43 4.17 6.34 4.21 6.26 4.29L4.46 6.09C4.3 6.25 4.3 6.5 4.46 6.65C4.62 6.81 4.87 6.81 5.03 6.65L6.04 5.64L6.04 18.29C6.04 18.31 6.05 18.34 6.05 18.36L5.03 17.34C4.87 17.18 4.62 17.18 4.46 17.34C4.3 17.5 4.3 17.74 4.46 17.9L6.26 19.7C6.34 19.78 6.43 19.82 6.54 19.82C6.66 19.82 6.75 19.78 6.83 19.7L8.63 17.9C8.79 17.74 8.79 17.5 8.63 17.34C8.47 17.18 8.22 17.18 8.06 17.34L7.04 18.36C7.04 18.34 7.04 18.31 7.04 18.29L7.04 5.64Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Uv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_3">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_3)">
		<path id="path" d="M11.57 6.33L11.57 6.3C11.82 6.05 12.23 6.05 12.48 6.3C12.74 6.56 12.74 6.96 12.48 7.22L12.46 7.22L11.57 6.33ZM14.54 9.3L14.54 9.28C14.8 9.02 15.2 9.02 15.46 9.28C15.71 9.53 15.71 9.94 15.46 10.2L15.43 10.2L14.54 9.3Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M12.03 6.76L6.82 11.97C5.59 13.2 5.59 15.19 6.82 16.42C8.05 17.66 10.05 17.66 11.28 16.42L17.48 10.23C18.3 9.41 18.3 8.08 17.48 7.26C16.65 6.44 15.32 6.44 14.5 7.26L8.31 13.45C7.9 13.86 7.9 14.53 8.31 14.94C8.72 15.35 9.39 15.35 9.8 14.94L15 9.74" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, Vv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_5">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_5)">
		<path id="path" d="M17.05 7.2L17.08 7.2C17.34 7.46 17.34 7.86 17.08 8.12C16.82 8.38 16.42 8.38 16.16 8.12L16.16 8.09L17.05 7.2ZM16.16 15.9L16.16 15.87C16.42 15.62 16.82 15.62 17.08 15.87C17.34 16.13 17.34 16.53 17.08 16.79L17.05 16.79L16.16 15.9Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M16.62 7.66L15.75 6.79L7.37 6.79L12.57 12L7.37 17.2L15.75 17.2L16.62 16.33" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.300000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, jv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_164">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_164)">
		<path id="矢量 65" d="M5.93 6.1C5.93 5.82 6.19 5.6 6.51 5.6L20.58 5.6C20.91 5.6 21.16 5.82 21.16 6.1C21.16 6.38 20.91 6.6 20.58 6.6L6.51 6.6C6.19 6.6 5.93 6.38 5.93 6.1ZM5.93 10.45C5.93 10.17 6.19 9.95 6.51 9.95L15.58 9.95C15.91 9.95 16.16 10.17 16.16 10.45C16.16 10.73 15.91 10.95 15.58 10.95L6.51 10.95C6.19 10.95 5.93 10.73 5.93 10.45ZM6.51 14.3C6.19 14.3 5.93 14.52 5.93 14.8C5.93 15.08 6.19 15.3 6.51 15.3L15.58 15.3C15.91 15.3 16.16 15.08 16.16 14.8C16.16 14.52 15.91 14.3 15.58 14.3L6.51 14.3ZM6.16 19.15C6.16 18.87 6.38 18.65 6.66 18.65L20.66 18.65C20.94 18.65 21.16 18.87 21.16 19.15C21.16 19.43 20.94 19.65 20.66 19.65L6.66 19.65C6.38 19.65 6.16 19.43 6.16 19.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 65" d="M5.93 6.1C5.93 6.38 6.19 6.6 6.51 6.6L20.58 6.6C20.91 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.91 5.6 20.58 5.6L6.51 5.6C6.19 5.6 5.93 5.82 5.93 6.1ZM5.93 10.45C5.93 10.73 6.19 10.95 6.51 10.95L15.58 10.95C15.91 10.95 16.16 10.73 16.16 10.45C16.16 10.17 15.91 9.95 15.58 9.95L6.51 9.95C6.19 9.95 5.93 10.17 5.93 10.45ZM5.93 14.8C5.93 15.08 6.19 15.3 6.51 15.3L15.58 15.3C15.91 15.3 16.16 15.08 16.16 14.8C16.16 14.52 15.91 14.3 15.58 14.3L6.51 14.3C6.19 14.3 5.93 14.52 5.93 14.8ZM6.16 19.15C6.16 19.43 6.38 19.65 6.66 19.65L20.66 19.65C20.94 19.65 21.16 19.43 21.16 19.15C21.16 18.87 20.94 18.65 20.66 18.65L6.66 18.65C6.38 18.65 6.16 18.87 6.16 19.15Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
		<path id="矢量 64" d="M18.64 11.31L19.96 12.62L18.64 13.93C18.45 14.13 18.45 14.44 18.64 14.64C18.84 14.84 19.15 14.84 19.35 14.64L21.02 12.98C21.12 12.88 21.16 12.76 21.16 12.62C21.16 12.48 21.12 12.37 21.02 12.27L19.35 10.6C19.15 10.4 18.84 10.4 18.64 10.6C18.45 10.8 18.45 11.11 18.64 11.31Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Wv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_113">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_113)">
		<path id="矢量 62" d="M5.93 6.1C5.93 5.82 6.19 5.6 6.51 5.6L20.58 5.6C20.91 5.6 21.16 5.82 21.16 6.1C21.16 6.38 20.91 6.6 20.58 6.6L6.51 6.6C6.19 6.6 5.93 6.38 5.93 6.1ZM10.93 10.45C10.93 10.17 11.19 9.95 11.51 9.95L20.58 9.95C20.91 9.95 21.16 10.17 21.16 10.45C21.16 10.73 20.91 10.95 20.58 10.95L11.51 10.95C11.19 10.95 10.93 10.73 10.93 10.45ZM11.51 14.3C11.19 14.3 10.93 14.52 10.93 14.8C10.93 15.08 11.19 15.3 11.51 15.3L20.58 15.3C20.91 15.3 21.16 15.08 21.16 14.8C21.16 14.52 20.91 14.3 20.58 14.3L11.51 14.3ZM6.16 19.15C6.16 18.87 6.38 18.65 6.66 18.65L20.66 18.65C20.94 18.65 21.16 18.87 21.16 19.15C21.16 19.43 20.94 19.65 20.66 19.65L6.66 19.65C6.38 19.65 6.16 19.43 6.16 19.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 62" d="M5.93 6.1C5.93 6.38 6.19 6.6 6.51 6.6L20.58 6.6C20.91 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.91 5.6 20.58 5.6L6.51 5.6C6.19 5.6 5.93 5.82 5.93 6.1ZM10.93 10.45C10.93 10.73 11.19 10.95 11.51 10.95L20.58 10.95C20.91 10.95 21.16 10.73 21.16 10.45C21.16 10.17 20.91 9.95 20.58 9.95L11.51 9.95C11.19 9.95 10.93 10.17 10.93 10.45ZM10.93 14.8C10.93 15.08 11.19 15.3 11.51 15.3L20.58 15.3C20.91 15.3 21.16 15.08 21.16 14.8C21.16 14.52 20.91 14.3 20.58 14.3L11.51 14.3C11.19 14.3 10.93 14.52 10.93 14.8ZM6.16 19.15C6.16 19.43 6.38 19.65 6.66 19.65L20.66 19.65C20.94 19.65 21.16 19.43 21.16 19.15C21.16 18.87 20.94 18.65 20.66 18.65L6.66 18.65C6.38 18.65 6.16 18.87 6.16 19.15Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
		<path id="矢量 63" d="M8.45 11.31L7.14 12.62L8.45 13.93C8.65 14.13 8.65 14.44 8.45 14.64C8.25 14.84 7.94 14.84 7.74 14.64L6.08 12.98C5.98 12.88 5.93 12.76 5.93 12.62C5.93 12.48 5.98 12.37 6.08 12.27L7.74 10.6C7.94 10.4 8.25 10.4 8.45 10.6C8.65 10.8 8.65 11.11 8.45 11.31Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Zv = `<svg width="32.000000" height="32.000000" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1654">
			<rect id="svg" width="24.000000" height="24.000000" transform="translate(4.000000 4.000000)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<rect id="矩形 350" rx="2.000000" width="32.000000" height="32.000000" fill-opacity="0.130000"/>
	<rect id="矩形 350" x="0.200012" y="0.199951" rx="2.000000" width="31.600000" height="31.600000" stroke-opacity="1.000000" stroke-width="0.400000"/>
	<g clip-path="url(#clip21_1654)">
		<path id="矢量 4" d="M13.85 7L26.79 7C27.09 7 27.32 7.21 27.32 7.5C27.32 7.78 27.09 8 26.79 8L13.85 8C13.55 8 13.32 7.78 13.32 7.5C13.32 7.21 13.55 7 13.85 7Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M13.85 15L26.79 15C27.09 15 27.32 15.22 27.32 15.5C27.32 15.78 27.09 16 26.79 16L13.85 16C13.55 16 13.32 15.78 13.32 15.5C13.32 15.22 13.55 15 13.85 15Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M13.85 23L26.79 23C27.09 23 27.32 23.22 27.32 23.5C27.32 23.78 27.09 24 26.79 24L13.85 24C13.55 24 13.32 23.78 13.32 23.5C13.32 23.22 13.55 23 13.85 23Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="一、" d="M8.75 6.67L4.23 6.67L4.23 7.14L8.75 7.14L8.75 6.67ZM10.46 8.52Q10.19 8.22 9.87 8.01L9.58 8.27C9.78 8.42 9.97 8.6 10.15 8.79C10.33 8.98 10.48 9.16 10.59 9.32L10.92 9.05Q10.72 8.78 10.46 8.52Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="二、" d="M8.28 13.16L4.71 13.16L4.71 13.62L8.28 13.62L8.28 13.16ZM10.46 16.52Q10.19 16.23 9.87 16.01L9.58 16.27C9.78 16.42 9.97 16.6 10.15 16.79C10.33 16.98 10.48 17.16 10.59 17.32L10.92 17.05Q10.72 16.78 10.46 16.52ZM8.74 16.31L4.25 16.31L4.25 16.78L8.74 16.78L8.74 16.31Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="三、" d="M8.46 21.49L4.55 21.49L4.55 21.96L8.46 21.96L8.46 21.49ZM8.09 23.21L4.91 23.21L4.91 23.67L8.09 23.67L8.09 23.21ZM10.46 25.02Q10.19 24.73 9.87 24.51L9.58 24.77C9.78 24.92 9.97 25.1 10.15 25.29C10.33 25.48 10.48 25.66 10.59 25.82L10.92 25.55Q10.72 25.28 10.46 25.02ZM8.75 25.05L4.24 25.05L4.24 25.52L8.75 25.52L8.75 25.05Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Kv = `<svg width="32.000000" height="32.000000" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1675">
			<rect id="svg" width="24.000000" height="24.000000" transform="translate(4.000000 4.000000)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<rect id="矩形 350" x="0.200012" y="0.199951" rx="2.000000" width="31.600000" height="31.600000"  stroke-opacity="1.000000" stroke-width="0.400000"/>
	<g clip-path="url(#clip21_1675)">
		<path id="矢量 4" d="M13.65 7L26.59 7C26.89 7 27.12 7.21 27.12 7.5C27.12 7.78 26.89 8 26.59 8L13.65 8C13.36 8 13.12 7.78 13.12 7.5C13.12 7.21 13.36 7 13.65 7Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M13.65 15L26.59 15C26.89 15 27.12 15.22 27.12 15.5C27.12 15.78 26.89 16 26.59 16L13.65 16C13.36 16 13.12 15.78 13.12 15.5C13.12 15.22 13.36 15 13.65 15Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M13.65 23L26.59 23C26.89 23 27.12 23.22 27.12 23.5C27.12 23.78 26.89 24 26.59 24L13.65 24C13.36 24 13.12 23.78 13.12 23.5C13.12 23.22 13.36 23 13.65 23Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 67" cx="8.144409" cy="6.887329" r="2.051001" stroke="#666666" stroke-opacity="0.990000" stroke-width="0.200000"/>
		<path id="1" d="M8.42 8.38L8.42 5.53L8.09 5.53Q7.96 5.67 7.74 5.81C7.6 5.89 7.46 5.95 7.33 5.98L7.33 6.41Q7.72 6.3 7.99 6.05L7.99 6.05L7.99 8.38L8.42 8.38Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 67" cx="8.144409" cy="15.000122" r="2.051001" stroke="#666666" stroke-opacity="0.990000" stroke-width="0.200000"/>
		<path id="2" d="M8.74 13.74Q8.5 13.58 8.17 13.58Q7.86 13.58 7.63 13.72Q7.52 13.79 7.43 13.89Q7.4 13.93 7.36 13.97Q7.16 14.24 7.16 14.66L7.59 14.66Q7.6 14.31 7.74 14.13Q7.78 14.08 7.83 14.04Q7.96 13.95 8.15 13.95Q8.41 13.95 8.54 14.07C8.63 14.15 8.67 14.27 8.67 14.43Q8.67 14.47 8.67 14.52Q8.64 14.72 8.48 14.9C8.4 14.98 8.26 15.09 8.07 15.23Q7.57 15.57 7.42 15.75Q7.28 15.91 7.21 16.1Q7.14 16.28 7.14 16.5L9.11 16.5L9.11 16.11L7.68 16.11C7.74 15.95 7.92 15.77 8.23 15.57Q8.66 15.28 8.82 15.11Q9.04 14.87 9.09 14.6Q9.1 14.52 9.1 14.44Q9.1 14.21 9.01 14.04Q8.95 13.92 8.84 13.82Q8.79 13.77 8.74 13.74Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 67" cx="8.144409" cy="23.500122" r="2.051001" stroke="#666666" stroke-opacity="0.990000" stroke-width="0.200000"/>
		<path id="3" d="M8.84 22.29Q8.58 22.08 8.15 22.08Q7.79 22.08 7.55 22.25Q7.51 22.28 7.47 22.32Q7.39 22.38 7.34 22.46Q7.18 22.67 7.15 22.98L7.58 22.98C7.6 22.81 7.65 22.68 7.75 22.59Q7.75 22.58 7.76 22.58Q7.9 22.46 8.16 22.46Q8.42 22.46 8.54 22.57Q8.57 22.59 8.58 22.61Q8.67 22.72 8.67 22.9C8.67 23.04 8.62 23.15 8.53 23.23C8.44 23.31 8.31 23.35 8.14 23.35L7.93 23.35L7.93 23.67L8.14 23.67Q8.42 23.67 8.57 23.79Q8.6 23.82 8.62 23.85Q8.72 23.97 8.72 24.17Q8.72 24.27 8.69 24.36Q8.65 24.45 8.58 24.52Q8.54 24.56 8.49 24.59Q8.34 24.68 8.13 24.68Q7.93 24.68 7.79 24.59Q7.75 24.57 7.72 24.54C7.61 24.44 7.54 24.29 7.54 24.09L7.1 24.09Q7.13 24.49 7.33 24.73Q7.38 24.78 7.43 24.83Q7.45 24.84 7.47 24.86Q7.73 25.05 8.14 25.05Q8.5 25.05 8.77 24.88Q8.83 24.84 8.88 24.79Q8.99 24.69 9.06 24.57Q9.16 24.38 9.16 24.15Q9.16 23.94 9.06 23.79Q9.04 23.76 9.01 23.73C8.92 23.62 8.79 23.55 8.63 23.5C8.94 23.39 9.1 23.18 9.1 22.87Q9.1 22.64 9 22.47Q8.94 22.37 8.84 22.29Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, Gv = `<svg width="32.000000" height="32.000000" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1647">
			<rect id="svg" width="24.000000" height="24.000000" transform="translate(4.000000 4.000000)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<rect id="矩形 350" rx="2.000000" width="32.000000" height="32.000000"  fill-opacity="0.130000"/>
	<rect id="矩形 350" x="0.200012" y="0.199951" rx="2.000000" width="31.600000" height="31.600000"  stroke-opacity="1.000000" stroke-width="0.400000"/>
	<g clip-path="url(#clip21_1647)">
		<path id="path" d="M6.21 3.99L6.8 3.99L6.8 8.76L6.02 8.76L6.02 4.94C5.73 5.2 5.37 5.39 4.93 5.52L4.93 4.74C5.14 4.69 5.37 4.59 5.61 4.46C5.85 4.31 6.05 4.16 6.21 3.99ZM6.47 11.9C6.93 11.9 7.31 12.04 7.61 12.3C7.9 12.57 8.05 12.91 8.05 13.34C8.05 13.75 7.89 14.12 7.58 14.46C7.4 14.66 7.06 14.92 6.6 15.23C6.11 15.55 5.82 15.83 5.71 16.07L8.06 16.07L8.06 16.76L4.74 16.76C4.74 16.27 4.89 15.85 5.21 15.49C5.38 15.29 5.75 15 6.3 14.62C6.61 14.4 6.82 14.22 6.96 14.08C7.05 13.98 7.13 13.87 7.18 13.74C7.24 13.61 7.27 13.47 7.27 13.33C7.27 13.07 7.2 12.88 7.06 12.75C6.92 12.62 6.72 12.56 6.44 12.56C6.15 12.56 5.93 12.66 5.78 12.86C5.64 13.05 5.56 13.34 5.54 13.71L4.76 13.71C4.77 13.18 4.92 12.75 5.23 12.42C5.54 12.08 5.96 11.9 6.47 11.9ZM6.44 19.91C6.92 19.91 7.32 20.02 7.61 20.25C7.9 20.49 8.04 20.81 8.04 21.22C8.04 21.74 7.78 22.09 7.25 22.26C7.53 22.35 7.75 22.47 7.9 22.65C8.06 22.83 8.14 23.06 8.14 23.34C8.14 23.78 7.98 24.14 7.68 24.42C7.36 24.71 6.94 24.85 6.42 24.85C5.92 24.85 5.52 24.73 5.22 24.47C4.89 24.19 4.7 23.78 4.66 23.25L5.46 23.25C5.47 23.55 5.56 23.79 5.75 23.96C5.92 24.11 6.14 24.19 6.41 24.19C6.71 24.19 6.95 24.11 7.12 23.94C7.2 23.87 7.26 23.78 7.3 23.68C7.34 23.58 7.36 23.48 7.36 23.37C7.36 23.1 7.27 22.9 7.11 22.77C6.95 22.64 6.72 22.58 6.41 22.58L6.08 22.58L6.08 21.99L6.41 21.99C6.69 21.99 6.9 21.93 7.05 21.81C7.19 21.69 7.26 21.51 7.26 21.28C7.26 21.05 7.2 20.87 7.07 20.75C6.93 20.63 6.72 20.57 6.45 20.57C6.17 20.57 5.96 20.64 5.8 20.78C5.64 20.92 5.55 21.13 5.52 21.42L4.76 21.42C4.8 20.94 4.97 20.57 5.29 20.3C5.59 20.03 5.98 19.91 6.44 19.91Z" fill="#666666" fill-opacity="1.000000" fill-rule="nonzero"/>
		<path id="矢量 4" d="M13.51 7L26.45 7C26.74 7 26.98 7.21 26.98 7.5C26.98 7.78 26.74 8 26.45 8L13.51 8C13.21 8 12.98 7.78 12.98 7.5C12.98 7.21 13.21 7 13.51 7Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M13.51 15L26.45 15C26.74 15 26.98 15.22 26.98 15.5C26.98 15.78 26.74 16 26.45 16L13.51 16C13.21 16 12.98 15.78 12.98 15.5C12.98 15.22 13.21 15 13.51 15Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M13.51 23L26.45 23C26.74 23 26.98 23.22 26.98 23.5C26.98 23.78 26.74 24 26.45 24L13.51 24C13.21 24 12.98 23.78 12.98 23.5C12.98 23.22 13.21 23 13.51 23Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 64" cx="9.344604" cy="7.927979" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 65" cx="9.344604" cy="15.881104" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 66" cx="9.344604" cy="23.834229" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
	</g>
</svg>
`, qv = `<svg width="32.000000" height="32.000000" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1668">
			<rect id="svg" width="24.000000" height="24.000000" transform="translate(4.000000 4.000000)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<rect id="矩形 350" x="0.200012" y="0.200012" rx="2.000000" width="31.600000" height="31.600000"  stroke-opacity="1.000000" stroke-width="0.400000"/>
	<g clip-path="url(#clip21_1668)">
		<path id="矢量 4" d="M13.64 7L26.58 7C26.88 7 27.11 7.22 27.11 7.5C27.11 7.77 26.88 8 26.58 8L13.64 8C13.34 8 13.11 7.77 13.11 7.5C13.11 7.22 13.34 7 13.64 7Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M13.64 15L26.58 15C26.88 15 27.11 15.22 27.11 15.5C27.11 15.78 26.88 16 26.58 16L13.64 16C13.34 16 13.11 15.78 13.11 15.5C13.11 15.22 13.34 15 13.64 15Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M13.64 23L26.58 23C26.88 23 27.11 23.22 27.11 23.5C27.11 23.78 26.88 24 26.58 24L13.64 24C13.34 24 13.11 23.78 13.11 23.5C13.11 23.22 13.34 23 13.64 23Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="a" d="M6.76 5.15Q6.44 4.81 5.75 4.81Q5.13 4.81 4.8 5.04Q4.69 5.11 4.61 5.2Q4.38 5.45 4.33 5.85L4.96 5.85Q4.98 5.68 5.07 5.57Q5.13 5.5 5.21 5.44Q5.38 5.32 5.71 5.32Q6.09 5.32 6.26 5.51Q6.41 5.67 6.41 5.97L6.41 6.05L5.72 6.06Q5.09 6.06 4.7 6.3Q4.51 6.41 4.4 6.58Q4.24 6.82 4.24 7.17Q4.24 7.42 4.34 7.61Q4.41 7.74 4.52 7.83Q4.54 7.84 4.55 7.85Q4.83 8.08 5.29 8.08Q5.69 8.08 6 7.93Q6.28 7.79 6.45 7.56L6.45 7.99L7.04 7.99L7.04 6.01Q7.04 5.45 6.76 5.15Q6.76 5.15 6.76 5.15ZM5.76 6.54L6.41 6.54L6.41 6.7Q6.41 6.93 6.31 7.12Q6.25 7.24 6.14 7.33Q6.08 7.39 6 7.43Q5.76 7.57 5.43 7.57Q5.17 7.57 5.03 7.45Q4.96 7.4 4.93 7.32Q4.89 7.24 4.89 7.15Q4.89 6.95 4.98 6.82Q5.17 6.54 5.76 6.54Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="b" d="M4.99 12.21L4.36 12.21L4.36 16.57L4.95 16.57L4.95 16.2Q5.07 16.37 5.23 16.47Q5.51 16.66 5.91 16.66Q6.32 16.66 6.63 16.48Q6.83 16.36 6.98 16.17Q7 16.15 7.02 16.12Q7.34 15.68 7.34 15.01Q7.34 14.42 7.08 14Q7.04 13.94 6.99 13.87Q6.83 13.68 6.63 13.56Q6.34 13.39 5.94 13.39Q5.75 13.39 5.59 13.45Q5.25 13.57 4.99 13.93L4.99 12.21ZM5.44 13.99Q5.59 13.9 5.8 13.9Q6.14 13.9 6.35 14.07Q6.43 14.13 6.49 14.22Q6.69 14.49 6.69 15.01Q6.69 15.51 6.5 15.81Q6.42 15.92 6.31 16Q6.11 16.14 5.81 16.14Q5.59 16.14 5.42 16.04Q5.28 15.96 5.17 15.81Q4.97 15.51 4.97 15.05L4.97 15Q4.97 14.49 5.22 14.19Q5.31 14.06 5.44 13.99Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="c" d="M6.69 21.31Q6.33 21.04 5.74 21.04Q5.26 21.04 4.92 21.26Q4.75 21.36 4.61 21.53Q4.56 21.59 4.51 21.66Q4.24 22.08 4.24 22.68Q4.24 23.32 4.54 23.74Q4.58 23.8 4.62 23.84Q4.74 23.98 4.88 24.08Q5.23 24.31 5.72 24.31Q6.29 24.31 6.65 24.04Q6.67 24.03 6.68 24.01Q7.05 23.7 7.16 23.08L6.53 23.08Q6.48 23.44 6.28 23.62Q6.08 23.79 5.73 23.79Q5.47 23.79 5.29 23.67Q5.19 23.6 5.11 23.5Q4.89 23.2 4.89 22.67Q4.89 22.14 5.12 21.86Q5.21 21.74 5.33 21.66Q5.5 21.56 5.74 21.56Q6.06 21.56 6.26 21.71Q6.45 21.85 6.51 22.18L7.14 22.18Q7.07 21.68 6.78 21.39Q6.74 21.35 6.69 21.31Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 64" cx="8.500000" cy="7.749390" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 65" cx="8.500000" cy="16.000000" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 66" cx="8.500000" cy="23.834106" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
	</g>
</svg>
`, Qv = `<svg width="32.000000" height="32.000000" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1682">
			<rect id="svg" width="24.000000" height="24.000000" transform="translate(4.000000 4.000000)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<rect id="矩形 350" x="0.200012" y="0.200012" rx="2.000000" width="31.600000" height="31.600000"  stroke-opacity="1.000000" stroke-width="0.400000"/>
	<g clip-path="url(#clip21_1682)">
		<path id="矢量 4" d="M13.7 7L26.64 7C26.94 7 27.17 7.22 27.17 7.5C27.17 7.77 26.94 8 26.64 8L13.7 8C13.41 8 13.17 7.77 13.17 7.5C13.17 7.22 13.41 7 13.7 7Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M13.7 15L26.64 15C26.94 15 27.17 15.22 27.17 15.5C27.17 15.78 26.94 16 26.64 16L13.7 16C13.41 16 13.17 15.78 13.17 15.5C13.17 15.22 13.41 15 13.7 15Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M13.7 23L26.64 23C26.94 23 27.17 23.22 27.17 23.5C27.17 23.78 26.94 24 26.64 24L13.7 24C13.41 24 13.17 23.78 13.17 23.5C13.17 23.22 13.41 23 13.7 23Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="iii" d="M4.94 20.39Q4.87 20.35 4.76 20.35Q4.66 20.35 4.59 20.39Q4.54 20.41 4.5 20.45Q4.49 20.47 4.47 20.49Q4.4 20.57 4.4 20.7Q4.4 20.81 4.45 20.88Q4.47 20.93 4.5 20.96Q4.58 21.03 4.66 21.05Q4.71 21.06 4.76 21.06Q4.82 21.06 4.87 21.05Q4.95 21.02 5.02 20.96Q5.08 20.91 5.1 20.84Q5.13 20.78 5.13 20.7Q5.13 20.59 5.08 20.52Q5.06 20.48 5.02 20.45Q4.99 20.42 4.94 20.39ZM6.48 20.39Q6.4 20.35 6.3 20.35Q6.2 20.35 6.12 20.39Q6.08 20.41 6.04 20.45Q6.02 20.47 6.01 20.49Q5.94 20.57 5.94 20.7Q5.94 20.81 5.98 20.88Q6.01 20.93 6.04 20.96Q6.11 21.03 6.2 21.05Q6.25 21.06 6.3 21.06Q6.36 21.06 6.41 21.05Q6.49 21.02 6.56 20.96Q6.61 20.91 6.64 20.84Q6.66 20.78 6.66 20.7Q6.66 20.59 6.61 20.52Q6.59 20.48 6.56 20.45Q6.52 20.42 6.48 20.39ZM8.02 20.39Q7.94 20.35 7.83 20.35Q7.74 20.35 7.66 20.39Q7.61 20.41 7.58 20.45Q7.56 20.47 7.54 20.49Q7.48 20.57 7.48 20.7Q7.48 20.81 7.52 20.88Q7.54 20.93 7.58 20.96Q7.65 21.03 7.73 21.05Q7.78 21.06 7.83 21.06Q7.89 21.06 7.95 21.05Q8.03 21.02 8.09 20.96Q8.15 20.91 8.18 20.84Q8.2 20.78 8.2 20.7Q8.2 20.59 8.15 20.52Q8.13 20.48 8.09 20.45Q8.06 20.42 8.02 20.39ZM5 21.52L4.52 21.52L4.52 24.62L5 24.62L5 21.52ZM6.54 21.52L6.06 21.52L6.06 24.62L6.54 24.62L6.54 21.52ZM8.07 21.52L7.59 21.52L7.59 24.62L8.07 24.62L8.07 21.52Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="ii" d="M6.29 13.15Q6.21 13.1 6.1 13.1Q6.01 13.1 5.93 13.14Q5.88 13.17 5.85 13.21Q5.83 13.22 5.81 13.24Q5.75 13.32 5.75 13.46Q5.75 13.56 5.79 13.64Q5.81 13.68 5.85 13.72Q5.92 13.78 6 13.8Q6.05 13.82 6.1 13.82Q6.16 13.82 6.22 13.8Q6.29 13.78 6.36 13.72Q6.42 13.66 6.44 13.59Q6.47 13.53 6.47 13.46Q6.47 13.35 6.42 13.27Q6.4 13.23 6.36 13.21Q6.33 13.17 6.29 13.15ZM7.82 13.15Q7.74 13.1 7.64 13.1Q7.54 13.1 7.47 13.14Q7.42 13.17 7.38 13.21Q7.36 13.22 7.35 13.24Q7.28 13.32 7.28 13.46Q7.28 13.56 7.32 13.64Q7.35 13.68 7.38 13.72Q7.45 13.78 7.54 13.8Q7.59 13.82 7.64 13.82Q7.7 13.82 7.75 13.8Q7.83 13.78 7.9 13.72Q7.95 13.66 7.98 13.59Q8.01 13.53 8.01 13.46Q8.01 13.35 7.96 13.27Q7.93 13.23 7.9 13.21Q7.86 13.17 7.82 13.15ZM6.34 14.27L5.86 14.27L5.86 17.38L6.34 17.38L6.34 14.27ZM7.88 14.27L7.4 14.27L7.4 17.38L7.88 17.38L7.88 14.27Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="i" d="M7.75 5.19Q7.67 5.15 7.57 5.15Q7.47 5.15 7.39 5.19Q7.35 5.22 7.31 5.25Q7.29 5.27 7.27 5.29Q7.21 5.37 7.21 5.5Q7.21 5.61 7.25 5.69Q7.27 5.73 7.31 5.76Q7.38 5.83 7.46 5.85Q7.51 5.86 7.57 5.86Q7.63 5.86 7.68 5.85Q7.76 5.82 7.82 5.76Q7.88 5.71 7.91 5.64Q7.93 5.58 7.93 5.5Q7.93 5.4 7.88 5.32Q7.86 5.28 7.82 5.25Q7.79 5.22 7.75 5.19ZM7.81 6.32L7.33 6.32L7.33 9.42L7.81 9.42L7.81 6.32Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 64" cx="9.500061" cy="8.635254" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 65" cx="9.500061" cy="16.500000" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 66" cx="9.500061" cy="23.834106" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
	</g>
</svg>
`, Yv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1661">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip21_1661)">
		<path id="矢量 4" d="M9.46 3L22.4 3C22.69 3 22.93 3.22 22.93 3.5C22.93 3.77 22.69 4 22.4 4L9.46 4C9.16 4 8.93 3.77 8.93 3.5C8.93 3.22 9.16 3 9.46 3Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 29" d="M9.46 11L22.4 11C22.69 11 22.93 11.22 22.93 11.5C22.93 11.78 22.69 12 22.4 12L9.46 12C9.16 12 8.93 11.78 8.93 11.5C8.93 11.22 9.16 11 9.46 11Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 30" d="M9.46 19L22.4 19C22.69 19 22.93 19.21 22.93 19.5C22.93 19.78 22.69 20 22.4 20L9.46 20C9.16 20 8.93 19.78 8.93 19.5C8.93 19.21 9.16 19 9.46 19Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<circle id="椭圆 64" cx="4.500000" cy="4.255127" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 65" cx="4.500000" cy="12.238037" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 66" cx="4.500000" cy="19.834106" r="0.500000" fill="#666666" fill-opacity="1.000000"/>
	</g>
</svg>
`, Jv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_69">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_69)">
		<path id="矢量 44" d="M3.55 10.63C3.6 10.57 3.67 10.52 3.75 10.46C3.91 10.33 4.08 10.24 4.24 10.18C4.47 10.1 4.78 10.09 4.98 10.12Q5.05 10.14 5.13 10.17Q5.47 10.31 5.71 10.68C5.78 10.78 5.83 10.89 5.86 11C5.88 11.08 5.89 11.16 5.89 11.25C5.89 11.42 5.84 11.6 5.76 11.79C5.63 12.06 5.41 12.34 5.09 12.63C5.03 12.68 4.97 12.74 4.9 12.79L5.75 12.79C5.94 12.79 6.1 12.95 6.1 13.14C6.1 13.34 5.94 13.49 5.75 13.49L3.83 13.49C3.75 13.5 3.68 13.48 3.62 13.44C3.54 13.4 3.48 13.32 3.46 13.23C3.44 13.14 3.45 13.05 3.5 12.97C3.53 12.91 3.58 12.86 3.65 12.83C3.73 12.78 3.83 12.71 3.95 12.63C4.2 12.46 4.43 12.29 4.62 12.11C4.87 11.89 5.04 11.68 5.13 11.49C5.19 11.36 5.17 11.17 5.13 11.07C5.03 10.92 4.92 10.83 4.81 10.8C4.72 10.78 4.61 10.79 4.49 10.84C4.39 10.87 4.28 10.93 4.17 11.02C4.12 11.06 4.08 11.09 4.05 11.12C3.91 11.26 3.69 11.26 3.55 11.12C3.41 10.98 3.41 10.76 3.55 10.63Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 45" d="M3.51 16.82C3.55 16.77 3.6 16.7 3.66 16.64Q3.85 16.43 4.07 16.31C4.23 16.22 4.4 16.16 4.57 16.13C4.63 16.12 4.75 16.12 4.82 16.12C5.09 16.13 5.35 16.23 5.62 16.4C5.89 16.59 6.09 16.85 6.17 17.1C6.19 17.16 6.2 17.22 6.2 17.28C6.21 17.45 6.18 17.63 6.11 17.8C6.06 17.92 5.99 18.04 5.9 18.15C5.99 18.27 6.06 18.38 6.11 18.5Q6.22 18.76 6.2 19.02L6.2 19.02C6.2 19.08 6.17 19.19 6.15 19.25C6.07 19.5 5.89 19.72 5.62 19.9C5.35 20.08 5.03 20.17 4.76 20.18Q4.66 20.18 4.57 20.17L4.57 20.17C4.4 20.15 4.23 20.09 4.07 20C3.92 19.91 3.79 19.8 3.66 19.67C3.6 19.6 3.55 19.54 3.51 19.48C3.4 19.32 3.44 19.1 3.61 19C3.77 18.89 4.06 19.03 4.17 19.19C4.25 19.27 4.33 19.34 4.42 19.39C4.51 19.44 4.6 19.47 4.7 19.48C4.87 19.5 5.04 19.44 5.23 19.32C5.38 19.22 5.47 19.12 5.49 19.02C5.51 18.95 5.5 18.87 5.46 18.78C5.43 18.69 5.37 18.61 5.3 18.52C5.29 18.51 5.29 18.51 5.28 18.5L4.77 18.5C4.58 18.5 4.42 18.35 4.42 18.15C4.42 17.96 4.58 17.8 4.77 17.8L5.28 17.8C5.28 17.79 5.29 17.79 5.3 17.78C5.37 17.7 5.43 17.61 5.46 17.53C5.5 17.44 5.51 17.36 5.49 17.29Q5.45 17.13 5.23 16.98C5.04 16.86 4.87 16.81 4.7 16.82C4.6 16.83 4.51 16.86 4.42 16.92C4.33 16.97 4.17 17.13 4.09 17.21C3.98 17.37 3.77 17.42 3.61 17.31C3.44 17.2 3.4 16.99 3.51 16.82Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 43" d="M5.12 4.19L5.12 6.73L5.75 6.73C5.94 6.73 6.1 6.88 6.1 7.08C6.1 7.27 5.94 7.43 5.75 7.43L3.8 7.43C3.6 7.43 3.45 7.27 3.45 7.08C3.45 6.88 3.6 6.73 3.8 6.73L4.42 6.73L4.42 4.81L3.99 5.1C3.83 5.21 3.62 5.16 3.51 5C3.4 4.84 3.44 4.62 3.61 4.51L4.55 3.88C4.59 3.85 4.64 3.83 4.69 3.82C4.77 3.8 4.85 3.8 4.91 3.84C5.01 3.88 5.08 3.96 5.11 4.06C5.12 4.1 5.13 4.15 5.12 4.19Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 59" d="M8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6ZM8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17ZM8.16 19.15C8.16 18.87 8.38 18.65 8.66 18.65L20.66 18.65C20.94 18.65 21.16 18.87 21.16 19.15C21.16 19.43 20.94 19.65 20.66 19.65L8.66 19.65C8.38 19.65 8.16 19.43 8.16 19.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 59" d="M8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1ZM8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67ZM8.16 19.15C8.16 19.43 8.38 19.65 8.66 19.65L20.66 19.65C20.94 19.65 21.16 19.43 21.16 19.15C21.16 18.87 20.94 18.65 20.66 18.65L8.66 18.65C8.38 18.65 8.16 18.87 8.16 19.15Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, Xv = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_25">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_25)">
		<path id="矢量 73" d="M17.66 6.1L6.33 6.1C6.24 6.1 6.15 6.1 6.07 6.12C5.99 6.14 5.92 6.16 5.85 6.19C5.78 6.22 5.71 6.26 5.65 6.3Q5.64 6.3 5.64 6.31L5.64 6.31Q5.54 6.37 5.46 6.46C5.4 6.52 5.35 6.58 5.3 6.65C5.26 6.71 5.22 6.78 5.19 6.85C5.16 6.92 5.14 6.99 5.12 7.07C5.1 7.15 5.1 7.24 5.1 7.33L5.1 16.66C5.1 16.83 5.13 16.99 5.19 17.14C5.25 17.27 5.32 17.38 5.41 17.49C5.43 17.5 5.44 17.52 5.46 17.53C5.46 17.54 5.47 17.55 5.48 17.55C5.57 17.65 5.68 17.72 5.8 17.78C5.82 17.78 5.83 17.79 5.85 17.8C6 17.86 6.16 17.89 6.33 17.89L17.66 17.89C17.83 17.89 17.99 17.86 18.14 17.8C18.29 17.74 18.42 17.65 18.53 17.53C18.65 17.42 18.73 17.29 18.8 17.14C18.86 16.99 18.89 16.83 18.89 16.66L18.89 7.33C18.89 7.24 18.89 7.15 18.87 7.07C18.85 6.99 18.83 6.92 18.8 6.85C18.73 6.7 18.65 6.57 18.53 6.46C18.47 6.4 18.41 6.35 18.34 6.3C18.28 6.26 18.21 6.22 18.14 6.19C17.99 6.13 17.83 6.1 17.66 6.1ZM17.74 14.16L17.66 7.23L6.26 7.26L6.31 13.88L8.59 11.59C8.71 11.47 8.84 11.41 8.96 11.4C9.09 11.4 9.22 11.45 9.35 11.55L10.59 12.54L12.23 10.63C12.35 10.49 12.47 10.42 12.6 10.4C12.73 10.39 12.86 10.44 13.01 10.54L17.74 14.16ZM6.33 16.76L6.32 15.47L9.04 12.75L10.31 13.77C10.45 13.88 10.59 13.93 10.72 13.92C10.85 13.91 10.97 13.83 11.09 13.7L12.74 11.77L17.75 15.6L17.76 16.66L6.33 16.76ZM9.53 9.79C9.57 9.7 9.59 9.6 9.59 9.49C9.59 9.39 9.57 9.29 9.53 9.2C9.49 9.11 9.44 9.03 9.36 8.96C9.29 8.89 9.21 8.83 9.12 8.79C9.03 8.76 8.93 8.74 8.83 8.74C8.72 8.74 8.63 8.76 8.54 8.79C8.45 8.83 8.37 8.89 8.29 8.96C8.22 9.03 8.16 9.11 8.13 9.2C8.09 9.29 8.07 9.39 8.07 9.49C8.07 9.6 8.09 9.7 8.13 9.79C8.16 9.87 8.22 9.96 8.29 10.03C8.37 10.1 8.45 10.16 8.54 10.2C8.63 10.23 8.72 10.25 8.83 10.25C8.93 10.25 9.03 10.23 9.12 10.2C9.21 10.16 9.29 10.1 9.36 10.03C9.44 9.96 9.49 9.87 9.53 9.79ZM9.05 9.4C9.05 9.41 9.05 9.43 9.06 9.45C9.06 9.5 9.06 9.57 9.05 9.59C9.03 9.61 8.95 9.71 8.92 9.72C8.91 9.72 8.9 9.72 8.88 9.72C8.83 9.72 8.76 9.73 8.74 9.72C8.71 9.7 8.62 9.62 8.6 9.59C8.6 9.58 8.6 9.56 8.6 9.54C8.6 9.49 8.59 9.42 8.6 9.4C8.63 9.38 8.71 9.28 8.74 9.27C8.74 9.27 8.76 9.27 8.78 9.27L8.78 9.27C8.83 9.27 8.9 9.26 8.92 9.27C8.95 9.28 9.03 9.38 9.05 9.4Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, ew = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_358">
			<rect id="svg" width="24.000000" height="24.000000" transform="matrix(-1 0 0 1 24 0)" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_358)">
		<path id="矢量 55" d="M17.93 6.94L16.33 5.57C16.03 5.31 15.99 4.88 16.25 4.58C16.5 4.28 16.94 4.25 17.24 4.5L20.18 7.02C20.39 7.13 20.52 7.33 20.52 7.59C20.54 7.78 20.45 7.99 20.32 8.14L17.28 11.18C17 11.46 16.56 11.46 16.29 11.18C16.01 10.91 16.01 10.47 16.29 10.2L18.14 8.34L9.82 8.34C9.55 8.34 9.28 8.37 9.01 8.41C8.65 8.47 8.3 8.58 7.96 8.72C7.73 8.82 7.5 8.93 7.29 9.06C6.97 9.25 6.68 9.48 6.4 9.75C6.13 10.01 5.89 10.3 5.68 10.61C5.54 10.82 5.42 11.04 5.31 11.27C5.16 11.6 5.04 11.94 4.97 12.3L4.97 12.3Q4.88 12.7 4.87 13.11C4.86 13.42 4.87 13.72 4.92 14.02C4.97 14.38 5.07 14.73 5.21 15.08C5.3 15.32 5.42 15.56 5.55 15.79C5.75 16.12 5.99 16.43 6.27 16.72C6.54 17 6.84 17.25 7.16 17.46C7.39 17.61 7.62 17.73 7.87 17.84C8.21 17.99 8.56 18.1 8.92 18.17C9.21 18.23 9.52 18.26 9.82 18.26L17.22 18.26C17.61 18.26 17.92 18.56 17.92 18.96C17.92 19.35 17.61 19.66 17.22 19.66L9.82 19.66C9.42 19.66 9.02 19.62 8.63 19.54C8.18 19.45 7.74 19.31 7.3 19.12C6.97 18.98 6.66 18.81 6.36 18.61C5.96 18.35 5.6 18.04 5.26 17.69C4.92 17.34 4.62 16.95 4.38 16.54C4.19 16.24 4.04 15.93 3.9 15.59C3.73 15.16 3.61 14.71 3.54 14.26C3.48 13.86 3.45 13.46 3.47 13.06C3.48 12.69 3.53 12.32 3.61 11.97C3.7 11.53 3.85 11.1 4.04 10.68C4.19 10.37 4.35 10.07 4.54 9.79C4.8 9.41 5.09 9.06 5.43 8.74C5.77 8.41 6.13 8.13 6.52 7.89C6.81 7.71 7.11 7.56 7.42 7.43C7.85 7.25 8.29 7.12 8.73 7.04C9.09 6.98 9.45 6.94 9.82 6.94L17.93 6.94Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, tw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip216_120">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip216_120)">
		<path id="矢量 14" d="M10.42 11.62L5.53 11.62C5.5 11.62 5.46 11.62 5.43 11.61C5.4 11.61 5.37 11.61 5.34 11.6C5.31 11.59 5.28 11.59 5.25 11.58C5.22 11.57 5.19 11.56 5.16 11.54C5.13 11.53 5.1 11.52 5.07 11.5C5.04 11.49 5.02 11.47 4.99 11.45C4.96 11.44 4.94 11.42 4.91 11.4C4.89 11.38 4.87 11.35 4.85 11.33C4.82 11.31 4.8 11.28 4.78 11.26C4.76 11.24 4.75 11.21 4.73 11.18C4.71 11.16 4.7 11.13 4.68 11.1C4.67 11.07 4.66 11.04 4.64 11.01C4.63 10.99 4.62 10.96 4.62 10.92C4.61 10.89 4.6 10.86 4.6 10.83C4.59 10.8 4.59 10.77 4.59 10.74C4.59 10.71 4.59 10.68 4.59 10.65L4.59 5.81C4.59 5.75 4.59 5.69 4.6 5.63C4.62 5.57 4.63 5.51 4.66 5.46C4.68 5.4 4.71 5.35 4.75 5.3C4.78 5.25 4.82 5.2 4.86 5.16C4.91 5.11 4.95 5.07 5 5.04C5.06 5.01 5.11 4.98 5.17 4.95C5.22 4.93 5.28 4.91 5.34 4.9C5.4 4.89 5.47 4.88 5.53 4.88L10.42 4.88C10.45 4.88 10.48 4.88 10.51 4.88C10.55 4.89 10.58 4.89 10.61 4.89C10.64 4.9 10.67 4.9 10.7 4.91C10.73 4.92 10.76 4.93 10.79 4.94C10.82 4.95 10.85 4.96 10.88 4.98C10.91 4.99 10.94 5.01 10.96 5.02C10.99 5.04 11.02 5.06 11.04 5.08C11.07 5.1 11.09 5.12 11.12 5.14C11.14 5.16 11.16 5.18 11.18 5.21C11.2 5.23 11.22 5.26 11.24 5.28C11.26 5.31 11.27 5.33 11.29 5.36C11.3 5.39 11.32 5.42 11.33 5.45C11.34 5.47 11.35 5.5 11.36 5.53C11.37 5.56 11.38 5.59 11.39 5.62C11.39 5.66 11.4 5.69 11.4 5.72C11.41 5.75 11.41 5.78 11.41 5.81L11.41 10.65C11.41 10.68 11.41 10.71 11.41 10.74C11.41 10.77 11.4 10.81 11.4 10.84C11.39 10.87 11.38 10.9 11.38 10.93C11.37 10.96 11.36 11 11.35 11.03C11.33 11.06 11.32 11.09 11.31 11.11C11.29 11.14 11.27 11.17 11.26 11.2C11.24 11.23 11.22 11.25 11.2 11.28C11.18 11.3 11.16 11.33 11.13 11.35C11.11 11.37 11.09 11.39 11.06 11.41C11.03 11.43 11.01 11.45 10.98 11.47C10.95 11.49 10.92 11.5 10.9 11.52C10.87 11.53 10.84 11.55 10.81 11.56C10.77 11.57 10.74 11.58 10.71 11.59C10.68 11.6 10.65 11.6 10.62 11.61C10.58 11.61 10.55 11.62 10.52 11.62C10.48 11.62 10.45 11.62 10.42 11.62ZM10.42 5.81L5.57 5.81L5.63 10.6L10.42 10.6L10.42 5.81ZM15.73 11.86C15.61 11.86 15.48 11.84 15.36 11.79C15.24 11.74 15.14 11.67 15.05 11.58L12.33 8.9C12.31 8.88 12.28 8.86 12.26 8.83C12.24 8.81 12.22 8.78 12.2 8.76C12.19 8.73 12.17 8.71 12.15 8.68C12.14 8.65 12.13 8.62 12.11 8.59C12.1 8.57 12.09 8.54 12.08 8.51C12.07 8.48 12.06 8.45 12.06 8.42C12.05 8.38 12.04 8.35 12.04 8.32C12.04 8.29 12.04 8.26 12.04 8.23C12.04 8.2 12.04 8.17 12.04 8.13C12.04 8.1 12.05 8.07 12.06 8.04C12.06 8.01 12.07 7.98 12.08 7.95C12.09 7.92 12.1 7.89 12.11 7.86C12.13 7.83 12.14 7.81 12.15 7.78C12.17 7.75 12.19 7.72 12.2 7.7C12.22 7.67 12.24 7.65 12.26 7.62C12.28 7.6 12.31 7.58 12.33 7.56L15.04 4.87C15.06 4.85 15.08 4.83 15.11 4.81C15.13 4.79 15.16 4.77 15.18 4.75C15.21 4.73 15.24 4.72 15.26 4.7C15.29 4.69 15.32 4.67 15.35 4.66C15.38 4.65 15.41 4.64 15.44 4.63C15.47 4.62 15.5 4.61 15.53 4.6C15.56 4.6 15.59 4.59 15.63 4.59C15.66 4.59 15.69 4.59 15.72 4.59C15.75 4.59 15.78 4.59 15.82 4.59C15.85 4.59 15.88 4.6 15.91 4.6C15.94 4.61 15.97 4.62 16 4.63C16.03 4.64 16.06 4.65 16.09 4.66C16.12 4.67 16.15 4.69 16.18 4.7C16.2 4.72 16.23 4.73 16.26 4.75C16.28 4.77 16.31 4.79 16.33 4.81C16.36 4.83 16.38 4.85 16.4 4.87L19.11 7.56C19.13 7.58 19.16 7.6 19.18 7.62C19.2 7.65 19.22 7.67 19.24 7.7C19.25 7.72 19.27 7.75 19.29 7.78C19.3 7.81 19.32 7.83 19.33 7.86C19.34 7.89 19.35 7.92 19.36 7.95C19.37 7.98 19.38 8.01 19.39 8.04C19.39 8.07 19.4 8.1 19.4 8.13C19.4 8.17 19.4 8.2 19.4 8.23C19.4 8.26 19.4 8.29 19.4 8.32C19.4 8.35 19.39 8.38 19.39 8.42C19.38 8.45 19.37 8.48 19.36 8.51C19.35 8.54 19.34 8.57 19.33 8.59C19.32 8.62 19.3 8.65 19.29 8.68C19.27 8.71 19.25 8.73 19.24 8.76C19.22 8.78 19.2 8.81 19.18 8.83C19.16 8.86 19.13 8.88 19.11 8.9L16.4 11.58C16.31 11.67 16.21 11.74 16.1 11.79C15.98 11.84 15.86 11.86 15.73 11.86ZM13.11 8.27L15.73 10.81L18.34 8.27L15.73 5.64L13.11 8.27ZM10.42 19.4L5.53 19.4C5.5 19.4 5.46 19.4 5.43 19.4C5.4 19.4 5.37 19.39 5.34 19.38C5.31 19.38 5.28 19.37 5.25 19.36C5.22 19.35 5.19 19.34 5.16 19.33C5.13 19.32 5.1 19.3 5.07 19.29C5.04 19.27 5.02 19.26 4.99 19.24C4.96 19.22 4.94 19.2 4.91 19.18C4.89 19.16 4.87 19.14 4.85 19.12C4.82 19.09 4.8 19.07 4.78 19.04C4.76 19.02 4.75 18.99 4.73 18.97C4.71 18.94 4.7 18.91 4.68 18.88C4.67 18.86 4.66 18.83 4.64 18.8C4.63 18.77 4.62 18.74 4.62 18.71C4.61 18.68 4.6 18.65 4.6 18.62C4.59 18.59 4.59 18.55 4.59 18.52C4.59 18.49 4.59 18.46 4.59 18.43L4.59 13.56C4.59 13.5 4.59 13.44 4.6 13.38C4.62 13.32 4.63 13.26 4.66 13.2C4.68 13.15 4.71 13.09 4.75 13.04C4.78 12.99 4.82 12.95 4.86 12.9C4.91 12.86 4.95 12.82 5 12.79C5.06 12.75 5.11 12.72 5.17 12.7C5.22 12.68 5.28 12.66 5.34 12.65C5.4 12.64 5.47 12.63 5.53 12.63L10.42 12.63C10.45 12.63 10.48 12.63 10.51 12.63C10.55 12.63 10.58 12.64 10.61 12.64C10.64 12.64 10.67 12.65 10.7 12.66C10.73 12.67 10.76 12.68 10.79 12.69C10.82 12.7 10.85 12.71 10.88 12.72C10.91 12.74 10.94 12.75 10.96 12.77C10.99 12.79 11.02 12.8 11.04 12.82C11.07 12.84 11.09 12.86 11.12 12.89C11.14 12.91 11.16 12.93 11.18 12.95C11.2 12.98 11.22 13 11.24 13.03C11.26 13.05 11.27 13.08 11.29 13.11C11.3 13.14 11.32 13.16 11.33 13.19C11.34 13.22 11.35 13.25 11.36 13.28C11.37 13.31 11.38 13.34 11.39 13.37C11.39 13.4 11.4 13.43 11.4 13.46C11.41 13.5 11.41 13.53 11.41 13.56L11.41 18.39C11.41 18.42 11.41 18.46 11.41 18.49C11.41 18.52 11.41 18.56 11.4 18.59C11.4 18.62 11.39 18.66 11.39 18.69C11.38 18.72 11.37 18.75 11.36 18.78C11.35 18.82 11.33 18.85 11.32 18.88C11.31 18.91 11.29 18.93 11.27 18.96C11.25 18.99 11.23 19.02 11.21 19.04C11.19 19.07 11.17 19.1 11.15 19.12C11.12 19.14 11.1 19.17 11.07 19.19C11.05 19.21 11.02 19.23 10.99 19.25C10.97 19.27 10.94 19.28 10.91 19.3C10.88 19.31 10.85 19.33 10.81 19.34C10.78 19.35 10.75 19.36 10.72 19.37C10.69 19.38 10.65 19.39 10.62 19.39C10.59 19.4 10.55 19.4 10.52 19.4C10.49 19.4 10.45 19.4 10.42 19.4ZM10.42 13.6L5.57 13.64L5.63 18.43L10.42 18.38L10.42 13.6ZM18.17 19.4L13.27 19.4C13.24 19.4 13.21 19.4 13.17 19.4C13.14 19.4 13.11 19.39 13.08 19.38C13.05 19.38 13.02 19.37 12.99 19.36C12.96 19.35 12.93 19.34 12.9 19.33C12.87 19.32 12.84 19.3 12.81 19.29C12.79 19.27 12.76 19.26 12.73 19.24C12.71 19.22 12.68 19.2 12.66 19.18C12.63 19.16 12.61 19.14 12.59 19.12C12.57 19.09 12.54 19.07 12.53 19.04C12.51 19.02 12.49 18.99 12.47 18.97C12.45 18.94 12.44 18.91 12.42 18.88C12.41 18.86 12.4 18.83 12.39 18.8C12.38 18.77 12.37 18.74 12.36 18.71C12.35 18.68 12.34 18.65 12.34 18.62C12.33 18.59 12.33 18.55 12.33 18.52C12.33 18.49 12.33 18.46 12.33 18.43L12.33 13.56C12.33 13.5 12.34 13.44 12.35 13.38C12.36 13.32 12.38 13.26 12.4 13.2C12.42 13.15 12.45 13.09 12.49 13.04C12.52 12.99 12.56 12.95 12.6 12.9C12.65 12.86 12.7 12.82 12.75 12.79C12.8 12.75 12.85 12.72 12.91 12.7C12.97 12.68 13.03 12.66 13.09 12.65C13.15 12.64 13.21 12.63 13.27 12.63L18.17 12.63C18.23 12.63 18.29 12.64 18.35 12.65C18.41 12.66 18.47 12.68 18.53 12.7C18.59 12.72 18.64 12.75 18.69 12.79C18.74 12.82 18.79 12.86 18.84 12.9C18.88 12.95 18.92 12.99 18.95 13.04C18.99 13.09 19.02 13.15 19.04 13.2C19.06 13.26 19.08 13.32 19.09 13.38C19.11 13.44 19.11 13.5 19.11 13.56L19.11 18.39C19.11 18.42 19.12 18.46 19.12 18.49C19.11 18.52 19.11 18.55 19.11 18.58C19.1 18.62 19.1 18.65 19.09 18.68C19.09 18.71 19.08 18.74 19.07 18.77C19.06 18.8 19.04 18.83 19.03 18.86C19.02 18.89 19 18.92 18.98 18.95C18.97 18.98 18.95 19 18.93 19.03C18.91 19.05 18.89 19.08 18.87 19.1C18.85 19.13 18.82 19.15 18.8 19.17C18.77 19.19 18.75 19.21 18.72 19.23C18.69 19.25 18.67 19.27 18.64 19.28C18.61 19.3 18.58 19.31 18.55 19.33C18.52 19.34 18.49 19.35 18.46 19.36C18.43 19.37 18.4 19.38 18.37 19.38C18.33 19.39 18.3 19.4 18.27 19.4C18.24 19.4 18.2 19.4 18.17 19.4ZM18.11 13.56L13.27 13.6L13.33 18.39L18.11 18.35L18.11 13.56Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
		<path id="矢量 14" d="M5.53 11.62C5.5 11.62 5.46 11.62 5.43 11.61C5.4 11.61 5.37 11.61 5.34 11.6C5.31 11.59 5.28 11.59 5.25 11.58C5.22 11.57 5.19 11.56 5.16 11.54C5.13 11.53 5.1 11.52 5.07 11.5C5.04 11.49 5.02 11.47 4.99 11.45C4.96 11.44 4.94 11.42 4.91 11.4C4.89 11.38 4.87 11.35 4.85 11.33C4.82 11.31 4.8 11.28 4.78 11.26C4.76 11.24 4.75 11.21 4.73 11.18C4.71 11.16 4.7 11.13 4.68 11.1C4.67 11.07 4.66 11.04 4.64 11.01C4.63 10.99 4.62 10.96 4.62 10.92C4.61 10.89 4.6 10.86 4.6 10.83C4.59 10.8 4.59 10.77 4.59 10.74C4.59 10.71 4.59 10.68 4.59 10.65L4.59 5.81C4.59 5.75 4.59 5.69 4.6 5.63C4.62 5.57 4.63 5.51 4.66 5.46C4.68 5.4 4.71 5.35 4.75 5.3C4.78 5.25 4.82 5.2 4.86 5.16C4.91 5.11 4.95 5.07 5 5.04C5.06 5.01 5.11 4.98 5.17 4.95C5.22 4.93 5.28 4.91 5.34 4.9C5.4 4.89 5.47 4.88 5.53 4.88L10.42 4.88C10.45 4.88 10.48 4.88 10.51 4.88C10.55 4.89 10.58 4.89 10.61 4.89C10.64 4.9 10.67 4.9 10.7 4.91C10.73 4.92 10.76 4.93 10.79 4.94C10.82 4.95 10.85 4.96 10.88 4.98C10.91 4.99 10.94 5.01 10.96 5.02C10.99 5.04 11.02 5.06 11.04 5.08C11.07 5.1 11.09 5.12 11.12 5.14C11.14 5.16 11.16 5.18 11.18 5.21C11.2 5.23 11.22 5.26 11.24 5.28C11.26 5.31 11.27 5.33 11.29 5.36C11.3 5.39 11.32 5.42 11.33 5.45C11.34 5.47 11.35 5.5 11.36 5.53C11.37 5.56 11.38 5.59 11.39 5.62C11.39 5.66 11.4 5.69 11.4 5.72C11.41 5.75 11.41 5.78 11.41 5.81L11.41 10.65C11.41 10.68 11.41 10.71 11.41 10.74C11.41 10.77 11.4 10.81 11.4 10.84C11.39 10.87 11.38 10.9 11.38 10.93C11.37 10.96 11.36 11 11.35 11.03C11.33 11.06 11.32 11.09 11.31 11.11C11.29 11.14 11.27 11.17 11.26 11.2C11.24 11.23 11.22 11.25 11.2 11.28C11.18 11.3 11.16 11.33 11.13 11.35C11.11 11.37 11.09 11.39 11.06 11.41C11.03 11.43 11.01 11.45 10.98 11.47C10.95 11.49 10.92 11.5 10.9 11.52C10.87 11.53 10.84 11.55 10.81 11.56C10.77 11.57 10.74 11.58 10.71 11.59C10.68 11.6 10.65 11.6 10.62 11.61C10.58 11.61 10.55 11.62 10.52 11.62C10.48 11.62 10.45 11.62 10.42 11.62L5.53 11.62ZM5.57 5.81L5.63 10.6L10.42 10.6L10.42 5.81L5.57 5.81ZM15.36 11.79C15.24 11.74 15.14 11.67 15.05 11.58L12.33 8.9C12.31 8.88 12.28 8.86 12.26 8.83C12.24 8.81 12.22 8.78 12.2 8.76C12.19 8.73 12.17 8.71 12.15 8.68C12.14 8.65 12.13 8.62 12.11 8.59C12.1 8.57 12.09 8.54 12.08 8.51C12.07 8.48 12.06 8.45 12.06 8.42C12.05 8.38 12.04 8.35 12.04 8.32C12.04 8.29 12.04 8.26 12.04 8.23C12.04 8.2 12.04 8.17 12.04 8.13C12.04 8.1 12.05 8.07 12.06 8.04C12.06 8.01 12.07 7.98 12.08 7.95C12.09 7.92 12.1 7.89 12.11 7.86C12.13 7.83 12.14 7.81 12.15 7.78C12.17 7.75 12.19 7.72 12.2 7.7C12.22 7.67 12.24 7.65 12.26 7.62C12.28 7.6 12.31 7.58 12.33 7.56L15.04 4.87C15.06 4.85 15.08 4.83 15.11 4.81C15.13 4.79 15.16 4.77 15.18 4.75C15.21 4.73 15.24 4.72 15.26 4.7C15.29 4.69 15.32 4.67 15.35 4.66C15.38 4.65 15.41 4.64 15.44 4.63C15.47 4.62 15.5 4.61 15.53 4.6C15.56 4.6 15.59 4.59 15.63 4.59C15.66 4.59 15.69 4.59 15.72 4.59C15.75 4.59 15.78 4.59 15.82 4.59C15.85 4.59 15.88 4.6 15.91 4.6C15.94 4.61 15.97 4.62 16 4.63C16.03 4.64 16.06 4.65 16.09 4.66C16.12 4.67 16.15 4.69 16.18 4.7C16.2 4.72 16.23 4.73 16.26 4.75C16.28 4.77 16.31 4.79 16.33 4.81C16.36 4.83 16.38 4.85 16.4 4.87L19.11 7.56C19.13 7.58 19.16 7.6 19.18 7.62C19.2 7.65 19.22 7.67 19.24 7.7C19.25 7.72 19.27 7.75 19.29 7.78C19.3 7.81 19.32 7.83 19.33 7.86C19.34 7.89 19.35 7.92 19.36 7.95C19.37 7.98 19.38 8.01 19.39 8.04C19.39 8.07 19.4 8.1 19.4 8.13C19.4 8.17 19.4 8.2 19.4 8.23C19.4 8.26 19.4 8.29 19.4 8.32C19.4 8.35 19.39 8.38 19.39 8.42C19.38 8.45 19.37 8.48 19.36 8.51C19.35 8.54 19.34 8.57 19.33 8.59C19.32 8.62 19.3 8.65 19.29 8.68C19.27 8.71 19.25 8.73 19.24 8.76C19.22 8.78 19.2 8.81 19.18 8.83C19.16 8.86 19.13 8.88 19.11 8.9L16.4 11.58C16.31 11.67 16.21 11.74 16.1 11.79C15.98 11.84 15.86 11.86 15.73 11.86C15.61 11.86 15.48 11.84 15.36 11.79ZM15.73 10.81L18.34 8.27L15.73 5.64L13.11 8.27L15.73 10.81ZM5.53 19.4C5.5 19.4 5.46 19.4 5.43 19.4C5.4 19.4 5.37 19.39 5.34 19.38C5.31 19.38 5.28 19.37 5.25 19.36C5.22 19.35 5.19 19.34 5.16 19.33C5.13 19.32 5.1 19.3 5.07 19.29C5.04 19.27 5.02 19.26 4.99 19.24C4.96 19.22 4.94 19.2 4.91 19.18C4.89 19.16 4.87 19.14 4.85 19.12C4.82 19.09 4.8 19.07 4.78 19.04C4.76 19.02 4.75 18.99 4.73 18.97C4.71 18.94 4.7 18.91 4.68 18.88C4.67 18.86 4.66 18.83 4.64 18.8C4.63 18.77 4.62 18.74 4.62 18.71C4.61 18.68 4.6 18.65 4.6 18.62C4.59 18.59 4.59 18.55 4.59 18.52C4.59 18.49 4.59 18.46 4.59 18.43L4.59 13.56C4.59 13.5 4.59 13.44 4.6 13.38C4.62 13.32 4.63 13.26 4.66 13.2C4.68 13.15 4.71 13.09 4.75 13.04C4.78 12.99 4.82 12.95 4.86 12.9C4.91 12.86 4.95 12.82 5 12.79C5.06 12.75 5.11 12.72 5.17 12.7C5.22 12.68 5.28 12.66 5.34 12.65C5.4 12.64 5.47 12.63 5.53 12.63L10.42 12.63C10.45 12.63 10.48 12.63 10.51 12.63C10.55 12.63 10.58 12.64 10.61 12.64C10.64 12.64 10.67 12.65 10.7 12.66C10.73 12.67 10.76 12.68 10.79 12.69C10.82 12.7 10.85 12.71 10.88 12.72C10.91 12.74 10.94 12.75 10.96 12.77C10.99 12.79 11.02 12.8 11.04 12.82C11.07 12.84 11.09 12.86 11.12 12.89C11.14 12.91 11.16 12.93 11.18 12.95C11.2 12.98 11.22 13 11.24 13.03C11.26 13.05 11.27 13.08 11.29 13.11C11.3 13.14 11.32 13.16 11.33 13.19C11.34 13.22 11.35 13.25 11.36 13.28C11.37 13.31 11.38 13.34 11.39 13.37C11.39 13.4 11.4 13.43 11.4 13.46C11.41 13.5 11.41 13.53 11.41 13.56L11.41 18.39C11.41 18.42 11.41 18.46 11.41 18.49C11.41 18.52 11.41 18.56 11.4 18.59C11.4 18.62 11.39 18.66 11.39 18.69C11.38 18.72 11.37 18.75 11.36 18.78C11.35 18.82 11.33 18.85 11.32 18.88C11.31 18.91 11.29 18.93 11.27 18.96C11.25 18.99 11.23 19.02 11.21 19.04C11.19 19.07 11.17 19.1 11.15 19.12C11.12 19.14 11.1 19.17 11.07 19.19C11.05 19.21 11.02 19.23 10.99 19.25C10.97 19.27 10.94 19.28 10.91 19.3C10.88 19.31 10.85 19.33 10.81 19.34C10.78 19.35 10.75 19.36 10.72 19.37C10.69 19.38 10.65 19.39 10.62 19.39C10.59 19.4 10.55 19.4 10.52 19.4C10.49 19.4 10.45 19.4 10.42 19.4L5.53 19.4ZM5.57 13.64L5.63 18.43L10.42 18.38L10.42 13.6L5.57 13.64ZM13.27 19.4C13.24 19.4 13.21 19.4 13.17 19.4C13.14 19.4 13.11 19.39 13.08 19.38C13.05 19.38 13.02 19.37 12.99 19.36C12.96 19.35 12.93 19.34 12.9 19.33C12.87 19.32 12.84 19.3 12.81 19.29C12.79 19.27 12.76 19.26 12.73 19.24C12.71 19.22 12.68 19.2 12.66 19.18C12.63 19.16 12.61 19.14 12.59 19.12C12.57 19.09 12.54 19.07 12.53 19.04C12.51 19.02 12.49 18.99 12.47 18.97C12.45 18.94 12.44 18.91 12.42 18.88C12.41 18.86 12.4 18.83 12.39 18.8C12.38 18.77 12.37 18.74 12.36 18.71C12.35 18.68 12.34 18.65 12.34 18.62C12.33 18.59 12.33 18.55 12.33 18.52C12.33 18.49 12.33 18.46 12.33 18.43L12.33 13.56C12.33 13.5 12.34 13.44 12.35 13.38C12.36 13.32 12.38 13.26 12.4 13.2C12.42 13.15 12.45 13.09 12.49 13.04C12.52 12.99 12.56 12.95 12.6 12.9C12.65 12.86 12.7 12.82 12.75 12.79C12.8 12.75 12.85 12.72 12.91 12.7C12.97 12.68 13.03 12.66 13.09 12.65C13.15 12.64 13.21 12.63 13.27 12.63L18.17 12.63C18.23 12.63 18.29 12.64 18.35 12.65C18.41 12.66 18.47 12.68 18.53 12.7C18.59 12.72 18.64 12.75 18.69 12.79C18.74 12.82 18.79 12.86 18.84 12.9C18.88 12.95 18.92 12.99 18.95 13.04C18.99 13.09 19.02 13.15 19.04 13.2C19.06 13.26 19.08 13.32 19.09 13.38C19.11 13.44 19.11 13.5 19.11 13.56L19.11 18.39C19.11 18.42 19.12 18.46 19.12 18.49C19.11 18.52 19.11 18.55 19.11 18.58C19.1 18.62 19.1 18.65 19.09 18.68C19.09 18.71 19.08 18.74 19.07 18.77C19.06 18.8 19.04 18.83 19.03 18.86C19.02 18.89 19 18.92 18.98 18.95C18.97 18.98 18.95 19 18.93 19.03C18.91 19.05 18.89 19.08 18.87 19.1C18.85 19.13 18.82 19.15 18.8 19.17C18.77 19.19 18.75 19.21 18.72 19.23C18.69 19.25 18.67 19.27 18.64 19.28C18.61 19.3 18.58 19.31 18.55 19.33C18.52 19.34 18.49 19.35 18.46 19.36C18.43 19.37 18.4 19.38 18.37 19.38C18.33 19.39 18.3 19.4 18.27 19.4C18.24 19.4 18.2 19.4 18.17 19.4L13.27 19.4ZM13.27 13.6L13.33 18.39L18.11 18.35L18.11 13.56L13.27 13.6Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.300000"/>
	</g>
</svg>
`, nw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_333">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_333)">
		<path id="矢量 49" d="M4.99 12L19 12M12 12C17.89 14.21 15.68 19.37 12 19.37C8.31 19.37 7.57 16.42 7.57 16.42M16.42 7.57C16.42 7.57 15.31 4.62 12 4.62C8.68 4.62 7.37 7.43 8.9 9.78" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.400000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, rw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_55">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_55)">
		<path id="path" d="M19.13 18.47L17.57 18.47C17.4 18.47 17.29 18.44 17.25 18.39C17.21 18.34 17.22 18.24 17.29 18.11C17.43 17.78 17.95 17.2 18.85 16.37C19.26 16 19.45 15.52 19.41 14.94C19.4 14.53 19.25 14.2 18.98 13.94C18.69 13.66 18.31 13.51 17.83 13.49C17.25 13.47 16.79 13.62 16.44 13.95C16.1 14.26 15.93 14.66 15.94 15.15C15.94 15.29 15.99 15.39 16.1 15.47C16.21 15.54 16.33 15.57 16.45 15.57C16.71 15.57 16.84 15.46 16.85 15.25C16.9 14.71 17.17 14.42 17.65 14.38C17.75 14.37 17.86 14.38 17.96 14.4C18.06 14.43 18.16 14.48 18.24 14.54C18.32 14.59 18.38 14.67 18.43 14.75C18.47 14.84 18.49 14.93 18.49 15.03C18.5 15.33 18.29 15.69 17.87 16.08C17.33 16.56 16.92 16.99 16.64 17.38C16.38 17.73 16.19 18.1 16.07 18.52C16.05 18.59 16.03 18.77 16.02 19.06C16.01 19.14 16.05 19.21 16.13 19.27C16.21 19.33 16.3 19.36 16.41 19.36L19.13 19.36C19.26 19.36 19.37 19.32 19.44 19.24C19.53 19.15 19.57 19.04 19.56 18.91C19.55 18.61 19.41 18.47 19.13 18.47ZM4.64 7.44C4.67 7.42 4.7 7.4 4.74 7.38C4.77 7.36 4.81 7.34 4.85 7.33C4.88 7.32 4.92 7.31 4.96 7.31C5 7.3 5.04 7.3 5.08 7.31C5.12 7.31 5.16 7.32 5.19 7.33C5.23 7.34 5.27 7.35 5.3 7.37C5.34 7.39 5.37 7.41 5.4 7.44C5.43 7.46 5.46 7.49 5.49 7.52L9.21 11.96L12.86 7.61C12.89 7.58 12.91 7.55 12.94 7.53C12.97 7.5 13.01 7.48 13.04 7.46C13.08 7.45 13.11 7.43 13.15 7.42C13.19 7.41 13.23 7.4 13.27 7.4C13.31 7.39 13.34 7.4 13.38 7.4C13.42 7.4 13.46 7.41 13.5 7.42C13.54 7.44 13.57 7.45 13.61 7.47C13.64 7.49 13.67 7.51 13.7 7.54C13.73 7.56 13.76 7.59 13.79 7.62C13.81 7.65 13.83 7.68 13.85 7.72C13.87 7.75 13.88 7.79 13.89 7.83C13.9 7.87 13.91 7.9 13.92 7.94C13.92 7.98 13.92 8.02 13.91 8.06C13.91 8.1 13.9 8.14 13.89 8.18C13.88 8.21 13.86 8.25 13.84 8.28C13.82 8.32 13.8 8.35 13.78 8.38L9.99 12.89L13.78 17.4C13.8 17.43 13.82 17.46 13.84 17.5C13.86 17.53 13.88 17.57 13.89 17.6C13.9 17.64 13.91 17.68 13.91 17.72C13.92 17.76 13.92 17.8 13.92 17.84C13.91 17.88 13.9 17.91 13.89 17.95C13.88 17.99 13.87 18.03 13.85 18.06C13.83 18.1 13.81 18.13 13.79 18.16C13.76 18.19 13.73 18.22 13.7 18.24C13.67 18.27 13.64 18.29 13.61 18.31C13.57 18.33 13.54 18.34 13.5 18.36C13.46 18.37 13.42 18.38 13.38 18.38C13.34 18.38 13.31 18.38 13.27 18.38C13.23 18.38 13.19 18.37 13.15 18.36C13.11 18.35 13.08 18.33 13.04 18.32C13.01 18.3 12.97 18.28 12.94 18.25C12.91 18.23 12.89 18.2 12.86 18.17L9.21 13.82L5.49 18.26C5.46 18.29 5.43 18.32 5.4 18.34C5.37 18.37 5.34 18.39 5.3 18.41C5.27 18.43 5.23 18.44 5.19 18.45C5.16 18.46 5.12 18.47 5.08 18.47C5.04 18.48 5 18.48 4.96 18.47C4.92 18.47 4.88 18.46 4.85 18.45C4.81 18.44 4.77 18.42 4.74 18.4C4.7 18.38 4.67 18.36 4.64 18.34C4.61 18.31 4.58 18.28 4.56 18.25C4.53 18.22 4.51 18.19 4.5 18.15C4.48 18.12 4.46 18.08 4.45 18.04C4.44 18.01 4.43 17.97 4.43 17.93C4.43 17.89 4.43 17.85 4.43 17.81C4.44 17.77 4.44 17.73 4.46 17.7C4.47 17.66 4.48 17.62 4.5 17.59C4.52 17.55 4.54 17.52 4.57 17.49L8.43 12.89L4.57 8.29C4.54 8.26 4.52 8.23 4.5 8.19C4.48 8.16 4.47 8.12 4.46 8.08C4.44 8.05 4.44 8.01 4.43 7.97C4.43 7.93 4.43 7.89 4.43 7.85C4.43 7.81 4.44 7.77 4.45 7.74C4.46 7.7 4.48 7.66 4.5 7.63C4.51 7.59 4.53 7.56 4.56 7.53C4.58 7.5 4.61 7.47 4.64 7.44Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
	</g>
</svg>
`, iw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_52">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_52)">
		<path id="path" d="M19.13 10.47L17.57 10.47C17.4 10.47 17.29 10.44 17.25 10.39C17.21 10.34 17.22 10.24 17.29 10.11C17.43 9.78 17.95 9.2 18.85 8.37C19.26 8 19.45 7.52 19.41 6.94C19.4 6.53 19.25 6.2 18.98 5.94C18.69 5.66 18.31 5.51 17.83 5.49C17.25 5.47 16.79 5.62 16.44 5.95C16.1 6.26 15.93 6.66 15.94 7.15C15.94 7.29 15.99 7.39 16.1 7.47C16.21 7.54 16.33 7.57 16.45 7.57C16.71 7.57 16.84 7.46 16.85 7.25C16.9 6.7 17.17 6.42 17.65 6.38C17.75 6.37 17.86 6.38 17.96 6.4C18.06 6.43 18.16 6.47 18.24 6.54C18.32 6.59 18.38 6.66 18.43 6.75C18.47 6.84 18.49 6.93 18.49 7.03C18.5 7.33 18.29 7.69 17.87 8.08C17.33 8.56 16.92 8.99 16.64 9.38C16.38 9.73 16.19 10.1 16.07 10.52C16.05 10.58 16.03 10.77 16.02 11.06C16.01 11.14 16.05 11.21 16.13 11.27C16.21 11.33 16.3 11.36 16.41 11.36L19.13 11.36C19.26 11.36 19.37 11.32 19.44 11.24C19.53 11.15 19.57 11.04 19.56 10.91C19.55 10.61 19.41 10.47 19.13 10.47ZM4.64 7.44C4.67 7.42 4.7 7.4 4.74 7.38C4.77 7.36 4.81 7.34 4.85 7.33C4.88 7.32 4.92 7.31 4.96 7.31C5 7.3 5.04 7.3 5.08 7.31C5.12 7.31 5.16 7.32 5.19 7.33C5.23 7.34 5.27 7.35 5.3 7.37C5.34 7.39 5.37 7.41 5.4 7.44C5.43 7.46 5.46 7.49 5.49 7.52L9.21 11.96L12.86 7.61C12.89 7.58 12.91 7.55 12.94 7.53C12.97 7.5 13.01 7.48 13.04 7.46C13.08 7.45 13.11 7.43 13.15 7.42C13.19 7.41 13.23 7.4 13.27 7.4C13.31 7.39 13.34 7.39 13.38 7.4C13.42 7.4 13.46 7.41 13.5 7.42C13.54 7.44 13.57 7.45 13.61 7.47C13.64 7.49 13.67 7.51 13.7 7.54C13.73 7.56 13.76 7.59 13.79 7.62C13.81 7.65 13.83 7.68 13.85 7.72C13.87 7.75 13.88 7.79 13.89 7.83C13.9 7.87 13.91 7.9 13.92 7.94C13.92 7.98 13.92 8.02 13.91 8.06C13.91 8.1 13.9 8.14 13.89 8.17C13.88 8.21 13.86 8.25 13.84 8.28C13.82 8.32 13.8 8.35 13.78 8.38L9.99 12.89L13.78 17.4C13.8 17.43 13.82 17.46 13.84 17.5C13.86 17.53 13.88 17.57 13.89 17.6C13.9 17.64 13.91 17.68 13.91 17.72C13.92 17.76 13.92 17.8 13.92 17.84C13.91 17.88 13.9 17.91 13.89 17.95C13.88 17.99 13.87 18.03 13.85 18.06C13.83 18.1 13.81 18.13 13.79 18.16C13.76 18.19 13.73 18.22 13.7 18.24C13.67 18.27 13.64 18.29 13.61 18.31C13.57 18.33 13.54 18.34 13.5 18.36C13.46 18.37 13.42 18.38 13.38 18.38C13.34 18.38 13.31 18.38 13.27 18.38C13.23 18.38 13.19 18.37 13.15 18.36C13.11 18.35 13.08 18.33 13.04 18.32C13.01 18.3 12.97 18.28 12.94 18.25C12.91 18.23 12.89 18.2 12.86 18.17L9.21 13.82L5.49 18.26C5.46 18.29 5.43 18.32 5.4 18.34C5.37 18.37 5.34 18.39 5.3 18.41C5.27 18.43 5.23 18.44 5.19 18.45C5.16 18.46 5.12 18.47 5.08 18.47C5.04 18.48 5 18.48 4.96 18.47C4.92 18.47 4.88 18.46 4.85 18.45C4.81 18.44 4.77 18.42 4.74 18.4C4.7 18.38 4.67 18.36 4.64 18.34C4.61 18.31 4.58 18.28 4.56 18.25C4.53 18.22 4.51 18.19 4.5 18.15C4.48 18.12 4.46 18.08 4.45 18.04C4.44 18.01 4.43 17.97 4.43 17.93C4.43 17.89 4.43 17.85 4.43 17.81C4.44 17.77 4.44 17.73 4.46 17.7C4.47 17.66 4.48 17.62 4.5 17.59C4.52 17.55 4.54 17.52 4.57 17.49L8.43 12.89L4.57 8.29C4.54 8.26 4.52 8.23 4.5 8.19C4.48 8.16 4.47 8.12 4.46 8.08C4.44 8.05 4.44 8.01 4.43 7.97C4.43 7.93 4.43 7.89 4.43 7.85C4.43 7.81 4.44 7.77 4.45 7.73C4.46 7.7 4.48 7.66 4.5 7.63C4.51 7.59 4.53 7.56 4.56 7.53C4.58 7.5 4.61 7.47 4.64 7.44Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="nonzero"/>
	</g>
</svg>
`, ow = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_13">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_13)">
		<path id="path" d="M5.21 18.12L5.19 18.14C4.8 18.14 4.49 17.83 4.49 17.44C4.49 17.05 4.8 16.74 5.19 16.74L5.21 16.76L5.21 18.12ZM18.78 16.76L18.8 16.74C19.19 16.74 19.5 17.05 19.5 17.44C19.5 17.83 19.19 18.14 18.8 18.14L18.78 18.12L18.78 16.76Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M5.19 17.44L9.96 17.44C7.69 15.95 6.55 14.14 6.55 12C6.55 8.78 8.94 6.55 12 6.55C15.06 6.55 17.44 8.93 17.44 12C17.44 14.04 16.3 15.85 14.04 17.44L18.8 17.44" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.400000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, sw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip243_19">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip243_19)">
		<path id="矢量 72" d="M17.06 5.49L6.93 5.49C6.82 5.49 6.72 5.5 6.62 5.52C6.53 5.54 6.45 5.56 6.36 5.6C6.28 5.63 6.2 5.68 6.13 5.73C6.05 5.78 5.98 5.84 5.91 5.91C5.84 5.98 5.78 6.05 5.72 6.13L5.72 6.13Q5.65 6.24 5.6 6.37C5.56 6.45 5.54 6.53 5.52 6.62C5.5 6.72 5.49 6.82 5.49 6.93L5.49 17.07C5.49 17.17 5.5 17.27 5.52 17.37C5.54 17.46 5.56 17.54 5.6 17.63C5.63 17.71 5.68 17.79 5.72 17.86C5.78 17.94 5.84 18.02 5.91 18.08C5.98 18.15 6.05 18.21 6.13 18.27C6.2 18.32 6.28 18.36 6.36 18.39C6.45 18.43 6.53 18.45 6.62 18.47C6.72 18.5 6.82 18.51 6.93 18.51L9.99 18.51C10 18.51 10 18.51 10.01 18.51C10.01 18.51 10.02 18.51 10.02 18.51L13.97 18.51C13.97 18.51 13.98 18.51 13.98 18.51C13.99 18.51 13.99 18.51 14 18.51L17.06 18.51C17.17 18.51 17.27 18.5 17.37 18.47C17.46 18.45 17.54 18.43 17.63 18.39C17.71 18.36 17.79 18.32 17.86 18.27C17.94 18.21 18.01 18.15 18.08 18.08C18.15 18.02 18.21 17.94 18.27 17.86C18.31 17.79 18.36 17.71 18.39 17.63C18.43 17.54 18.45 17.46 18.47 17.37C18.49 17.27 18.5 17.17 18.5 17.07L18.5 6.93C18.5 6.82 18.49 6.72 18.47 6.62C18.45 6.53 18.43 6.45 18.39 6.37C18.36 6.28 18.31 6.2 18.27 6.13C18.21 6.05 18.15 5.98 18.08 5.91C18.01 5.84 17.94 5.78 17.86 5.73C17.79 5.68 17.71 5.63 17.63 5.6C17.54 5.56 17.46 5.54 17.37 5.52C17.27 5.5 17.17 5.49 17.06 5.49ZM17.41 13.44L17.41 10.55L14.53 10.55L14.53 13.44L17.41 13.44ZM14.53 14.53L17.41 14.53L17.41 17.07C17.41 17.11 17.4 17.16 17.39 17.2C17.37 17.24 17.35 17.28 17.31 17.31C17.28 17.35 17.24 17.37 17.2 17.39L17.2 17.39L17.2 17.39Q17.14 17.41 17.06 17.41L14.53 17.41L14.53 14.53ZM13.44 13.44L13.44 10.55L10.55 10.55L10.55 13.44L13.44 13.44ZM10.55 14.53L13.44 14.53L13.44 17.41L10.55 17.41L10.55 14.53ZM9.46 13.44L9.46 10.55L6.58 10.55L6.58 13.44L9.46 13.44ZM6.58 14.53L9.46 14.53L9.46 17.41L6.93 17.41Q6.85 17.41 6.79 17.39L6.79 17.39C6.75 17.37 6.71 17.35 6.68 17.31C6.64 17.28 6.62 17.24 6.6 17.2C6.59 17.16 6.58 17.11 6.58 17.07L6.58 14.53ZM6.58 9.46L9.46 9.46L9.46 6.58L6.93 6.58Q6.85 6.58 6.79 6.6L6.79 6.6L6.79 6.6C6.75 6.62 6.71 6.65 6.68 6.68C6.64 6.71 6.62 6.75 6.6 6.79C6.59 6.83 6.58 6.88 6.58 6.93L6.58 9.46ZM10.55 9.46L13.44 9.46L13.44 6.58L10.55 6.58L10.55 9.46ZM14.53 9.46L17.41 9.46L17.41 6.93C17.41 6.88 17.4 6.83 17.39 6.79C17.37 6.75 17.35 6.71 17.31 6.68C17.28 6.65 17.24 6.62 17.2 6.6L17.2 6.6L17.2 6.6Q17.14 6.58 17.06 6.58L14.53 6.58L14.53 9.46Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, aw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_102">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_102)">
		<path id="矢量 61" d="M8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6ZM8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17ZM8.16 19.15C8.16 18.87 8.38 18.65 8.66 18.65L20.66 18.65C20.94 18.65 21.16 18.87 21.16 19.15C21.16 19.43 20.94 19.65 20.66 19.65L8.66 19.65C8.38 19.65 8.16 19.43 8.16 19.15Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 61" d="M8.16 6.1C8.16 6.38 8.38 6.6 8.66 6.6L20.66 6.6C20.94 6.6 21.16 6.38 21.16 6.1C21.16 5.82 20.94 5.6 20.66 5.6L8.66 5.6C8.38 5.6 8.16 5.82 8.16 6.1ZM8.16 12.67C8.16 12.95 8.38 13.17 8.66 13.17L20.66 13.17C20.94 13.17 21.16 12.95 21.16 12.67C21.16 12.39 20.94 12.17 20.66 12.17L8.66 12.17C8.38 12.17 8.16 12.39 8.16 12.67ZM8.16 19.15C8.16 19.43 8.38 19.65 8.66 19.65L20.66 19.65C20.94 19.65 21.16 19.43 21.16 19.15C21.16 18.87 20.94 18.65 20.66 18.65L8.66 18.65C8.38 18.65 8.16 18.87 8.16 19.15Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
		<path id="矢量 70" d="M6.61 5.08L4.72 6.97C4.62 7.07 4.5 7.12 4.37 7.12C4.23 7.12 4.11 7.07 4.01 6.97L3.06 6.03C2.87 5.83 2.87 5.52 3.06 5.32C3.26 5.12 3.57 5.12 3.77 5.32L4.37 5.91L5.91 4.37C6.1 4.17 6.42 4.17 6.61 4.37C6.81 4.57 6.81 4.88 6.61 5.08ZM6.61 11.65L4.72 13.54C4.62 13.64 4.5 13.69 4.37 13.69C4.23 13.69 4.11 13.64 4.01 13.54L3.06 12.59C2.87 12.39 2.87 12.08 3.06 11.89C3.26 11.69 3.57 11.69 3.77 11.89L4.37 12.48L5.91 10.94C6.1 10.74 6.42 10.74 6.61 10.94C6.81 11.14 6.81 11.45 6.61 11.65ZM6.61 18.07L4.72 19.97C4.62 20.07 4.5 20.12 4.37 20.12C4.23 20.12 4.11 20.07 4.01 19.97L3.06 19.02C2.87 18.82 2.87 18.51 3.06 18.31C3.26 18.12 3.57 18.12 3.77 18.31L4.37 18.91L5.91 17.37C6.1 17.17 6.42 17.17 6.61 17.37C6.81 17.57 6.81 17.88 6.61 18.07Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, lw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_758">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_758)">
		<path id="矢量 66" d="M4.38 5.47C4.38 5.19 4.63 4.97 4.96 4.97L19.03 4.97C19.36 4.97 19.61 5.19 19.61 5.47C19.61 5.75 19.36 5.97 19.03 5.97L4.96 5.97C4.63 5.97 4.38 5.75 4.38 5.47ZM6.88 9.82C6.88 9.54 7.13 9.32 7.46 9.32L16.53 9.32C16.86 9.32 17.11 9.54 17.11 9.82C17.11 10.1 16.86 10.32 16.53 10.32L7.46 10.32C7.13 10.32 6.88 10.1 6.88 9.82ZM4.96 13.67C4.63 13.67 4.38 13.89 4.38 14.17C4.38 14.45 4.63 14.67 4.96 14.67L19.03 14.67C19.36 14.67 19.61 14.45 19.61 14.17C19.61 13.89 19.36 13.67 19.03 13.67L4.96 13.67ZM6.88 18.52C6.88 18.24 7.1 18.02 7.38 18.02L16.38 18.02C16.66 18.02 16.88 18.24 16.88 18.52C16.88 18.8 16.66 19.02 16.38 19.02L7.38 19.02C7.1 19.02 6.88 18.8 6.88 18.52Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 66" d="M4.38 5.47C4.38 5.75 4.63 5.97 4.96 5.97L19.03 5.97C19.36 5.97 19.61 5.75 19.61 5.47C19.61 5.19 19.36 4.97 19.03 4.97L4.96 4.97C4.63 4.97 4.38 5.19 4.38 5.47ZM6.88 9.82C6.88 10.1 7.13 10.32 7.46 10.32L16.53 10.32C16.86 10.32 17.11 10.1 17.11 9.82C17.11 9.54 16.86 9.32 16.53 9.32L7.46 9.32C7.13 9.32 6.88 9.54 6.88 9.82ZM4.38 14.17C4.38 14.45 4.63 14.67 4.96 14.67L19.03 14.67C19.36 14.67 19.61 14.45 19.61 14.17C19.61 13.89 19.36 13.67 19.03 13.67L4.96 13.67C4.63 13.67 4.38 13.89 4.38 14.17ZM6.88 18.52C6.88 18.8 7.1 19.02 7.38 19.02L16.38 19.02C16.66 19.02 16.88 18.8 16.88 18.52C16.88 18.24 16.66 18.02 16.38 18.02L7.38 18.02C7.1 18.02 6.88 18.24 6.88 18.52Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.400000"/>
	</g>
</svg>
`, cw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1717">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip21_1717)">
		<circle id="椭圆 61" cx="2.500000" cy="3.500000" r="1.200000" stroke="#666666" stroke-opacity="1.000000" stroke-width="0.600000"/>
		<circle id="椭圆 62" cx="2.500000" cy="11.500000" r="1.200000" stroke="#666666" stroke-opacity="1.000000" stroke-width="0.600000"/>
		<circle id="椭圆 63" cx="2.500000" cy="19.500000" r="1.200000" stroke="#666666" stroke-opacity="1.000000" stroke-width="0.600000"/>
		<path id="矢量 31" d="M5.68 3L22.31 3C22.69 3 23 3.21 23 3.5C23 3.78 22.69 4 22.31 4L5.68 4C5.3 4 5 3.78 5 3.5C5 3.21 5.3 3 5.68 3Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 32" d="M5.68 11L22.31 11C22.69 11 23 11.22 23 11.5C23 11.78 22.69 12 22.31 12L5.68 12C5.3 12 5 11.78 5 11.5C5 11.22 5.3 11 5.68 11Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 33" d="M5.68 19L22.31 19C22.69 19 23 19.21 23 19.5C23 19.78 22.69 20 22.31 20L5.68 20C5.3 20 5 19.78 5 19.5C5 19.21 5.3 19 5.68 19Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, dw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1710">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip21_1710)">
		<circle id="椭圆 61" cx="2.500000" cy="3.500000" r="1.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 62" cx="2.500000" cy="11.500000" r="1.500000" fill="#666666" fill-opacity="1.000000"/>
		<circle id="椭圆 63" cx="2.500000" cy="19.500000" r="1.500000" fill="#666666" fill-opacity="1.000000"/>
		<path id="矢量 31" d="M5.68 3L22.31 3C22.69 3 23 3.21 23 3.5C23 3.78 22.69 4 22.31 4L5.68 4C5.3 4 5 3.78 5 3.5C5 3.21 5.3 3 5.68 3Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 32" d="M5.68 11L22.31 11C22.69 11 23 11.22 23 11.5C23 11.78 22.69 12 22.31 12L5.68 12C5.3 12 5 11.78 5 11.5C5 11.22 5.3 11 5.68 11Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 33" d="M5.68 19L22.31 19C22.69 19 23 19.21 23 19.5C23 19.78 22.69 20 22.31 20L5.68 20C5.3 20 5 19.78 5 19.5C5 19.21 5.3 19 5.68 19Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, uw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip21_1724">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip21_1724)">
		<path id="矢量 31" d="M5.68 3L22.31 3C22.69 3 23 3.21 23 3.5C23 3.78 22.69 4 22.31 4L5.68 4C5.3 4 5 3.78 5 3.5C5 3.21 5.3 3 5.68 3Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 32" d="M5.68 11L22.31 11C22.69 11 23 11.22 23 11.5C23 11.78 22.69 12 22.31 12L5.68 12C5.3 12 5 11.78 5 11.5C5 11.22 5.3 11 5.68 11Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<path id="矢量 33" d="M5.68 19L22.31 19C22.69 19 23 19.21 23 19.5C23 19.78 22.69 20 22.31 20L5.68 20C5.3 20 5 19.78 5 19.5C5 19.21 5.3 19 5.68 19Z" fill="#666666" fill-opacity="1.000000" fill-rule="evenodd"/>
		<rect id="矩形 631" x="1.000000" y="2.000000" width="3.000000" height="3.000000" fill="#666666" fill-opacity="1.000000"/>
		<rect id="矩形 632" x="1.000000" y="10.000000" width="3.000000" height="3.000000" fill="#666666" fill-opacity="1.000000"/>
		<rect id="矩形 633" x="1.000000" y="18.000000" width="3.000000" height="3.000000" fill="#666666" fill-opacity="1.000000"/>
	</g>
</svg>
`, fw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_328">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_328)">
		<path id="矢量 51" d="M7.8 7.67L7.8 4.68C7.8 4.3 7.5 3.99 7.12 3.99C6.73 3.99 6.43 4.3 6.43 4.68L6.43 10.65C6.43 11.06 6.47 11.47 6.56 11.86C6.63 12.18 6.73 12.5 6.87 12.82C7 13.13 7.16 13.43 7.34 13.71C7.55 14.02 7.79 14.31 8.06 14.58C8.33 14.86 8.62 15.09 8.93 15.3C9.22 15.49 9.51 15.64 9.83 15.78C10.14 15.91 10.46 16.01 10.79 16.08C11.18 16.17 11.58 16.21 12 16.21C12.75 16.21 13.47 16.07 14.16 15.78C14.48 15.64 14.77 15.49 15.06 15.3C15.37 15.09 15.66 14.86 15.93 14.58C16.44 14.07 16.84 13.48 17.12 12.82C17.41 12.13 17.56 11.4 17.56 10.65L17.56 4.68C17.56 4.3 17.26 3.99 16.87 3.99C16.49 3.99 16.19 4.3 16.19 4.68L16.19 10.65C16.19 10.97 16.15 11.28 16.08 11.59C16.03 11.82 15.95 12.05 15.86 12.28C15.64 12.78 15.35 13.23 14.96 13.61C14.75 13.82 14.53 14 14.29 14.16C14.08 14.3 13.86 14.41 13.63 14.51C13.4 14.61 13.17 14.68 12.93 14.74C12.63 14.81 12.31 14.84 12 14.84C11.43 14.84 10.88 14.73 10.36 14.51C9.86 14.3 9.42 14 9.03 13.61C8.82 13.41 8.64 13.18 8.48 12.94C8.35 12.73 8.23 12.51 8.13 12.28C8.04 12.05 7.96 11.82 7.91 11.59C7.84 11.28 7.8 10.97 7.8 10.65L7.8 7.67ZM4.19 19.39C4.19 19.06 4.45 18.79 4.79 18.79L19.2 18.79C19.54 18.79 19.8 19.06 19.8 19.39C19.8 19.73 19.54 20 19.2 20L4.79 20C4.45 20 4.19 19.73 4.19 19.39Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, pw = `<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 1024 1024">
  <path d="M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 0 0-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 0 1-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 0 1-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 0 0-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z"/>
</svg>
`, hw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip221_363">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip221_363)">
		<path id="矢量 54" d="M6.06 6.94L7.66 5.57C7.96 5.31 8 4.88 7.74 4.58C7.49 4.28 7.05 4.25 6.75 4.5L3.83 7.01C3.59 7.11 3.42 7.31 3.42 7.59C3.42 7.64 3.43 7.69 3.44 7.75C3.48 7.88 3.55 8.01 3.65 8.11C3.65 8.12 3.66 8.13 3.67 8.14L6.71 11.18C6.99 11.46 7.43 11.46 7.7 11.18C7.98 10.91 7.98 10.47 7.7 10.2L5.85 8.34L14.17 8.34C14.44 8.34 14.71 8.37 14.98 8.41C15.34 8.47 15.69 8.58 16.03 8.72C16.61 8.96 17.13 9.3 17.59 9.75C17.86 10.01 18.1 10.3 18.31 10.61C18.45 10.82 18.57 11.04 18.68 11.27C18.83 11.6 18.95 11.94 19.02 12.3L19.02 12.3Q19.11 12.7 19.12 13.11C19.13 13.42 19.12 13.72 19.07 14.02C19.02 14.38 18.92 14.73 18.78 15.08C18.54 15.69 18.19 16.24 17.72 16.72C17.45 17 17.15 17.25 16.83 17.46C16.6 17.61 16.37 17.73 16.12 17.84C15.5 18.12 14.85 18.26 14.17 18.26L6.77 18.26C6.38 18.26 6.07 18.56 6.07 18.96C6.07 19.35 6.38 19.66 6.77 19.66L14.17 19.66C14.57 19.66 14.97 19.62 15.36 19.54C15.81 19.45 16.25 19.31 16.69 19.12C17.02 18.98 17.33 18.81 17.63 18.61C18.03 18.35 18.39 18.04 18.73 17.69C19.07 17.34 19.37 16.96 19.61 16.54C19.8 16.24 19.95 15.93 20.09 15.59C20.41 14.78 20.56 13.93 20.52 13.06C20.51 12.69 20.46 12.32 20.38 11.97C20.29 11.53 20.14 11.1 19.95 10.68C19.8 10.37 19.64 10.07 19.45 9.79C19.19 9.41 18.9 9.06 18.56 8.74C17.97 8.17 17.31 7.74 16.57 7.43C16.14 7.25 15.7 7.12 15.26 7.04C14.9 6.98 14.54 6.94 14.17 6.94L6.06 6.94Z" fill="#4C4C4C" fill-opacity="1.000000" fill-rule="evenodd"/>
	</g>
</svg>
`, gw = `<svg width="24.000000" height="24.000000" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<desc>
			Created with Pixso.
	</desc>
	<defs>
		<clipPath id="clip272_69">
			<rect id="svg" width="24.000000" height="24.000000" fill="white" fill-opacity="0"/>
		</clipPath>
	</defs>
	<g clip-path="url(#clip272_69)">
		<path id="path" d="M6.98 4.84L14.14 4.84L17.72 8.42L17.72 18.44C17.72 18.83 17.4 19.15 17.01 19.15L6.98 19.15C6.59 19.15 6.27 18.83 6.27 18.44L6.27 5.55C6.27 5.16 6.59 4.84 6.98 4.84Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M14.14 4.84L17.72 8.42L17.72 18.44C17.72 18.83 17.4 19.15 17.01 19.15L6.98 19.15C6.59 19.15 6.27 18.83 6.27 18.44L6.27 5.55C6.27 5.16 6.59 4.84 6.98 4.84L14.14 4.84Z" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="1.000000" stroke-linejoin="round"/>
		<path id="path" d="M8.82 10.65L8.79 10.64C8.75 10.45 8.87 10.26 9.06 10.22C9.25 10.18 9.44 10.3 9.48 10.49L9.46 10.51L8.82 10.65ZM14.53 10.51L14.52 10.49C14.56 10.3 14.74 10.18 14.93 10.22C15.13 10.26 15.24 10.45 15.2 10.64L15.18 10.65L14.53 10.51Z" fill="#000000" fill-opacity="0" fill-rule="nonzero"/>
		<path id="path" d="M9.13 10.56L10.21 15.57L12 12L13.79 15.57L14.86 10.56" stroke="#4C4C4C" stroke-opacity="1.000000" stroke-width="0.700000" stroke-linejoin="round" stroke-linecap="round"/>
	</g>
</svg>
`, mw = /* @__PURE__ */ Object.assign({
  "./svgs/ai-tool.svg": gv,
  "./svgs/align-center.svg": mv,
  "./svgs/align-justify.svg": Cv,
  "./svgs/align-left.svg": bv,
  "./svgs/align-right.svg": yv,
  "./svgs/bg-color.svg": vv,
  "./svgs/block-quote.svg": wv,
  "./svgs/bold.svg": _v,
  "./svgs/bullet-list.svg": Ev,
  "./svgs/caret-down.svg": xv,
  "./svgs/caret-right.svg": kv,
  "./svgs/clear-format.svg": Sv,
  "./svgs/clock.svg": Mv,
  "./svgs/code-block.svg": Ov,
  "./svgs/code-inline.svg": Tv,
  "./svgs/color-picker.svg": Lv,
  "./svgs/correct.svg": Nv,
  "./svgs/emoji.svg": Av,
  "./svgs/file.svg": Rv,
  "./svgs/find.svg": Iv,
  "./svgs/font-color.svg": Dv,
  "./svgs/format-paint.svg": Pv,
  "./svgs/grid.svg": Bv,
  "./svgs/highlight.svg": $v,
  "./svgs/horizontal.svg": zv,
  "./svgs/italic.svg": Hv,
  "./svgs/line-height.svg": Fv,
  "./svgs/link.svg": Uv,
  "./svgs/math.svg": Vv,
  "./svgs/menu-fold.svg": jv,
  "./svgs/menu-unfold.svg": Wv,
  "./svgs/ol-chinese-number.svg": Zv,
  "./svgs/ol-decimal-zero.svg": Kv,
  "./svgs/ol-decimal.svg": Gv,
  "./svgs/ol-lower-alpha.svg": qv,
  "./svgs/ol-lower-roman.svg": Qv,
  "./svgs/ol-upper-alpha.svg": Yv,
  "./svgs/ordered-list.svg": Jv,
  "./svgs/picture.svg": Xv,
  "./svgs/redo.svg": ew,
  "./svgs/smart-tool.svg": tw,
  "./svgs/strike.svg": nw,
  "./svgs/sub.svg": rw,
  "./svgs/super.svg": iw,
  "./svgs/symbol.svg": ow,
  "./svgs/table.svg": sw,
  "./svgs/task-list.svg": aw,
  "./svgs/text-align.svg": lw,
  "./svgs/ul-hollow-circle.svg": cw,
  "./svgs/ul-solid-circle.svg": dw,
  "./svgs/ul-solid-square.svg": uw,
  "./svgs/underline.svg": fw,
  "./svgs/undo-outline.svg": pw,
  "./svgs/undo.svg": hw,
  "./svgs/word.svg": gw
}), Cw = (t) => {
  const e = `./svgs/${t}.svg`;
  return mw[e] || "";
}, bw = ["innerHTML"], yw = /* @__PURE__ */ ve({
  __name: "Icon",
  props: {
    name: {},
    color: {},
    size: {}
  },
  setup(t) {
    const e = t, n = (o, s = "16px") => o ? typeof o == "number" ? `${o}px` : o : s, r = Ge(() => Cw(e.name)), i = Ge(() => {
      const o = n(e.size);
      return {
        width: o,
        height: o,
        fontSize: o,
        ...e.color ? { fill: e.color } : {}
      };
    });
    return (o, s) => (B(), he("i", {
      class: "svg",
      style: or(i.value)
    }, [
      E("use", { innerHTML: r.value }, null, 8, bw),
      Vi(o.$slots, "default", {}, void 0, !0)
    ], 4));
  }
}), Ot = /* @__PURE__ */ dt(yw, [["__scopeId", "data-v-06018a61"]]), vw = { class: "colors-palette" }, ww = ["onClick"], _w = { class: "color-more" }, Ew = { class: "color-circle" }, xw = /* @__PURE__ */ ve({
  __name: "font-color",
  props: ["editor"],
  setup(t) {
    const e = t, n = Ct(r2()), r = U(0), i = (s, a) => {
      r.value = a, e.editor.chain().focus().setColor(s).run();
    }, o = (s) => {
      e.editor.chain().focus().setColor(s).run();
    };
    return (s, a) => {
      const l = ce("a-popover"), c = ce("a-tooltip");
      return B(), ye(l, {
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("ul", vw, [
            (B(!0), he(Ye, null, bt(n, (d, u) => (B(), he("li", {
              class: lt([
                "color-item",
                {
                  border_black: r.value === u
                }
              ]),
              key: d,
              onClick: (f) => i(d, u)
            }, [
              E("div", {
                class: "color-box",
                style: or({ background: d })
              }, null, 4)
            ], 10, ww))), 128))
          ]),
          k(l, { placement: "right" }, {
            content: R(() => [
              k(o2, { onUpdateColor: o })
            ]),
            default: R(() => [
              E("div", _w, [
                E("div", Ew, [
                  k(Ot, { name: "color-picker" }),
                  a[0] || (a[0] = Ae(" 更多颜色 "))
                ]),
                E("div", null, [
                  k(se(tl), { style: { "font-size": "12px" } })
                ])
              ])
            ]),
            _: 1
          })
        ]),
        default: R(() => [
          k(c, { placement: "top" }, {
            title: R(() => a[1] || (a[1] = [
              E("span", null, "文字颜色", -1)
            ])),
            default: R(() => [
              E("div", {
                class: lt([
                  "tool",
                  {
                    "tool--active": t.editor.isActive("textStyle")
                  }
                ])
              }, [
                k(se(td), { style: { "font-size": "16px" } }),
                k(se(Ln), { style: { "font-size": "10px" } })
              ], 2)
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
}), kw = { class: "colors-palette" }, Sw = ["onClick"], Mw = { class: "color-more" }, Ow = { class: "color-circle" }, Tw = /* @__PURE__ */ ve({
  __name: "bg-color",
  props: ["editor"],
  setup(t) {
    const e = t, n = Ct(r2()), r = U(9), i = (s, a) => {
      r.value = a, e.editor.chain().focus().setHighlight({ color: s }).run();
    }, o = (s) => {
      e.editor.chain().focus().setHighlight({ color: s }).run();
    };
    return (s, a) => {
      const l = ce("a-popover"), c = ce("a-tooltip");
      return B(), ye(l, {
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("ul", kw, [
            (B(!0), he(Ye, null, bt(n, (d, u) => (B(), he("li", {
              class: lt([
                "color-item",
                {
                  border_black: r.value === u
                }
              ]),
              key: d,
              onClick: (f) => i(d, u)
            }, [
              E("div", {
                class: "color-box",
                style: or({ background: d })
              }, null, 4)
            ], 10, Sw))), 128))
          ]),
          k(l, { placement: "right" }, {
            content: R(() => [
              k(o2, { onUpdateColor: o })
            ]),
            default: R(() => [
              E("div", Mw, [
                E("div", Ow, [
                  k(Ot, { name: "color-picker" }),
                  a[0] || (a[0] = Ae(" 更多颜色 "))
                ]),
                E("div", null, [
                  k(se(tl), { style: { "font-size": "12px" } })
                ])
              ])
            ]),
            _: 1
          })
        ]),
        default: R(() => [
          k(c, { placement: "top" }, {
            title: R(() => a[1] || (a[1] = [
              E("span", null, "背景颜色", -1)
            ])),
            default: R(() => [
              E("div", {
                class: lt([
                  "tool",
                  {
                    "tool--active": t.editor.isActive("highlight")
                  }
                ])
              }, [
                k(se(Zc), { style: { "font-size": "16px", "font-weight": "600" } }),
                k(se(Ln), { style: { "font-size": "10px", "font-weight": "600" } })
              ], 2)
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
}), Lw = { class: "tool header-tool" }, Nw = { class: "header_label" }, Aw = { class: "header-lists" }, Rw = /* @__PURE__ */ ve({
  __name: "header-tool",
  props: {
    editor: {}
  },
  setup(t) {
    const e = t, n = ["正文", "标题1", "标题2", "标题3", "标题4"], r = U(!1), i = U("正文"), o = (s) => {
      i.value = n[s], r.value = !1, s === 0 ? e.editor.chain().focus().setParagraph().run() : e.editor.chain().focus().toggleHeading({ level: s }).run();
    };
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), ye(c, {
        placement: "bottom",
        trigger: "click",
        open: r.value,
        "onUpdate:open": a[5] || (a[5] = (d) => r.value = d)
      }, {
        content: R(() => [
          E("div", Aw, [
            E("div", {
              class: "header-lists-text header-lists-item",
              onClick: a[0] || (a[0] = (d) => o(0))
            }, [
              a[7] || (a[7] = Ae(" 正文 ")),
              i.value === "正文" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("h1", {
              class: "header-lists-h1 header-lists-item",
              onClick: a[1] || (a[1] = (d) => o(1))
            }, [
              a[8] || (a[8] = Ae(" 标题1 ")),
              i.value === "标题1" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("h2", {
              class: "header-lists-h2 header-lists-item",
              onClick: a[2] || (a[2] = (d) => o(2))
            }, [
              a[9] || (a[9] = Ae(" 标题2 ")),
              i.value === "标题2" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("h3", {
              class: "header-lists-h3 header-lists-item",
              onClick: a[3] || (a[3] = (d) => o(3))
            }, [
              a[10] || (a[10] = Ae(" 标题3 ")),
              i.value === "标题3" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("h4", {
              class: "header-lists-h4 header-lists-item",
              onClick: a[4] || (a[4] = (d) => o(4))
            }, [
              a[11] || (a[11] = Ae(" 标题4 ")),
              i.value === "标题4" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ])
          ])
        ]),
        default: R(() => [
          k(l, { placement: "top" }, {
            title: R(() => a[6] || (a[6] = [
              E("span", null, " 标题", -1)
            ])),
            default: R(() => [
              E("div", Lw, [
                E("div", Nw, ft(i.value), 1),
                k(se(Ln), { style: { "font-size": "10px" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), Iw = /* @__PURE__ */ dt(Rw, [["__scopeId", "data-v-487dfffc"]]), Dw = {
  SegoeUI: "Segoe UI",
  YaHei: "Microsoft YaHei, sans-serif",
  // 微软雅黑
  SimSun: "SimSun,STSong, sans-serif",
  // 宋体
  SimHei: "SimHei,STHeiti, sans-serif",
  // 黑体
  FangSong: "FangSong,STFangsong, sans-serif",
  // 仿宋
  KaiTi: "KaiTi, sans-serif",
  // 楷体
  Arial: "Arial, sans-serif",
  //Arial
  Times: "Times New Roman, sans-serif"
}, Pw = { class: "family_label" }, Bw = { class: "family-lists" }, $w = /* @__PURE__ */ ve({
  __name: "font-family",
  props: ["modelValue", "editor"],
  setup(t) {
    const e = t, n = U(!1), r = {
      SegoeUI: "默认",
      YaHei: "微软雅黑",
      SimSun: "宋体",
      SimHei: "黑体",
      FangSong: "仿宋",
      Times: "Times New Roman",
      default: "字体"
    }, i = U("SegoeUI"), o = (s) => {
      i.value = s, e.editor.chain().focus().setFontFamily(Dw[s]).run();
    };
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), ye(c, {
        open: n.value,
        "onUpdate:open": a[7] || (a[7] = (d) => n.value = d),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", Bw, [
            E("div", {
              class: "item SegoeUI",
              onClick: a[1] || (a[1] = (d) => o("SegoeUI"))
            }, [
              a[9] || (a[9] = Ae(" 默认字体 ")),
              i.value === "SegoeUI" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("div", {
              class: "item yahei",
              onClick: a[2] || (a[2] = (d) => o("YaHei"))
            }, [
              a[10] || (a[10] = Ae(" 微软雅黑 ")),
              i.value === "YaHei" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("div", {
              class: "item simsun",
              onClick: a[3] || (a[3] = (d) => o("SimSun"))
            }, [
              a[11] || (a[11] = Ae(" 宋体 ")),
              i.value === "SimSun" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("div", {
              class: "item simhei",
              onClick: a[4] || (a[4] = (d) => o("SimHei"))
            }, [
              a[12] || (a[12] = Ae(" 黑体 ")),
              i.value === "SimHei" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("div", {
              class: "item fangsong",
              onClick: a[5] || (a[5] = (d) => o("FangSong"))
            }, [
              a[13] || (a[13] = Ae(" 仿宋 ")),
              i.value === "FangSong" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ]),
            E("div", {
              class: "item times",
              onClick: a[6] || (a[6] = (d) => o("Times"))
            }, [
              a[14] || (a[14] = Ae(" Times New Roman ")),
              i.value === "Times" ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ])
          ])
        ]),
        default: R(() => [
          k(l, { placement: "top" }, {
            title: R(() => a[8] || (a[8] = [
              E("span", null, " 字体", -1)
            ])),
            default: R(() => [
              E("div", {
                class: "tool family_button",
                onClick: a[0] || (a[0] = (d) => n.value = !n.value)
              }, [
                E("div", Pw, ft(r[i.value]), 1),
                k(se(Ln), { style: { "font-size": "10px" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), zw = /* @__PURE__ */ dt($w, [["__scopeId", "data-v-5d35e7a7"]]), il = async (t, e) => e ? /^(((ht|f)tps?):\/\/)?([^!@#$%^&*?.\s-]([^!@#$%^&*?.\s]{0,63}[^!@#$%^&*?.\s])?\.)+[a-z]{2,6}\/?/.test(
  e
) ? Promise.resolve() : Promise.reject(new Error("请输入正确的URL地址!")) : Promise.reject(new Error("URL地址不能为空!")), Hw = /* @__PURE__ */ ve({
  __name: "index",
  props: ["options"],
  emits: ["emitInsert"],
  setup(t, { expose: e, emit: n }) {
    const r = U(), i = Ct({}), o = U(!1), s = n, a = () => {
      i.url = "", o.value = !0;
    }, l = () => {
      o.value = !1;
    }, c = () => {
      r.value.validateFields().then(() => {
        s("emitInsert", { ...i, type: "insert" }), l();
      });
    };
    return e({
      showModal: a,
      closeModal: l
    }), (d, u) => {
      const f = ce("a-select-option"), p = ce("a-radio"), h = ce("a-form-item"), m = ce("a-form"), g = ce("a-modal");
      return B(), ye(g, {
        open: o.value,
        "onUpdate:open": u[0] || (u[0] = (C) => o.value = C),
        title: t.options.title,
        onOk: c,
        okText: "插入",
        cancelText: "取消"
      }, {
        default: R(() => [
          k(m, {
            model: i,
            ref_key: "formRef",
            ref: r
          }, {
            default: R(() => [
              t.options.headers.length ? (B(!0), he(Ye, { key: 0 }, bt(t.options.headers, (C) => (B(), ye(h, Qd({ ref_for: !0 }, C.formItem, {
                key: C.formItem.name
              }), {
                default: R(() => [
                  (B(), ye(js(`a-${C.component.name}`), Qd({
                    value: i[C.formItem.name],
                    "onUpdate:value": (v) => i[C.formItem.name] = v
                  }, { ref_for: !0 }, C.component), {
                    default: R(() => [
                      C.component.name === "select" && C.options ? (B(!0), he(Ye, { key: 0 }, bt(C.options, (v) => (B(), ye(f, {
                        key: v.value,
                        value: v.value
                      }, {
                        default: R(() => [
                          Ae(ft(v.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["value"]))), 128)) : it("", !0),
                      C.component.name === "radio-group" && C.options ? (B(!0), he(Ye, { key: 1 }, bt(C.options, (v, _) => (B(), ye(p, {
                        key: _,
                        value: v.value,
                        options: C.options
                      }, {
                        default: R(() => [
                          Ae(ft(v.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["value", "options"]))), 128)) : it("", !0)
                    ]),
                    _: 2
                  }, 1040, ["value", "onUpdate:value"]))
                ]),
                _: 2
              }, 1040))), 128)) : it("", !0),
              Vi(d.$slots, "default", {}, void 0, !0)
            ]),
            _: 3
          }, 8, ["model"])
        ]),
        _: 3
      }, 8, ["open", "title"]);
    };
  }
}), ol = /* @__PURE__ */ dt(Hw, [["__scopeId", "data-v-92414cf6"]]);
var Fw = typeof global == "object" && global && global.Object === Object && global, Uw = typeof self == "object" && self && self.Object === Object && self, s2 = Fw || Uw || Function("return this")(), aa = s2.Symbol, a2 = Object.prototype, Vw = a2.hasOwnProperty, jw = a2.toString, Xi = aa ? aa.toStringTag : void 0;
function Ww(t) {
  var e = Vw.call(t, Xi), n = t[Xi];
  try {
    t[Xi] = void 0;
    var r = !0;
  } catch {
  }
  var i = jw.call(t);
  return r && (e ? t[Xi] = n : delete t[Xi]), i;
}
var Zw = Object.prototype, Kw = Zw.toString;
function Gw(t) {
  return Kw.call(t);
}
var qw = "[object Null]", Qw = "[object Undefined]", Ap = aa ? aa.toStringTag : void 0;
function Yw(t) {
  return t == null ? t === void 0 ? Qw : qw : Ap && Ap in Object(t) ? Ww(t) : Gw(t);
}
function U1(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
function Jw(t) {
  return t != null && typeof t == "object";
}
var Xw = "[object Symbol]";
function e_(t) {
  return typeof t == "symbol" || Jw(t) && Yw(t) == Xw;
}
var t_ = /\s/;
function n_(t) {
  for (var e = t.length; e-- && t_.test(t.charAt(e)); )
    ;
  return e;
}
var r_ = /^\s+/;
function i_(t) {
  return t && t.slice(0, n_(t) + 1).replace(r_, "");
}
var Rp = NaN, o_ = /^[-+]0x[0-9a-f]+$/i, s_ = /^0b[01]+$/i, a_ = /^0o[0-7]+$/i, l_ = parseInt;
function Ip(t) {
  if (typeof t == "number")
    return t;
  if (e_(t))
    return Rp;
  if (U1(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = U1(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = i_(t);
  var n = s_.test(t);
  return n || a_.test(t) ? l_(t.slice(2), n ? 2 : 8) : o_.test(t) ? Rp : +t;
}
var ql = function() {
  return s2.Date.now();
}, c_ = "Expected a function", d_ = Math.max, u_ = Math.min;
function f_(t, e, n) {
  var r, i, o, s, a, l, c = 0, d = !1, u = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(c_);
  e = Ip(e) || 0, U1(n) && (d = !!n.leading, u = "maxWait" in n, o = u ? d_(Ip(n.maxWait) || 0, e) : o, f = "trailing" in n ? !!n.trailing : f);
  function p(y) {
    var M = r, S = i;
    return r = i = void 0, c = y, s = t.apply(S, M), s;
  }
  function h(y) {
    return c = y, a = setTimeout(C, e), d ? p(y) : s;
  }
  function m(y) {
    var M = y - l, S = y - c, T = e - M;
    return u ? u_(T, o - S) : T;
  }
  function g(y) {
    var M = y - l, S = y - c;
    return l === void 0 || M >= e || M < 0 || u && S >= o;
  }
  function C() {
    var y = ql();
    if (g(y))
      return v(y);
    a = setTimeout(C, m(y));
  }
  function v(y) {
    return a = void 0, f && r ? p(y) : (r = i = void 0, s);
  }
  function _() {
    a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
  }
  function b() {
    return a === void 0 ? s : v(ql());
  }
  function x() {
    var y = ql(), M = g(y);
    if (r = arguments, i = this, l = y, M) {
      if (a === void 0)
        return h(l);
      if (u)
        return clearTimeout(a), a = setTimeout(C, e), p(l);
    }
    return a === void 0 && (a = setTimeout(C, e)), s;
  }
  return x.cancel = _, x.flush = b, x;
}
function p_(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
const yd = async (t) => new Promise(
  (e, n) => {
    const r = new FileReader();
    r.readAsDataURL(t), r.onload = () => e(r.result), r.onerror = (i) => n(i);
  }
), Cr = (t, e, n) => t < e ? e : t > n ? n : t, h_ = { class: "ant-upload-drag-icon" }, vd = /* @__PURE__ */ ve({
  __name: "index",
  props: ["options"],
  emits: ["emitUpload"],
  setup(t, { expose: e, emit: n }) {
    const r = U(!1), i = n, o = t, { fileType: s } = o.options, a = () => {
      r.value = !0;
    }, l = () => {
      r.value = !1;
    }, c = U([]), d = async (u) => {
      u.type, u.type === "image/jpeg" || u.type, u.type;
      const f = await yd(u);
      return i("emitUpload", { url: f, file: u, type: "upload" }), !1;
    };
    return e({
      showModal: a,
      closeModal: l
    }), (u, f) => {
      const p = ce("a-upload-dragger"), h = ce("a-form-item"), m = ce("a-modal");
      return B(), ye(m, {
        open: r.value,
        "onUpdate:open": f[1] || (f[1] = (g) => r.value = g),
        title: t.options.title
      }, {
        footer: R(() => f[4] || (f[4] = [])),
        default: R(() => [
          k(h, null, {
            default: R(() => [
              k(p, {
                fileList: c.value,
                "onUpdate:fileList": f[0] || (f[0] = (g) => c.value = g),
                name: "file",
                "before-upload": d,
                "show-upload-list": !1,
                "auto-upload": !1
              }, {
                default: R(() => [
                  E("p", h_, [
                    k(se(nd))
                  ]),
                  f[2] || (f[2] = E("p", { class: "ant-upload-text" }, "Click or drag file to this area to upload", -1)),
                  f[3] || (f[3] = E("p", { class: "ant-upload-hint" }, " Support for a single or bulk upload. Strictly prohibit from uploading company data or other band files ", -1))
                ]),
                _: 1,
                __: [2, 3]
              }, 8, ["fileList"])
            ]),
            _: 1
          }),
          Vi(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["open", "title"]);
    };
  }
}), g_ = { class: "dropdown" }, m_ = { class: "tool" }, C_ = /* @__PURE__ */ ve({
  __name: "image-tool",
  props: {
    editor: {}
  },
  setup(t) {
    const e = t, n = [
      {
        formItem: {
          name: "url",
          rules: [{ required: !0, validator: il, trigger: "blur" }]
        },
        component: {
          name: "input",
          placeholder: "URL of Image"
        }
      }
    ], r = U(), i = U(), o = async ({ url: s, file: a, type: l }) => {
      if (l === "upload") {
        const c = await yd(a);
        e.editor.chain().focus().setImage({ src: c }).run();
      } else
        e.editor.chain().focus().setImage({ src: s }).run();
      i.value.closeModal(), r.value.closeModal();
    };
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), he(Ye, null, [
        k(c, {
          placement: "bottom",
          trigger: "click"
        }, {
          content: R(() => [
            E("ul", g_, [
              E("li", {
                class: "dropdown__opeartion",
                onClick: a[0] || (a[0] = (d) => r.value.showModal())
              }, [
                k(se(rl), { style: { "margin-right": "5px" } }),
                a[2] || (a[2] = Ae("插入URL "))
              ]),
              E("li", {
                class: "dropdown__opeartion",
                onClick: a[1] || (a[1] = (d) => i.value.showModal())
              }, [
                k(se(Yo), { style: { "margin-right": "5px" } }),
                a[3] || (a[3] = Ae("上传图片 "))
              ])
            ])
          ]),
          default: R(() => [
            k(l, { placement: "top" }, {
              title: R(() => a[4] || (a[4] = [
                E("span", null, "图片", -1)
              ])),
              default: R(() => [
                E("div", m_, [
                  k(se(dd), { style: { "font-size": "16px", "font-weight": "600" } })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        k(ol, {
          ref_key: "insertRef",
          ref: r,
          onEmitInsert: o,
          options: { title: "插入图片地址", headers: n }
        }, null, 8, ["options"]),
        k(vd, {
          ref_key: "uploadRef",
          ref: i,
          onEmitUpload: o,
          options: { title: "上传图片" }
        }, null, 512)
      ], 64);
    };
  }
}), b_ = { class: "dropdown" }, y_ = { class: "tool" }, v_ = /* @__PURE__ */ ve({
  __name: "video-tool",
  props: ["editor"],
  emits: ["emitVideo"],
  setup(t, { emit: e }) {
    const n = t, r = [
      {
        formItem: {
          name: "url",
          rules: [{ required: !0, validator: il, trigger: "blur" }]
        },
        component: {
          name: "input",
          placeholder: "URL of Video"
        }
      }
    ], i = U(), o = U(), s = async ({ url: a, file: l, type: c }) => {
      if (c === "upload") {
        const d = await yd(l);
        n.editor.chain().focus().setVideo({ src: d }).run();
      } else
        n.editor.chain().focus().setVideo({ src: a }).run();
      o.value.closeModal(), i.value.closeModal();
    };
    return (a, l) => {
      const c = ce("a-tooltip"), d = ce("a-popover");
      return B(), he(Ye, null, [
        k(d, {
          placement: "bottom",
          trigger: "click"
        }, {
          content: R(() => [
            E("ul", b_, [
              E("li", {
                class: "dropdown__opeartion",
                onClick: l[0] || (l[0] = //@ts-ignore
                (...u) => i.value.showModal && i.value.showModal(...u))
              }, [
                k(se(rl), { style: { "margin-right": "5px" } }),
                l[2] || (l[2] = Ae("插入网络视频 "))
              ]),
              E("li", {
                class: "dropdown__opeartion",
                onClick: l[1] || (l[1] = //@ts-ignore
                (...u) => o.value.showModal && o.value.showModal(...u))
              }, [
                k(se(Yo), { style: { "margin-right": "5px" } }),
                l[3] || (l[3] = Ae("上传本地视频 "))
              ])
            ])
          ]),
          default: R(() => [
            k(c, { placement: "top" }, {
              title: R(() => l[4] || (l[4] = [
                E("span", null, "视频", -1)
              ])),
              default: R(() => [
                E("div", y_, [
                  k(se(bd), { style: { "font-size": "16px", "font-weight": "600" } })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        k(ol, {
          ref_key: "insertRef",
          ref: i,
          onEmitInsert: s,
          options: { title: "网络视频URL", headers: r }
        }, null, 8, ["options"]),
        k(vd, {
          ref_key: "uploadRef",
          ref: o,
          onEmitUpload: s,
          options: { title: "上传本地视频", headers: r, fileType: "video" }
        }, null, 8, ["options"])
      ], 64);
    };
  }
}), w_ = { class: "dropdown" }, __ = { class: "tool" }, E_ = /* @__PURE__ */ ve({
  __name: "pdf-tool",
  props: ["editor"],
  emits: ["emitPdf"],
  setup(t, { emit: e }) {
    const n = t, r = U(), i = U(), o = [
      {
        formItem: {
          name: "url",
          rules: [{ required: !0, validator: il, trigger: "blur" }]
        },
        component: {
          name: "input",
          placeholder: "URL of PDF"
        }
      }
    ], s = U(1), a = async ({ url: c, file: d, type: u }) => {
      if (u === "upload") {
        const f = d.name || "document.pdf", p = new Blob([d], { type: "application/pdf" }), h = URL.createObjectURL(p);
        n.editor.chain().focus().setPdf({
          src: h,
          fileName: f
        }).run();
      } else if (s.value === 1 && n.editor.commands.insertContent({
        type: "text",
        text: `附件:${c}`,
        marks: [
          {
            type: "link",
            attrs: {
              href: c
            }
          }
        ]
      }), s.value === 2)
        if (c.toLowerCase().includes(".pdf") || c.includes("application/pdf")) {
          const f = c.split("/").pop() || "document.pdf";
          n.editor.chain().focus().setPdf({
            src: c,
            fileName: f
          }).run();
        } else
          n.editor.chain().focus().setIframe({ src: c }).run();
      i.value.closeModal(), r.value.closeModal();
    }, l = () => {
      s.value = 2, i.value.showModal();
    };
    return (c, d) => {
      const u = ce("a-tooltip"), f = ce("a-popover"), p = ce("a-radio-button"), h = ce("a-radio-group"), m = ce("a-form-item");
      return B(), he(Ye, null, [
        k(f, {
          placement: "bottom",
          trigger: "click"
        }, {
          content: R(() => [
            E("ul", w_, [
              E("li", {
                class: "dropdown__opeartion",
                onClick: d[0] || (d[0] = (g) => r.value.showModal())
              }, [
                k(se(nl), { style: { "margin-right": "5px" } }),
                d[2] || (d[2] = Ae("插入网络PDF "))
              ]),
              E("li", {
                class: "dropdown__opeartion",
                onClick: l
              }, [
                k(se(Yo), { style: { "margin-right": "5px" } }),
                d[3] || (d[3] = Ae("上传本地PDF "))
              ])
            ])
          ]),
          default: R(() => [
            k(u, { placement: "top" }, {
              title: R(() => d[4] || (d[4] = [
                E("span", null, "PDF", -1)
              ])),
              default: R(() => [
                E("div", __, [
                  k(se(ed), { style: { "font-size": "16px", "font-weight": "600" } })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        k(ol, {
          ref_key: "insertRef",
          ref: r,
          onEmitInsert: a,
          options: { title: "插入PDF地址", placeholder: "URL of PDF", headers: o }
        }, {
          default: R(() => [
            k(m, {
              name: "type",
              label: "插入类型"
            }, {
              default: R(() => [
                k(h, {
                  value: s.value,
                  "onUpdate:value": d[1] || (d[1] = (g) => s.value = g),
                  "button-style": "solid"
                }, {
                  default: R(() => [
                    k(p, { value: 1 }, {
                      default: R(() => d[5] || (d[5] = [
                        Ae("附件形式")
                      ])),
                      _: 1,
                      __: [5]
                    }),
                    k(p, { value: 2 }, {
                      default: R(() => d[6] || (d[6] = [
                        Ae("内容形式")
                      ])),
                      _: 1,
                      __: [6]
                    })
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["options"]),
        k(vd, {
          ref_key: "uploadRef",
          ref: i,
          onEmitUpload: a,
          options: { title: "上传PDF" }
        }, null, 512)
      ], 64);
    };
  }
}), x_ = { class: "table-wrap" }, k_ = { class: "show-row-column" }, Ql = 6, Dp = 6, Pp = 20, S_ = /* @__PURE__ */ ve({
  __name: "table-sheet",
  emits: ["emitTable"],
  setup(t, { emit: e }) {
    const n = U(null), r = U(0), i = U(0), o = e, s = {
      mounted(a) {
        a.addEventListener("mousemove", (l) => {
          if (n.value) {
            const { width: c, height: d, left: u, top: f } = a.getBoundingClientRect(), p = Math.min(l.clientX - u, c), h = Math.min(l.clientY - f, d);
            n.value.style.width = `${Math.abs(p)}px`, n.value.style.height = `${Math.abs(h)}px`, n.value.style.left = `${p}px`, n.value.style.top = `${h}px`;
            const m = a.querySelectorAll(".cell");
            m.forEach((g) => {
              g.classList.remove("selected");
            }), r.value = Math.min(Math.floor(h / Pp) + 1, Ql), i.value = Math.min(Math.floor(p / Pp) + 1, Dp);
            for (let g = 0; g <= r.value - 1; g++)
              for (let C = 0; C <= i.value - 1; C++) {
                const v = g * Ql + C;
                m[v].classList.add("selected");
              }
          }
        }), a.addEventListener("mouseup", () => {
          o("emitTable", { row: r.value, column: i.value }), r.value = i.value = 0, n.value && (n.value.style.left = "0px", n.value.style.top = "0px");
        });
      },
      unmounted(a) {
        a.removeEventListener("mousemove", () => {
        }), a.removeEventListener("mouseup", () => {
        });
      }
    };
    return (a, l) => (B(), he(Ye, null, [
      za((B(), he("div", x_, [
        E("table", null, [
          (B(), he(Ye, null, bt(Ql, (c) => E("tr", { key: c }, [
            (B(), he(Ye, null, bt(Dp, (d) => E("td", {
              class: "cell",
              key: d
            })), 64))
          ])), 64))
        ]),
        E("div", {
          class: "select-suspension-modal",
          ref_key: "selectModal",
          ref: n
        }, null, 512)
      ])), [
        [s]
      ]),
      E("div", k_, ft(r.value) + " x " + ft(i.value), 1)
    ], 64));
  }
});
function M_(t) {
  return O4() ? (T4(t), !0) : !1;
}
const wd = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const O_ = Object.prototype.toString, T_ = (t) => O_.call(t) === "[object Object]", Ci = () => {
}, L_ = /* @__PURE__ */ N_();
function N_() {
  var t, e;
  return wd && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Yl(t) {
  return Array.isArray(t) ? t : [t];
}
function A_(t, e = {}) {
  if (!S4(t))
    return M4(t);
  const n = Array.isArray(t.value) ? Array.from({ length: t.value.length }) : {};
  for (const r in t.value)
    n[r] = Mh(() => ({
      get() {
        return t.value[r];
      },
      set(i) {
        var o;
        if ((o = Xe(e.replaceRef)) != null ? o : !0)
          if (Array.isArray(t.value)) {
            const a = [...t.value];
            a[r] = i, t.value = a;
          } else {
            const a = { ...t.value, [r]: i };
            Object.setPrototypeOf(a, Object.getPrototypeOf(t.value)), t.value = a;
          }
        else
          t.value[r] = i;
      }
    }));
  return n;
}
function R_(t, e, n) {
  return Oh(
    t,
    e,
    {
      ...n,
      immediate: !0
    }
  );
}
const _d = wd ? window : void 0;
function so(t) {
  var e;
  const n = Xe(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function Ai(...t) {
  const e = [], n = () => {
    e.forEach((a) => a()), e.length = 0;
  }, r = (a, l, c, d) => (a.addEventListener(l, c, d), () => a.removeEventListener(l, c, d)), i = Ge(() => {
    const a = Yl(Xe(t[0])).filter((l) => l != null);
    return a.every((l) => typeof l != "string") ? a : void 0;
  }), o = R_(
    () => {
      var a, l;
      return [
        (l = (a = i.value) == null ? void 0 : a.map((c) => so(c))) != null ? l : [_d].filter((c) => c != null),
        Yl(Xe(i.value ? t[1] : t[0])),
        Yl(se(i.value ? t[2] : t[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        Xe(i.value ? t[3] : t[2])
      ];
    },
    ([a, l, c, d]) => {
      if (n(), !(a != null && a.length) || !(l != null && l.length) || !(c != null && c.length))
        return;
      const u = T_(d) ? { ...d } : d;
      e.push(
        ...a.flatMap(
          (f) => l.flatMap(
            (p) => c.map((h) => r(f, p, h, u))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return M_(n), s;
}
let Bp = !1;
function I_(t, e, n = {}) {
  const { window: r = _d, ignore: i = [], capture: o = !0, detectIframe: s = !1, controls: a = !1 } = n;
  if (!r)
    return a ? { stop: Ci, cancel: Ci, trigger: Ci } : Ci;
  if (L_ && !Bp) {
    Bp = !0;
    const g = { passive: !0 };
    Array.from(r.document.body.children).forEach((C) => C.addEventListener("click", Ci, g)), r.document.documentElement.addEventListener("click", Ci, g);
  }
  let l = !0;
  const c = (g) => Xe(i).some((C) => {
    if (typeof C == "string")
      return Array.from(r.document.querySelectorAll(C)).some((v) => v === g.target || g.composedPath().includes(v));
    {
      const v = so(C);
      return v && (g.target === v || g.composedPath().includes(v));
    }
  });
  function d(g) {
    const C = Xe(g);
    return C && C.$.subTree.shapeFlag === 16;
  }
  function u(g, C) {
    const v = Xe(g), _ = v.$.subTree && v.$.subTree.children;
    return _ == null || !Array.isArray(_) ? !1 : _.some((b) => b.el === C.target || C.composedPath().includes(b.el));
  }
  const f = (g) => {
    const C = so(t);
    if (g.target != null && !(!(C instanceof Element) && d(t) && u(t, g)) && !(!C || C === g.target || g.composedPath().includes(C))) {
      if ("detail" in g && g.detail === 0 && (l = !c(g)), !l) {
        l = !0;
        return;
      }
      e(g);
    }
  };
  let p = !1;
  const h = [
    Ai(r, "click", (g) => {
      p || (p = !0, setTimeout(() => {
        p = !1;
      }, 0), f(g));
    }, { passive: !0, capture: o }),
    Ai(r, "pointerdown", (g) => {
      const C = so(t);
      l = !c(g) && !!(C && !g.composedPath().includes(C));
    }, { passive: !0 }),
    s && Ai(r, "blur", (g) => {
      setTimeout(() => {
        var C;
        const v = so(t);
        ((C = r.document.activeElement) == null ? void 0 : C.tagName) === "IFRAME" && !(v != null && v.contains(r.document.activeElement)) && e(g);
      }, 0);
    }, { passive: !0 })
  ].filter(Boolean), m = () => h.forEach((g) => g());
  return a ? {
    stop: m,
    cancel: () => {
      l = !1;
    },
    trigger: (g) => {
      l = !0, f(g), l = !1;
    }
  } : m;
}
function D_(t, e = {}) {
  var n;
  const {
    pointerTypes: r,
    preventDefault: i,
    stopPropagation: o,
    exact: s,
    onMove: a,
    onEnd: l,
    onStart: c,
    initialValue: d,
    axis: u = "both",
    draggingElement: f = _d,
    containerElement: p,
    handle: h = t,
    buttons: m = [0]
  } = e, g = U(
    (n = Xe(d)) != null ? n : { x: 0, y: 0 }
  ), C = U(), v = (M) => r ? r.includes(M.pointerType) : !0, _ = (M) => {
    Xe(i) && M.preventDefault(), Xe(o) && M.stopPropagation();
  }, b = (M) => {
    var S;
    if (!Xe(m).includes(M.button) || Xe(e.disabled) || !v(M) || Xe(s) && M.target !== Xe(t))
      return;
    const T = Xe(p), D = (S = T == null ? void 0 : T.getBoundingClientRect) == null ? void 0 : S.call(T), j = Xe(t).getBoundingClientRect(), V = {
      x: M.clientX - (T ? j.left - D.left + T.scrollLeft : j.left),
      y: M.clientY - (T ? j.top - D.top + T.scrollTop : j.top)
    };
    (c == null ? void 0 : c(V, M)) !== !1 && (C.value = V, _(M));
  }, x = (M) => {
    if (Xe(e.disabled) || !v(M) || !C.value)
      return;
    const S = Xe(p), T = Xe(t).getBoundingClientRect();
    let { x: D, y: j } = g.value;
    (u === "x" || u === "both") && (D = M.clientX - C.value.x, S && (D = Math.min(Math.max(0, D), S.scrollWidth - T.width))), (u === "y" || u === "both") && (j = M.clientY - C.value.y, S && (j = Math.min(Math.max(0, j), S.scrollHeight - T.height))), g.value = {
      x: D,
      y: j
    }, a == null || a(g.value, M), _(M);
  }, y = (M) => {
    Xe(e.disabled) || !v(M) || C.value && (C.value = void 0, l == null || l(g.value, M), _(M));
  };
  if (wd) {
    const M = () => {
      var S;
      return {
        capture: (S = e.capture) != null ? S : !0,
        passive: !Xe(i)
      };
    };
    Ai(h, "pointerdown", b, M), Ai(f, "pointermove", x, M), Ai(f, "pointerup", y, M);
  }
  return {
    ...A_(g),
    position: g,
    isDragging: Ge(() => !!C.value),
    style: Ge(
      () => `left:${g.value.x}px;top:${g.value.y}px;`
    )
  };
}
const P_ = { class: "dropdown__opeartion border_bottom" }, B_ = { class: "tool" }, $_ = /* @__PURE__ */ ve({
  __name: "table-tool",
  props: ["editor"],
  emits: ["emitTable"],
  setup(t, { emit: e }) {
    const n = t, r = U(!1), i = U(), o = ({ row: h, column: m }) => {
      n.editor.chain().focus().insertTable({ rows: h, cols: m, withHeaderRow: !0 }).run();
    };
    I_(i, () => {
      r.value = !1;
    });
    const s = () => {
      n.editor.chain().focus().addRowBefore().run(), r.value = !1;
    }, a = () => {
      n.editor.chain().focus().addRowAfter().run(), r.value = !1;
    }, l = () => {
      n.editor.chain().focus().deleteRow().run(), r.value = !1;
    }, c = () => {
      n.editor.chain().focus().addColumnBefore().run(), r.value = !1;
    }, d = () => {
      n.editor.chain().focus().addColumnAfter().run(), r.value = !1;
    }, u = () => {
      n.editor.chain().focus().deleteColumn().run(), r.value = !1;
    }, f = () => {
      n.editor.chain().focus().mergeCells().run(), r.value = !1;
    }, p = () => {
      n.editor.chain().focus().splitCell().run(), r.value = !1;
    };
    return (h, m) => {
      const g = ce("a-popover"), C = ce("a-tooltip");
      return B(), ye(g, {
        placement: "bottom",
        trigger: "click",
        open: r.value,
        "onUpdate:open": m[0] || (m[0] = (v) => r.value = v)
      }, {
        content: R(() => [
          E("ul", {
            class: "dropdown",
            ref_key: "containerRef",
            ref: i
          }, [
            E("li", P_, [
              k(g, { placement: "right" }, {
                content: R(() => [
                  k(S_, { onEmitTable: o })
                ]),
                default: R(() => [
                  m[1] || (m[1] = E("div", null, "插入表格", -1))
                ]),
                _: 1,
                __: [1]
              })
            ]),
            E("li", {
              class: "dropdown__opeartion",
              onClick: s
            }, "添加行before"),
            E("li", {
              class: "dropdown__opeartion",
              onClick: a
            }, "添加行after"),
            E("li", {
              class: "dropdown__opeartion border_bottom",
              onClick: l
            }, "删除行"),
            E("li", {
              class: "dropdown__opeartion",
              onClick: c
            }, "添加列before"),
            E("li", {
              class: "dropdown__opeartion",
              onClick: d
            }, "添加列after"),
            E("li", {
              class: "dropdown__opeartion border_bottom",
              onClick: u
            }, "删除列"),
            E("li", {
              class: "dropdown__opeartion",
              onClick: f
            }, "合并单元格"),
            E("li", {
              class: "dropdown__opeartion",
              onClick: p
            }, "取消合并单元格")
          ], 512)
        ]),
        default: R(() => [
          k(C, { placement: "top" }, {
            title: R(() => m[2] || (m[2] = [
              E("span", null, "表格", -1)
            ])),
            default: R(() => [
              E("div", B_, [
                k(se(hd), { style: { "font-size": "16px", "font-weight": "600" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), z_ = /* @__PURE__ */ dt($_, [["__scopeId", "data-v-6812c9cd"]]), H_ = { class: "order-lists" }, F_ = ["onClick"], U_ = /* @__PURE__ */ ve({
  __name: "ordered-list",
  props: ["modelValue", "editor"],
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const n = t, r = U(!1), i = U(""), o = [
      {
        type: "chinese",
        icon: "ol-chinese-number"
      },
      {
        type: "decimal",
        icon: "ol-decimal"
      },
      {
        type: "circle",
        icon: "ol-decimal-zero"
      },
      {
        type: "lower-alpha",
        icon: "ol-lower-alpha"
      },
      {
        type: "letter",
        icon: "ol-upper-alpha"
      },
      {
        type: "roman",
        icon: "ol-lower-roman"
      }
    ], s = Ge(() => {
      var l;
      return (l = n.editor) == null ? void 0 : l.isActive("orderedList");
    }), a = (l) => {
      s.value && i.value === l ? n.editor.chain().focus().toggleOrderedList().run() : s.value || n.editor.chain().focus().toggleOrderedList().run(), i.value = l, n.editor.chain().focus().setOrderedStyle(l).updateAttributes("orderedList", { orderedStyle: l }).run(), r.value = !1;
    };
    return (l, c) => {
      const d = ce("a-tooltip"), u = ce("a-popover");
      return B(), ye(u, {
        open: r.value,
        "onUpdate:open": c[0] || (c[0] = (f) => r.value = f),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", H_, [
            (B(), he(Ye, null, bt(o, (f) => E("div", {
              key: f.type,
              class: lt(["order-lists-item", [{ "order-lists__border": s.value && i.value === f.type }]]),
              onClick: (p) => a(f.type)
            }, [
              k(Ot, {
                name: f.icon,
                size: 25
              }, null, 8, ["name"])
            ], 10, F_)), 64))
          ])
        ]),
        default: R(() => [
          E("div", null, [
            k(d, { placement: "top" }, {
              title: R(() => c[1] || (c[1] = [
                E("span", null, " 有序列表", -1)
              ])),
              default: R(() => [
                E("div", {
                  class: lt([
                    "tool ordered_button",
                    {
                      "tool--active": s.value
                    }
                  ])
                }, [
                  k(se(cd), { style: { "font-size": "18px" } }),
                  k(se(Ln), { style: { "font-size": "10px" } })
                ], 2)
              ]),
              _: 1
            })
          ])
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), V_ = /* @__PURE__ */ dt(U_, [["__scopeId", "data-v-f7098b58"]]), j_ = { class: "bullet-lists" }, W_ = ["onClick"], Z_ = /* @__PURE__ */ ve({
  __name: "bullet-List",
  props: ["modelValue", "editor"],
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const n = t, r = U(!1), i = [
      {
        type: "disc",
        icon: "ul-solid-circle"
      },
      {
        type: "circle",
        icon: "ul-hollow-circle"
      },
      {
        type: "square",
        icon: "ul-solid-square"
      }
    ], o = U(""), s = Ge(() => {
      var l;
      return (l = n.editor) == null ? void 0 : l.isActive("bulletList");
    }), a = (l) => {
      s.value && o.value === l ? n.editor.chain().focus().toggleBulletList().run() : s.value || n.editor.chain().focus().toggleBulletList().run(), o.value = l, n.editor.chain().focus().setBulletStyle(l).updateAttributes("bulletList", { bulletStyle: l }).run(), r.value = !1;
    };
    return (l, c) => {
      const d = ce("a-tooltip"), u = ce("a-popover");
      return B(), ye(u, {
        open: r.value,
        "onUpdate:open": c[0] || (c[0] = (f) => r.value = f),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", j_, [
            (B(), he(Ye, null, bt(i, (f) => E("div", {
              key: f.type,
              class: lt(["bullet-lists-item", [{ "bullet-lists__border": s.value && o.value === f.type }]]),
              onClick: (p) => a(f.type)
            }, [
              k(Ot, {
                name: f.icon,
                size: 18
              }, null, 8, ["name"])
            ], 10, W_)), 64))
          ])
        ]),
        default: R(() => [
          k(d, { placement: "top" }, {
            title: R(() => c[1] || (c[1] = [
              E("span", null, " 无序列表", -1)
            ])),
            default: R(() => [
              E("div", {
                class: lt([
                  "tool bullet_button",
                  {
                    "tool--active": s.value
                  }
                ])
              }, [
                k(se(Cd), { style: { "font-size": "18px" } }),
                k(se(Ln), { style: { "font-size": "10px" } })
              ], 2)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), K_ = /* @__PURE__ */ dt(Z_, [["__scopeId", "data-v-33d4a484"]]), G_ = /* @__PURE__ */ ve({
  __name: "link-tool",
  props: ["editor"],
  emits: ["emitUpdate"],
  setup(t, { emit: e }) {
    const n = t, r = [
      {
        formItem: {
          label: "链接",
          name: "href",
          rules: [{ required: !0, validator: il, trigger: "blur" }]
        },
        component: {
          name: "input",
          placeholder: "URL of LINK"
        }
      }
    ], i = U(), o = ({ href: s }) => {
      n.editor.chain().focus().extendMarkRange("link").setLink({
        href: s
      }).run();
    };
    return (s, a) => {
      const l = ce("a-tooltip");
      return B(), he(Ye, null, [
        k(l, { placement: "top" }, {
          title: R(() => a[1] || (a[1] = [
            E("span", null, "链接", -1)
          ])),
          default: R(() => [
            E("div", {
              class: lt(["tool", t.editor.isActive("link") ? "tool--active" : ""]),
              onClick: a[0] || (a[0] = (c) => i.value.showModal())
            }, [
              k(se(id), { style: { "font-size": "16px", "font-weight": "600" } })
            ], 2)
          ]),
          _: 1
        }),
        k(ol, {
          ref_key: "linkRef",
          ref: i,
          onEmitInsert: o,
          options: { title: "插入链接", headers: r }
        }, null, 8, ["options"])
      ], 64);
    };
  }
}), q_ = Symbol("isFullScreen"), l2 = Symbol("toggleFullscreen"), Q_ = /* @__PURE__ */ ve({
  __name: "fullscreen",
  props: {
    editor: {}
  },
  setup(t) {
    const e = rc(l2);
    return (n, r) => {
      const i = ce("a-tooltip");
      return B(), ye(i, {
        placement: "top",
        "show-after": 200
      }, {
        title: R(() => r[1] || (r[1] = [
          E("span", null, "全屏", -1)
        ])),
        default: R(() => [
          E("div", {
            class: lt(["tool", n.editor.isActive("ExpandOutlined") ? "tool--active" : ""]),
            onClick: r[0] || (r[0] = //@ts-ignore
            (...o) => se(e) && se(e)(...o))
          }, [
            k(se(Xc), { style: { "font-size": "16px" } })
          ], 2)
        ]),
        _: 1
      });
    };
  }
});
var tr;
class Y_ {
  constructor(e) {
    Kd(this, tr, /* @__PURE__ */ new Map());
    e && Gd(this, tr, e);
  }
  on(e, n) {
    const r = pi(this, tr).get(e) || [];
    return r.push(n), pi(this, tr).set(e, r), () => this.off(e, n);
  }
  off(e, n) {
    const r = pi(this, tr).get(e);
    r && pi(this, tr).set(
      e,
      //@ts-ignore
      r.filter((i) => i !== n)
    );
  }
  emit(e, ...n) {
    const r = pi(this, tr).get(e);
    r == null || r.forEach((i) => i(...n));
  }
  once(e, n) {
    const r = (i) => {
      n(i), this.off(e, r);
    };
    this.on(e, r);
  }
}
tr = new WeakMap();
const ao = new Y_(), J_ = { class: "find-header" }, X_ = { class: "icon-left" }, eE = { class: "tabs" }, tE = { class: "search-card" }, nE = { class: "input" }, rE = { style: { color: "#409eff" } }, iE = { class: "input" }, oE = { class: "search-action" }, sE = /* @__PURE__ */ ve({
  __name: "find-replace",
  props: ["modelValue", "editor", "visible", "closeModal"],
  setup(t) {
    const e = t, n = L4("el"), r = U(""), i = U(""), o = U(0), s = U(0);
    ao.on("search", (v) => a(v));
    const a = (v) => {
      o.value = v.decorations.length, s.value = v.activeIndex + 1;
    }, l = () => {
      e.editor.chain().findNext().search(r.value).run();
    }, c = () => {
      e.editor.chain().findPrev().search(r.value).run();
    }, d = () => {
      e.editor.chain().replace(i.value).run();
    }, u = () => {
      e.editor.chain().replaceAll(i.value).run();
    }, f = f_(() => {
      e.editor.chain().search(r.value).run();
    }, 1e3), p = () => {
      h(), e.closeModal();
    }, h = () => {
      e.editor.chain().clearSearch().run(), o.value = 0, s.value = 0, i.value = "", r.value = "";
    }, { style: m } = D_(n, {
      initialValue: { x: 100, y: 100 }
    }), g = U(1), C = (v) => {
      g.value = v;
    };
    return (v, _) => {
      const b = ce("a-input"), x = ce("a-button");
      return t.visible ? (B(), he("div", {
        key: 0,
        class: "find-replace",
        style: or(se(m))
      }, [
        E("div", J_, [
          E("div", X_, [
            E("div", {
              class: "icon",
              ref_key: "el",
              ref: n
            }, [
              k(se(Jc))
            ], 512),
            E("div", eE, [
              E("span", {
                class: lt(["tab", g.value === 1 ? "tab_active" : ""]),
                onClick: _[0] || (_[0] = (y) => C(1))
              }, "查找", 2),
              E("span", {
                class: lt(["tab", g.value === 2 ? "tab_active" : ""]),
                onClick: _[1] || (_[1] = (y) => C(2))
              }, "替换", 2)
            ])
          ]),
          E("div", {
            class: "icon",
            onClick: p
          }, [
            k(se(Qc))
          ])
        ]),
        E("div", tE, [
          E("div", nE, [
            k(b, {
              value: r.value,
              "onUpdate:value": _[2] || (_[2] = (y) => r.value = y),
              placeholder: "搜索内容",
              onKeyup: N4(se(f), ["enter"]),
              onChange: se(f)
            }, {
              suffix: R(() => [
                E("span", rE, ft(s.value) + "/" + ft(o.value), 1)
              ]),
              _: 1
            }, 8, ["value", "onKeyup", "onChange"])
          ]),
          za(E("div", iE, [
            k(b, {
              value: i.value,
              "onUpdate:value": _[3] || (_[3] = (y) => i.value = y),
              placeholder: "替换为"
            }, null, 8, ["value"])
          ], 512), [
            [ic, g.value === 2]
          ]),
          E("div", oE, [
            k(x, { onClick: c }, {
              default: R(() => _[4] || (_[4] = [
                Ae("上一个")
              ])),
              _: 1,
              __: [4]
            }),
            k(x, { onClick: l }, {
              default: R(() => _[5] || (_[5] = [
                Ae("下一个")
              ])),
              _: 1,
              __: [5]
            }),
            k(x, { onClick: d }, {
              default: R(() => _[6] || (_[6] = [
                Ae("替换")
              ])),
              _: 1,
              __: [6]
            }),
            k(x, { onClick: u }, {
              default: R(() => _[7] || (_[7] = [
                Ae("全部替换")
              ])),
              _: 1,
              __: [7]
            })
          ])
        ])
      ], 4)) : it("", !0);
    };
  }
}), aE = /* @__PURE__ */ dt(sE, [["__scopeId", "data-v-cf4a59b9"]]), lE = { class: "size-label" }, cE = { class: "label" }, dE = { class: "size-lists" }, uE = ["onClick"], fE = { class: "pr-2" }, pE = /* @__PURE__ */ ve({
  __name: "font-size",
  props: ["modelValue", "editor"],
  setup(t) {
    const e = t, n = U(!1), r = U(14), i = (s) => {
      r.value = s, e.editor.chain().focus().setFontSize(s).run(), n.value = !1;
    }, o = [
      {
        label: "12",
        value: 12
      },
      {
        label: "14",
        value: 14
      },
      {
        label: "16",
        value: 16
      },
      {
        label: "18",
        value: 18
      },
      {
        label: "22",
        value: 22
      },
      {
        label: "24",
        value: 24
      },
      {
        label: "26",
        value: 26
      },
      {
        label: "28",
        value: 28
      },
      {
        label: "36",
        value: 36
      },
      {
        label: "48",
        value: 48
      },
      {
        label: "72",
        value: 72
      }
    ];
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), ye(c, {
        open: n.value,
        "onUpdate:open": a[1] || (a[1] = (d) => n.value = d),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", dE, [
            (B(), he(Ye, null, bt(o, (d) => E("div", {
              class: "size-lists-text size-lists-item",
              onClick: (u) => i(d.value),
              key: d.value
            }, [
              E("span", fE, ft(d.label), 1),
              r.value === d.value ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ], 8, uE)), 64))
          ])
        ]),
        default: R(() => [
          k(l, { placement: "top" }, {
            title: R(() => a[2] || (a[2] = [
              E("span", null, " 字号", -1)
            ])),
            default: R(() => [
              E("div", {
                class: "tool font-size",
                onClick: a[0] || (a[0] = (d) => n.value = !n.value)
              }, [
                E("div", lE, [
                  E("span", cE, ft(r.value), 1)
                ]),
                k(se(Ln), { style: { "font-size": "10px" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), hE = { class: "x-flex" }, gE = ["onClick"], mE = /* @__PURE__ */ ve({
  __name: "font-align",
  props: ["modelValue", "editor"],
  setup(t) {
    const e = t, n = U(!1), r = U(sa), i = (s) => {
      r.value = s.icon, e.editor.chain().focus().setTextAlign(s.name).run(), n.value = !1;
    }, o = [
      {
        name: "left",
        icon: sa,
        prompt: "左对齐"
      },
      {
        name: "center",
        icon: jc,
        prompt: "居中对齐"
      },
      {
        name: "right",
        icon: Wc,
        prompt: "右对齐"
      },
      {
        name: "justify",
        icon: sd,
        prompt: "两端对齐"
      }
    ];
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), ye(c, {
        open: n.value,
        "onUpdate:open": a[1] || (a[1] = (d) => n.value = d),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", hE, [
            (B(), he(Ye, null, bt(o, (d) => E("div", {
              class: "item",
              onClick: (u) => i(d),
              key: d.name
            }, [
              k(l, { placement: "bottom" }, {
                title: R(() => [
                  E("span", null, ft(d.prompt), 1)
                ]),
                default: R(() => [
                  (B(), ye(js(d.icon), { style: { "font-size": "16px" } }))
                ]),
                _: 2
              }, 1024)
            ], 8, gE)), 64))
          ])
        ]),
        default: R(() => [
          k(l, { placement: "top" }, {
            title: R(() => a[2] || (a[2] = [
              E("span", null, "对齐方式", -1)
            ])),
            default: R(() => [
              E("div", {
                class: "tool font-size",
                onClick: a[0] || (a[0] = (d) => n.value = !n.value)
              }, [
                (B(), ye(js(r.value), { style: { "font-size": "16px" } })),
                k(se(Ln), { style: { "font-size": "10px" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), CE = /* @__PURE__ */ ve({
  __name: "format-brush",
  props: ["editor"],
  setup(t) {
    const e = t, n = U(), r = () => {
      clearTimeout(n.value), n.value = setTimeout(() => {
        e.editor.chain().focus().copyFormat({ type: "click" }).run();
      }, 300);
    }, i = () => {
      clearTimeout(n.value), e.editor.chain().focus().copyFormat({ type: "dblclick" }).run();
    };
    return (o, s) => {
      const a = ce("a-tooltip");
      return B(), ye(a, {
        placement: "top",
        "show-after": 200
      }, {
        title: R(() => s[0] || (s[0] = [
          Ae(" 格式刷 ")
        ])),
        default: R(() => [
          E("div", {
            class: lt(["tool", t.editor.isActive("formatBrush") ? "tool--active" : ""]),
            onClick: r,
            onDblclick: i
          }, [
            k(se(qc))
          ], 34)
        ]),
        _: 1
      });
    };
  }
}), bE = { class: "size-label" }, yE = { class: "label" }, vE = { class: "size-lists" }, wE = ["onClick"], _E = { class: "pr-2" }, EE = /* @__PURE__ */ ve({
  __name: "line-height",
  props: ["modelValue", "editor"],
  setup(t) {
    const e = t, n = U(!1), r = U(1), i = (s) => {
      r.value = s;
      const a = s * 100 + "%";
      e.editor.chain().focus().setLineHeight(a).run(), n.value = !1;
    }, o = [
      {
        label: "1.0",
        value: 1
      },
      {
        label: "1.25",
        value: 1.25
      },
      {
        label: "2.0",
        value: 2
      },
      {
        label: "2.5",
        value: 2.5
      },
      {
        label: "3.0",
        value: 3
      }
    ];
    return (s, a) => {
      const l = ce("a-tooltip"), c = ce("a-popover");
      return B(), ye(c, {
        open: n.value,
        "onUpdate:open": a[1] || (a[1] = (d) => n.value = d),
        placement: "bottom",
        trigger: "click"
      }, {
        content: R(() => [
          E("div", vE, [
            (B(), he(Ye, null, bt(o, (d) => E("div", {
              class: "size-lists-text size-lists-item",
              onClick: (u) => i(d.value),
              key: d.value
            }, [
              E("span", _E, ft(d.label), 1),
              r.value === d.value ? (B(), ye(Ot, {
                key: 0,
                name: "correct"
              })) : it("", !0)
            ], 8, wE)), 64))
          ])
        ]),
        default: R(() => [
          k(l, { placement: "top" }, {
            title: R(() => a[2] || (a[2] = [
              E("span", null, " 行高", -1)
            ])),
            default: R(() => [
              E("div", {
                class: "tool font-size",
                onClick: a[0] || (a[0] = (d) => n.value = !n.value)
              }, [
                E("div", bE, [
                  E("span", yE, ft(r.value), 1)
                ]),
                k(se(Ln), { style: { "font-size": "10px" } })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), xE = { class: "toolbar" }, kE = /* @__PURE__ */ ve({
  __name: "index",
  props: {
    editor: {}
  },
  setup(t) {
    const { visible: e, toggleModal: n, closeModal: r } = Oy(), o = Ct(
      My(t.editor, {
        searchoutlined: {
          toggleModal: n
        }
      })
    );
    return (s, a) => (B(), he("div", xE, [
      (B(!0), he(Ye, null, bt(o, (l) => (B(), ye(Ty, {
        editor: s.editor,
        option: l,
        key: l.name
      }, null, 8, ["editor", "option"]))), 128)),
      k(G_, { editor: s.editor }, null, 8, ["editor"]),
      k(se(Ry)),
      k(CE, { editor: s.editor }, null, 8, ["editor"]),
      k(pE, { editor: s.editor }, null, 8, ["editor"]),
      k(EE, { editor: s.editor }, null, 8, ["editor"]),
      k(xw, { editor: s.editor }, null, 8, ["editor"]),
      k(Tw, { editor: s.editor }, null, 8, ["editor"]),
      k(Iw, { editor: s.editor }, null, 8, ["editor"]),
      k(zw, { editor: s.editor }, null, 8, ["editor"]),
      k(C_, { editor: s.editor }, null, 8, ["editor"]),
      k(v_, { editor: s.editor }, null, 8, ["editor"]),
      k(E_, { editor: s.editor }, null, 8, ["editor"]),
      k(z_, { editor: s.editor }, null, 8, ["editor"]),
      k(mE, { editor: s.editor }, null, 8, ["editor"]),
      k(V_, { editor: s.editor }, null, 8, ["editor"]),
      k(K_, { editor: s.editor }, null, 8, ["editor"]),
      k(Q_, { editor: s.editor }, null, 8, ["editor"]),
      (B(), ye(A4, { to: "body" }, [
        k(aE, {
          editor: s.editor,
          visible: se(e),
          closeModal: se(r)
        }, null, 8, ["editor", "visible", "closeModal"])
      ])),
      Vi(s.$slots, "tool", {}, void 0, !0)
    ]));
  }
}), SE = /* @__PURE__ */ dt(kE, [["__scopeId", "data-v-c4e30eba"]]), ME = vn.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), OE = (t) => {
  if (!t.children.length)
    return;
  const e = t.querySelectorAll("span");
  e && e.forEach((n) => {
    var r, i;
    const o = n.getAttribute("style"), s = (i = (r = n.parentElement) === null || r === void 0 ? void 0 : r.closest("span")) === null || i === void 0 ? void 0 : i.getAttribute("style");
    n.setAttribute("style", `${s};${o}`);
  });
}, TE = vn.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !1
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && OE(t), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: t }) => {
        const { selection: e } = t;
        return t.doc.nodesBetween(e.from, e.to, (n, r) => {
          if (n.isTextblock)
            return !0;
          n.marks.filter((i) => i.type === this.type).some((i) => Object.values(i.attrs).some((o) => !!o)) || t.removeMark(r, r + n.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), LE = qe.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), NE = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, AE = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, RE = vn.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", Be(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      ai({
        find: NE,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dr({
        find: AE,
        type: this.type
      })
    ];
  }
}), IE = qe.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e),
      toggleTextAlign: (t) => ({ editor: e, commands: n }) => this.options.alignments.includes(t) ? e.isActive({ textAlign: t }) ? n.unsetTextAlign() : n.setTextAlign(t) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), DE = qe.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
});
var V1, j1;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  V1 = (e) => t.get(e), j1 = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  V1 = (r) => {
    for (let i = 0; i < t.length; i += 2)
      if (t[i] == r) return t[i + 1];
  }, j1 = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i);
}
var tt = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t) continue;
      const r = e % this.width, i = e / this.width | 0;
      let o = r + 1, s = i + 1;
      for (let a = 1; o < this.width && this.map[e + a] == n; a++)
        o++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
        s++;
      return { left: r, top: i, right: o, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: i, top: o, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[o * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? o == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? o - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: r,
      top: i,
      bottom: o
    } = this.findCell(t), {
      left: s,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(i, l),
      right: Math.max(r, a),
      bottom: Math.max(o, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let i = t.left; i < t.right; i++) {
        const o = r * this.width + i, s = this.map[o];
        n[s] || (n[s] = !0, !(i == t.left && i && this.map[o - 1] == s || r == t.top && r && this.map[o - this.width] == s) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, i = 0; ; r++) {
      const o = i + n.child(r).nodeSize;
      if (r == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < i; ) s++;
        return s == a ? o - 1 : this.map[s];
      }
      i = o;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return V1(t) || j1(t, PE(t));
  }
};
function PE(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = BE(t), n = t.childCount, r = [];
  let i = 0, o = null;
  const s = [];
  for (let c = 0, d = e * n; c < d; c++) r[c] = 0;
  for (let c = 0, d = 0; c < n; c++) {
    const u = t.child(c);
    d++;
    for (let h = 0; ; h++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (h == u.childCount) break;
      const m = u.child(h), { colspan: g, rowspan: C, colwidth: v } = m.attrs;
      for (let _ = 0; _ < C; _++) {
        if (_ + c >= n) {
          (o || (o = [])).push({
            type: "overlong_rowspan",
            pos: d,
            n: C - _
          });
          break;
        }
        const b = i + _ * e;
        for (let x = 0; x < g; x++) {
          r[b + x] == 0 ? r[b + x] = d : (o || (o = [])).push({
            type: "collision",
            row: c,
            pos: d,
            n: g - x
          });
          const y = v && v[x];
          if (y) {
            const M = (b + x) % e * 2, S = s[M];
            S == null || S != y && s[M + 1] == 1 ? (s[M] = y, s[M + 1] = 1) : S == y && s[M + 1]++;
          }
        }
      }
      i += g, d += m.nodeSize;
    }
    const f = (c + 1) * e;
    let p = 0;
    for (; i < f; ) r[i++] == 0 && p++;
    p && (o || (o = [])).push({ type: "missing", row: c, n: p }), d++;
  }
  (e === 0 || n === 0) && (o || (o = [])).push({ type: "zero_sized" });
  const a = new tt(e, n, r, o);
  let l = !1;
  for (let c = 0; !l && c < s.length; c += 2)
    s[c] != null && s[c + 1] < n && (l = !0);
  return l && $E(a, s, t), a;
}
function BE(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r);
    let o = 0;
    if (n)
      for (let s = 0; s < r; s++) {
        const a = t.child(s);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          s + c.attrs.rowspan > r && (o += c.attrs.colspan);
        }
      }
    for (let s = 0; s < i.childCount; s++) {
      const a = i.child(s);
      o += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = o : e != o && (e = Math.max(e, o));
  }
  return e;
}
function $E(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let i = 0; i < t.map.length; i++) {
    const o = t.map[i];
    if (r[o]) continue;
    r[o] = !0;
    const s = n.nodeAt(o);
    if (!s)
      throw new RangeError(`No cell with offset ${o} found`);
    let a = null;
    const l = s.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const d = (i + c) % t.width, u = e[d * 2];
      u != null && (!l.colwidth || l.colwidth[c] != u) && ((a || (a = zE(l)))[c] = u);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: o,
      colwidth: a
    });
  }
}
function zE(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++) e.push(0);
  return e;
}
function Dt(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var vr = new ct("selectingCells");
function Zi(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function HE(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return t.node(e);
  }
  return null;
}
function Nn(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function sl(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = Zi(e.$head) || FE(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function FE(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function W1(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function UE(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Ed(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function c2(t, e, n) {
  const r = t.node(-1), i = tt.get(r), o = t.start(-1), s = i.nextCell(t.pos - o, e, n);
  return s == null ? null : t.node(0).resolve(o + s);
}
function ci(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function d2(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < n; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function VE(t, e, n) {
  const r = Dt(e.type.schema).header_cell;
  for (let i = 0; i < t.height; i++)
    if (e.nodeAt(t.map[n + i * t.width]).type != r)
      return !1;
  return !0;
}
var je = class Yn extends le {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), i = tt.get(r), o = e.start(-1), s = i.rectBetween(
      e.pos - o,
      n.pos - o
    ), a = e.node(0), l = i.cellsInRect(s).filter((d) => d != n.pos - o);
    l.unshift(n.pos - o);
    const c = l.map((d) => {
      const u = r.nodeAt(d);
      if (!u)
        throw RangeError(`No cell with offset ${d} found`);
      const f = o + d + 1;
      return new a0(
        a.resolve(f),
        a.resolve(f + u.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
    if (W1(r) && W1(i) && Ed(r, i)) {
      const o = this.$anchorCell.node(-1) != r.node(-1);
      return o && this.isRowSelection() ? Yn.rowSelection(r, i) : o && this.isColSelection() ? Yn.colSelection(r, i) : new Yn(r, i);
    }
    return ie.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = tt.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), o = {}, s = [];
    for (let l = i.top; l < i.bottom; l++) {
      const c = [];
      for (let d = l * n.width + i.left, u = i.left; u < i.right; u++, d++) {
        const f = n.map[d];
        if (o[f]) continue;
        o[f] = !0;
        const p = n.findCell(f);
        let h = e.nodeAt(f);
        if (!h)
          throw RangeError(`No cell with offset ${f} found`);
        const m = i.left - p.left, g = p.right - i.right;
        if (m > 0 || g > 0) {
          let C = h.attrs;
          if (m > 0 && (C = ci(C, 0, m)), g > 0 && (C = ci(
            C,
            C.colspan - g,
            g
          )), p.left < i.left) {
            if (h = h.type.createAndFill(C), !h)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(C)}`
              );
          } else
            h = h.type.create(C, h.content);
        }
        if (p.top < i.top || p.bottom > i.bottom) {
          const C = {
            ...h.attrs,
            rowspan: Math.min(p.bottom, i.bottom) - Math.max(p.top, i.top)
          };
          p.top < i.top ? h = h.type.createAndFill(C) : h = h.type.create(C, h.content);
        }
        c.push(h);
      }
      s.push(e.child(l).copy(A.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new F(A.from(a), 1, 1);
  }
  replace(e, n = F.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      const { $from: a, $to: l } = i[s], c = e.mapping.slice(r);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        s ? F.empty : n
      );
    }
    const o = le.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    o && e.setSelection(o);
  }
  replaceWith(e, n) {
    this.replace(e, new F(A.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = tt.get(n), i = this.$anchorCell.start(-1), o = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let s = 0; s < o.length; s++)
      e(n.nodeAt(o[s]), i + o[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), i = tt.get(r), o = e.start(-1), s = i.findCell(e.pos - o), a = i.findCell(n.pos - o), l = e.node(0);
    return s.top <= a.top ? (s.top > 0 && (e = l.resolve(o + i.map[s.left])), a.bottom < i.height && (n = l.resolve(
      o + i.map[i.width * (i.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(o + i.map[a.left])), s.bottom < i.height && (e = l.resolve(
      o + i.map[i.width * (i.height - 1) + s.right - 1]
    ))), new Yn(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = tt.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), o = n.colCount(this.$headCell.pos - r);
    if (Math.min(i, o) > 0) return !1;
    const s = i + this.$anchorCell.nodeAfter.attrs.colspan, a = o + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return e instanceof Yn && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), i = tt.get(r), o = e.start(-1), s = i.findCell(e.pos - o), a = i.findCell(n.pos - o), l = e.node(0);
    return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
      o + i.map[s.top * i.width]
    )), a.right < i.width && (n = l.resolve(
      o + i.map[i.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(o + i.map[a.top * i.width])), s.right < i.width && (e = l.resolve(
      o + i.map[i.width * (s.top + 1) - 1]
    ))), new Yn(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Yn(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Yn(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new jE(this.$anchorCell.pos, this.$headCell.pos);
  }
};
je.prototype.visible = !1;
le.jsonID("cell", je);
var jE = class u2 {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new u2(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && Ed(n, r) ? new je(n, r) : le.near(r, 1);
  }
};
function WE(t) {
  if (!(t.selection instanceof je)) return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(
      Tt.node(r, r + n.nodeSize, { class: "selectedCell" })
    );
  }), Ke.create(t.doc, e);
}
function ZE({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let n = t.pos, r = e.pos, i = t.depth;
  for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++)
    ;
  for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--)
    ;
  return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function KE({ $from: t, $to: e }) {
  let n, r;
  for (let i = t.depth; i > 0; i--) {
    const o = t.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      n = o;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const o = e.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      r = o;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function GE(t, e, n) {
  const r = (e || t).selection, i = (e || t).doc;
  let o, s;
  if (r instanceof ne && (s = r.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell")
      o = je.create(i, r.from);
    else if (s == "row") {
      const a = i.resolve(r.from + 1);
      o = je.rowSelection(a, a);
    } else if (!n) {
      const a = tt.get(r.node), l = r.from + 1, c = l + a.map[a.width * a.height - 1];
      o = je.create(i, l + 1, c);
    }
  } else r instanceof ie && ZE(r) ? o = ie.create(i, r.from) : r instanceof ie && KE(r) && (o = ie.create(i, r.$from.start(), r.$from.end()));
  return o && (e || (e = t.tr)).setSelection(o), e;
}
var qE = new ct("fix-tables");
function f2(t, e, n, r) {
  const i = t.childCount, o = e.childCount;
  e: for (let s = 0, a = 0; s < o; s++) {
    const l = e.child(s);
    for (let c = a, d = Math.min(i, s + 3); c < d; c++)
      if (t.child(c) == l) {
        a = c + 1, n += l.nodeSize;
        continue e;
      }
    r(l, n), a < i && t.child(a).sameMarkup(l) ? f2(t.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
  }
}
function p2(t, e) {
  let n;
  const r = (i, o) => {
    i.type.spec.tableRole == "table" && (n = QE(t, i, o, n));
  };
  return e ? e.doc != t.doc && f2(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function QE(t, e, n, r) {
  const i = tt.get(e);
  if (!i.problems) return r;
  r || (r = t.tr);
  const o = [];
  for (let l = 0; l < i.height; l++) o.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const c = i.problems[l];
    if (c.type == "collision") {
      const d = e.nodeAt(c.pos);
      if (!d) continue;
      const u = d.attrs;
      for (let f = 0; f < u.rowspan; f++) o[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + c.pos),
        null,
        ci(u, u.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      o[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const d = e.nodeAt(c.pos);
      if (!d) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...d.attrs,
        rowspan: d.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const d = e.nodeAt(c.pos);
      if (!d) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...d.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const d = r.mapping.map(n);
      r.delete(d, d + e.nodeSize);
    }
  }
  let s, a;
  for (let l = 0; l < o.length; l++)
    o[l] && (s == null && (s = l), a = l);
  for (let l = 0, c = n + 1; l < i.height; l++) {
    const d = e.child(l), u = c + d.nodeSize, f = o[l];
    if (f > 0) {
      let p = "cell";
      d.firstChild && (p = d.firstChild.type.spec.tableRole);
      const h = [];
      for (let g = 0; g < f; g++) {
        const C = Dt(t.schema)[p].createAndFill();
        C && h.push(C);
      }
      const m = (l == 0 || s == l - 1) && a == l ? c + 1 : u - 1;
      r.insert(r.mapping.map(m), h);
    }
    c = u;
  }
  return r.setMeta(qE, { fixTables: !0 });
}
function Wn(t) {
  const e = t.selection, n = sl(t), r = n.node(-1), i = n.start(-1), o = tt.get(r);
  return { ...e instanceof je ? o.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : o.findCell(n.pos - i), tableStart: i, map: o, table: r };
}
function h2(t, { map: e, tableStart: n, table: r }, i) {
  let o = i > 0 ? -1 : 0;
  VE(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + i;
    if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = r.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        d2(c.attrs, i - e.colCount(l))
      ), s += c.attrs.rowspan - 1;
    } else {
      const l = o == null ? Dt(r.type.schema).cell : r.nodeAt(e.map[a + o]).type, c = e.positionAt(s, i, r);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function YE(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t);
    e(h2(t.tr, n, n.left));
  }
  return !0;
}
function JE(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t);
    e(h2(t.tr, n, n.right));
  }
  return !0;
}
function XE(t, { map: e, table: n, tableStart: r }, i) {
  const o = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + i, l = e.map[a], c = n.nodeAt(l), d = c.attrs;
    if (i > 0 && e.map[a - 1] == l || i < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(o).map(r + l),
        null,
        ci(d, i - e.colCount(l))
      );
    else {
      const u = t.mapping.slice(o).map(r + l);
      t.delete(u, u + c.nodeSize);
    }
    s += d.rowspan;
  }
}
function ex(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let i = n.right - 1; XE(r, n, i), i != n.left; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = tt.get(o);
    }
    e(r);
  }
  return !0;
}
function tx(t, e, n) {
  var r;
  const i = Dt(e.type.schema).header_cell;
  for (let o = 0; o < t.width; o++)
    if (((r = e.nodeAt(t.map[o + n * t.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function g2(t, { map: e, tableStart: n, table: r }, i) {
  var o;
  let s = n;
  for (let c = 0; c < i; c++) s += r.child(c).nodeSize;
  const a = [];
  let l = i > 0 ? -1 : 0;
  tx(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
  for (let c = 0, d = e.width * i; c < e.width; c++, d++)
    if (i > 0 && i < e.height && e.map[d] == e.map[d - e.width]) {
      const u = e.map[d], f = r.nodeAt(u).attrs;
      t.setNodeMarkup(n + u, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const u = l == null ? Dt(r.type.schema).cell : (o = r.nodeAt(e.map[d + l * e.width])) == null ? void 0 : o.type, f = u == null ? void 0 : u.createAndFill();
      f && a.push(f);
    }
  return t.insert(s, Dt(r.type.schema).row.create(null, a)), t;
}
function nx(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t);
    e(g2(t.tr, n, n.top));
  }
  return !0;
}
function rx(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t);
    e(g2(t.tr, n, n.bottom));
  }
  return !0;
}
function ix(t, { map: e, table: n, tableStart: r }, i) {
  let o = 0;
  for (let c = 0; c < i; c++) o += n.child(c).nodeSize;
  const s = o + n.child(i).nodeSize, a = t.mapping.maps.length;
  t.delete(o + r, s + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, d = i * e.width; c < e.width; c++, d++) {
    const u = e.map[d];
    if (!l.has(u)) {
      if (l.add(u), i > 0 && u == e.map[d - e.width]) {
        const f = n.nodeAt(u).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(u + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && u == e.map[d + e.width]) {
        const f = n.nodeAt(u), p = f.attrs, h = f.type.create(
          { ...p, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(i + 1, c, n);
        t.insert(t.mapping.slice(a).map(r + m), h), c += p.colspan - 1;
      }
    }
  }
}
function ox(t, e) {
  if (!Nn(t)) return !1;
  if (e) {
    const n = Wn(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let i = n.bottom - 1; ix(r, n, i), i != n.top; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = tt.get(n.table);
    }
    e(r);
  }
  return !0;
}
function $p(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function sx({ width: t, height: e, map: n }, r) {
  let i = r.top * t + r.left, o = i, s = (r.bottom - 1) * t + r.left, a = i + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[o] == n[o - 1] || r.right < t && n[a] == n[a + 1])
      return !0;
    o += t, a += t;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[s] == n[s + t])
      return !0;
    i++, s++;
  }
  return !1;
}
function zp(t, e) {
  const n = t.selection;
  if (!(n instanceof je) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const r = Wn(t), { map: i } = r;
  if (sx(i, r)) return !1;
  if (e) {
    const o = t.tr, s = {};
    let a = A.empty, l, c;
    for (let d = r.top; d < r.bottom; d++)
      for (let u = r.left; u < r.right; u++) {
        const f = i.map[d * i.width + u], p = r.table.nodeAt(f);
        if (!(s[f] || !p))
          if (s[f] = !0, l == null)
            l = f, c = p;
          else {
            $p(p) || (a = a.append(p.content));
            const h = o.mapping.map(f + r.tableStart);
            o.delete(h, h + p.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (o.setNodeMarkup(l + r.tableStart, null, {
      ...d2(
        c.attrs,
        c.attrs.colspan,
        r.right - r.left - c.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), a.size) {
      const d = l + 1 + c.content.size, u = $p(c) ? l + 1 : d;
      o.replaceWith(u + r.tableStart, d + r.tableStart, a);
    }
    o.setSelection(
      new je(o.doc.resolve(l + r.tableStart))
    ), e(o);
  }
  return !0;
}
function Hp(t, e) {
  const n = Dt(t.schema);
  return ax(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function ax(t) {
  return (e, n) => {
    var r;
    const i = e.selection;
    let o, s;
    if (i instanceof je) {
      if (i.$anchorCell.pos != i.$headCell.pos) return !1;
      o = i.$anchorCell.nodeAfter, s = i.$anchorCell.pos;
    } else {
      if (o = HE(i.$from), !o) return !1;
      s = (r = Zi(i.$from)) == null ? void 0 : r.pos;
    }
    if (o == null || s == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = o.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const d = Wn(e), u = e.tr;
      for (let p = 0; p < d.right - d.left; p++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[p] ? [c[p]] : null
          } : a
        );
      let f;
      for (let p = d.top; p < d.bottom; p++) {
        let h = d.map.positionAt(p, d.left, d.table);
        p == d.top && (h += o.nodeSize);
        for (let m = d.left, g = 0; m < d.right; m++, g++)
          m == d.left && p == d.top || u.insert(
            f = u.mapping.map(h + d.tableStart, 1),
            t({ node: o, row: p, col: m }).createAndFill(l[g])
          );
      }
      u.setNodeMarkup(
        s,
        t({ node: o, row: d.top, col: d.left }),
        l[0]
      ), i instanceof je && u.setSelection(
        new je(
          u.doc.resolve(i.$anchorCell.pos),
          f ? u.doc.resolve(f) : void 0
        )
      ), n(u);
    }
    return !0;
  };
}
function lx(t, e) {
  return function(n, r) {
    if (!Nn(n)) return !1;
    const i = sl(n);
    if (i.nodeAfter.attrs[t] === e) return !1;
    if (r) {
      const o = n.tr;
      n.selection instanceof je ? n.selection.forEachCell((s, a) => {
        s.attrs[t] !== e && o.setNodeMarkup(a, null, {
          ...s.attrs,
          [t]: e
        });
      }) : o.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [t]: e
      }), r(o);
    }
    return !0;
  };
}
function cx(t) {
  return function(e, n) {
    if (!Nn(e)) return !1;
    if (n) {
      const r = Dt(e.schema), i = Wn(e), o = e.tr, s = i.map.cellsInRect(
        t == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : t == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), a = s.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < s.length; l++)
        a[l].type == r.header_cell && o.setNodeMarkup(
          i.tableStart + s[l],
          r.cell,
          a[l].attrs
        );
      if (o.steps.length == 0)
        for (let l = 0; l < s.length; l++)
          o.setNodeMarkup(
            i.tableStart + s[l],
            r.header_cell,
            a[l].attrs
          );
      n(o);
    }
    return !0;
  };
}
function Fp(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const o = e.table.nodeAt(r[i]);
    if (o && o.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function $o(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? cx(t) : function(n, r) {
    if (!Nn(n)) return !1;
    if (r) {
      const i = Dt(n.schema), o = Wn(n), s = n.tr, a = Fp("row", o, i), l = Fp(
        "column",
        o,
        i
      ), d = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, u = t == "column" ? {
        left: 0,
        top: d,
        right: 1,
        bottom: o.map.height
      } : t == "row" ? {
        left: d,
        top: 0,
        right: o.map.width,
        bottom: 1
      } : o, f = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? a ? i.cell : i.header_cell : i.cell;
      o.map.cellsInRect(u).forEach((p) => {
        const h = p + o.tableStart, m = s.doc.nodeAt(h);
        m && s.setNodeMarkup(h, f, m.attrs);
      }), r(s);
    }
    return !0;
  };
}
$o("row", {
  useDeprecatedLogic: !0
});
$o("column", {
  useDeprecatedLogic: !0
});
var dx = $o("cell", {
  useDeprecatedLogic: !0
});
function ux(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n) return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
      const o = t.node(-1).child(r), s = o.lastChild;
      if (s)
        return i - 1 - s.nodeSize;
      i -= o.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
      const o = n.child(r);
      if (o.childCount) return i + 1;
      i += o.nodeSize;
    }
  }
  return null;
}
function Up(t) {
  return function(e, n) {
    if (!Nn(e)) return !1;
    const r = ux(sl(e), t);
    if (r == null) return !1;
    if (n) {
      const i = e.doc.resolve(r);
      n(
        e.tr.setSelection(ie.between(i, UE(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function fx(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function ws(t, e) {
  const n = t.selection;
  if (!(n instanceof je)) return !1;
  if (e) {
    const r = t.tr, i = Dt(t.schema).cell.createAndFill().content;
    n.forEachCell((o, s) => {
      o.content.eq(i) || r.replace(
        r.mapping.map(s + 1),
        r.mapping.map(s + o.nodeSize - 1),
        new F(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function px(t) {
  if (!t.size) return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const i = e.child(0), o = i.type.spec.tableRole, s = i.type.schema, a = [];
  if (o == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const d = l ? 0 : Math.max(0, n - 1), u = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (d || u) && (c = Z1(
        Dt(s).row,
        new F(c, d, u)
      ).content), a.push(c);
    }
  else if (o == "cell" || o == "header_cell")
    a.push(
      n || r ? Z1(
        Dt(s).row,
        new F(e, n, r)
      ).content : e
    );
  else
    return null;
  return hx(s, a);
}
function hx(t, e) {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const o = e[i];
    for (let s = o.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = o.child(s).attrs;
      for (let c = i; c < i + a; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < n.length; i++) r = Math.max(r, n[i]);
  for (let i = 0; i < n.length; i++)
    if (i >= e.length && e.push(A.empty), n[i] < r) {
      const o = Dt(t).cell.createAndFill(), s = [];
      for (let a = n[i]; a < r; a++)
        s.push(o);
      e[i] = e[i].append(A.from(s));
    }
  return { height: e.length, width: r, rows: e };
}
function Z1(t, e) {
  const n = t.createAndFill();
  return new lc(n).replace(0, n.content.size, e).doc;
}
function gx({ width: t, height: e, rows: n }, r, i) {
  if (t != r) {
    const o = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let d = o[a] || 0, u = 0; d < r; u++) {
        let f = l.child(u % l.childCount);
        d + f.attrs.colspan > r && (f = f.type.createChecked(
          ci(
            f.attrs,
            f.attrs.colspan,
            d + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), d += f.attrs.colspan;
        for (let p = 1; p < f.attrs.rowspan; p++)
          o[a + p] = (o[a + p] || 0) + f.attrs.colspan;
      }
      s.push(A.from(c));
    }
    n = s, t = r;
  }
  if (e != i) {
    const o = [];
    for (let s = 0, a = 0; s < i; s++, a++) {
      const l = [], c = n[a % e];
      for (let d = 0; d < c.childCount; d++) {
        let u = c.child(d);
        s + u.attrs.rowspan > i && (u = u.type.create(
          {
            ...u.attrs,
            rowspan: Math.max(1, i - u.attrs.rowspan)
          },
          u.content
        )), l.push(u);
      }
      o.push(A.from(l));
    }
    n = o, e = i;
  }
  return { width: t, height: e, rows: n };
}
function mx(t, e, n, r, i, o, s) {
  const a = t.doc.type.schema, l = Dt(a);
  let c, d;
  if (i > e.width)
    for (let u = 0, f = 0; u < e.height; u++) {
      const p = n.child(u);
      f += p.nodeSize;
      const h = [];
      let m;
      p.lastChild == null || p.lastChild.type == l.cell ? m = c || (c = l.cell.createAndFill()) : m = d || (d = l.header_cell.createAndFill());
      for (let g = e.width; g < i; g++) h.push(m);
      t.insert(t.mapping.slice(s).map(f - 1 + r), h);
    }
  if (o > e.height) {
    const u = [];
    for (let h = 0, m = (e.height - 1) * e.width; h < Math.max(e.width, i); h++) {
      const g = h >= e.width ? !1 : n.nodeAt(e.map[m + h]).type == l.header_cell;
      u.push(
        g ? d || (d = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, A.from(u)), p = [];
    for (let h = e.height; h < o; h++) p.push(f);
    t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), p);
  }
  return !!(c || d);
}
function Vp(t, e, n, r, i, o, s, a) {
  if (s == 0 || s == e.height) return !1;
  let l = !1;
  for (let c = i; c < o; c++) {
    const d = s * e.width + c, u = e.map[d];
    if (e.map[d - e.width] == u) {
      l = !0;
      const f = n.nodeAt(u), { top: p, left: h } = e.findCell(u);
      t.setNodeMarkup(t.mapping.slice(a).map(u + r), null, {
        ...f.attrs,
        rowspan: s - p
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(s, h, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: p + f.attrs.rowspan - s
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function jp(t, e, n, r, i, o, s, a) {
  if (s == 0 || s == e.width) return !1;
  let l = !1;
  for (let c = i; c < o; c++) {
    const d = c * e.width + s, u = e.map[d];
    if (e.map[d - 1] == u) {
      l = !0;
      const f = n.nodeAt(u), p = e.colCount(u), h = t.mapping.slice(a).map(u + r);
      t.setNodeMarkup(
        h,
        null,
        ci(
          f.attrs,
          s - p,
          f.attrs.colspan - (s - p)
        )
      ), t.insert(
        h + f.nodeSize,
        f.type.createAndFill(
          ci(f.attrs, 0, s - p)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function Wp(t, e, n, r, i) {
  let o = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!o)
    throw new Error("No table found");
  let s = tt.get(o);
  const { top: a, left: l } = r, c = l + i.width, d = a + i.height, u = t.tr;
  let f = 0;
  function p() {
    if (o = n ? u.doc.nodeAt(n - 1) : u.doc, !o)
      throw new Error("No table found");
    s = tt.get(o), f = u.mapping.maps.length;
  }
  mx(u, s, o, n, c, d, f) && p(), Vp(u, s, o, n, l, c, a, f) && p(), Vp(u, s, o, n, l, c, d, f) && p(), jp(u, s, o, n, a, d, l, f) && p(), jp(u, s, o, n, a, d, c, f) && p();
  for (let h = a; h < d; h++) {
    const m = s.positionAt(h, l, o), g = s.positionAt(h, c, o);
    u.replace(
      u.mapping.slice(f).map(m + n),
      u.mapping.slice(f).map(g + n),
      new F(i.rows[h - a], 0, 0)
    );
  }
  p(), u.setSelection(
    new je(
      u.doc.resolve(n + s.positionAt(a, l, o)),
      u.doc.resolve(n + s.positionAt(d - 1, c - 1, o))
    )
  ), e(u);
}
var Cx = yc({
  ArrowLeft: _s("horiz", -1),
  ArrowRight: _s("horiz", 1),
  ArrowUp: _s("vert", -1),
  ArrowDown: _s("vert", 1),
  "Shift-ArrowLeft": Es("horiz", -1),
  "Shift-ArrowRight": Es("horiz", 1),
  "Shift-ArrowUp": Es("vert", -1),
  "Shift-ArrowDown": Es("vert", 1),
  Backspace: ws,
  "Mod-Backspace": ws,
  Delete: ws,
  "Mod-Delete": ws
});
function Fs(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function _s(t, e) {
  return (n, r, i) => {
    if (!i) return !1;
    const o = n.selection;
    if (o instanceof je)
      return Fs(
        n,
        r,
        le.near(o.$headCell, e)
      );
    if (t != "horiz" && !o.empty) return !1;
    const s = m2(i, t, e);
    if (s == null) return !1;
    if (t == "horiz")
      return Fs(
        n,
        r,
        le.near(n.doc.resolve(o.head + e), e)
      );
    {
      const a = n.doc.resolve(s), l = c2(a, t, e);
      let c;
      return l ? c = le.near(l, 1) : e < 0 ? c = le.near(n.doc.resolve(a.before(-1)), -1) : c = le.near(n.doc.resolve(a.after(-1)), 1), Fs(n, r, c);
    }
  };
}
function Es(t, e) {
  return (n, r, i) => {
    if (!i) return !1;
    const o = n.selection;
    let s;
    if (o instanceof je)
      s = o;
    else {
      const l = m2(i, t, e);
      if (l == null) return !1;
      s = new je(n.doc.resolve(l));
    }
    const a = c2(s.$headCell, t, e);
    return a ? Fs(
      n,
      r,
      new je(s.$anchorCell, a)
    ) : !1;
  };
}
function bx(t, e) {
  const n = t.state.doc, r = Zi(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new je(r))), !0) : !1;
}
function yx(t, e, n) {
  if (!Nn(t.state)) return !1;
  let r = px(n);
  const i = t.state.selection;
  if (i instanceof je) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        A.from(
          Z1(Dt(t.state.schema).cell, n)
        )
      ]
    });
    const o = i.$anchorCell.node(-1), s = i.$anchorCell.start(-1), a = tt.get(o).rectBetween(
      i.$anchorCell.pos - s,
      i.$headCell.pos - s
    );
    return r = gx(r, a.right - a.left, a.bottom - a.top), Wp(t.state, t.dispatch, s, a, r), !0;
  } else if (r) {
    const o = sl(t.state), s = o.start(-1);
    return Wp(
      t.state,
      t.dispatch,
      s,
      tt.get(o.node(-1)).findCell(o.pos - s),
      r
    ), !0;
  } else
    return !1;
}
function vx(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey) return;
  const r = Zp(t, e.target);
  let i;
  if (e.shiftKey && t.state.selection instanceof je)
    o(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = Zi(t.state.selection.$anchor)) != null && ((n = Jl(t, e)) == null ? void 0 : n.pos) != i.pos)
    o(i, e), e.preventDefault();
  else if (!r)
    return;
  function o(l, c) {
    let d = Jl(t, c);
    const u = vr.getState(t.state) == null;
    if (!d || !Ed(l, d))
      if (u) d = l;
      else return;
    const f = new je(l, d);
    if (u || !t.state.selection.eq(f)) {
      const p = t.state.tr.setSelection(f);
      u && p.setMeta(vr, l.pos), t.dispatch(p);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), vr.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(vr, -1));
  }
  function a(l) {
    const c = l, d = vr.getState(t.state);
    let u;
    if (d != null)
      u = t.state.doc.resolve(d);
    else if (Zp(t, c.target) != r && (u = Jl(t, e), !u))
      return s();
    u && o(u, c);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
}
function m2(t, e, n) {
  if (!(t.state.selection instanceof ie)) return null;
  const { $head: r } = t.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const o = r.node(i);
    if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount)) return null;
    if (o.type.spec.tableRole == "cell" || o.type.spec.tableRole == "header_cell") {
      const a = r.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function Zp(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Jl(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? Zi(t.state.doc.resolve(n.pos)) : null;
}
var wx = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), K1(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, K1(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function K1(t, e, n, r, i, o) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const d = t.firstChild;
  if (d) {
    for (let u = 0, f = 0; u < d.childCount; u++) {
      const { colspan: p, colwidth: h } = d.child(u).attrs;
      for (let m = 0; m < p; m++, f++) {
        const g = i == f ? o : h && h[m], C = g ? g + "px" : "";
        if (a += g || r, g || (l = !1), c)
          c.style.width != C && (c.style.width = C), c = c.nextSibling;
        else {
          const v = document.createElement("col");
          v.style.width = C, e.appendChild(v);
        }
      }
    }
    for (; c; ) {
      const u = c.nextSibling;
      (s = c.parentNode) == null || s.removeChild(c), c = u;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var ln = new ct(
  "tableColumnResizing"
);
function _x({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = wx,
  lastColumnResizable: i = !0
} = {}) {
  const o = new Qe({
    key: ln,
    state: {
      init(s, a) {
        var l, c;
        const d = (c = (l = o.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, u = Dt(a.schema).table.name;
        return r && d && (d[u] = (f, p) => new r(f, n, p)), new Ex(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = ln.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          xx(s, a, t, i);
        },
        mouseleave: (s) => {
          kx(s);
        },
        mousedown: (s, a) => {
          Sx(s, a, e, n);
        }
      },
      decorations: (s) => {
        const a = ln.getState(s);
        if (a && a.activeHandle > -1)
          return Nx(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return o;
}
var Ex = class Us {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(ln);
    if (r && r.setHandle != null)
      return new Us(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Us(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(n.activeHandle, -1);
      return W1(e.doc.resolve(i)) || (i = -1), new Us(i, n.dragging);
    }
    return n;
  }
};
function xx(t, e, n, r) {
  if (!t.editable) return;
  const i = ln.getState(t.state);
  if (i && !i.dragging) {
    const o = Ox(e.target);
    let s = -1;
    if (o) {
      const { left: a, right: l } = o.getBoundingClientRect();
      e.clientX - a <= n ? s = Kp(t, e, "left", n) : l - e.clientX <= n && (s = Kp(t, e, "right", n));
    }
    if (s != i.activeHandle) {
      if (!r && s !== -1) {
        const a = t.state.doc.resolve(s), l = a.node(-1), c = tt.get(l), d = a.start(-1);
        if (c.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      C2(t, s);
    }
  }
}
function kx(t) {
  if (!t.editable) return;
  const e = ln.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && C2(t, -1);
}
function Sx(t, e, n, r) {
  var i;
  if (!t.editable) return !1;
  const o = (i = t.dom.ownerDocument.defaultView) != null ? i : window, s = ln.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const a = t.state.doc.nodeAt(s.activeHandle), l = Mx(t, s.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(ln, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(u) {
    o.removeEventListener("mouseup", c), o.removeEventListener("mousemove", d);
    const f = ln.getState(t.state);
    f != null && f.dragging && (Tx(
      t,
      f.activeHandle,
      Gp(f.dragging, u, n)
    ), t.dispatch(
      t.state.tr.setMeta(ln, { setDragging: null })
    ));
  }
  function d(u) {
    if (!u.which) return c(u);
    const f = ln.getState(t.state);
    if (f && f.dragging) {
      const p = Gp(f.dragging, u, n);
      qp(
        t,
        f.activeHandle,
        p,
        r
      );
    }
  }
  return qp(
    t,
    s.activeHandle,
    l,
    r
  ), o.addEventListener("mouseup", c), o.addEventListener("mousemove", d), e.preventDefault(), !0;
}
function Mx(t, e, { colspan: n, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const o = t.domAtPos(e);
  let a = o.node.childNodes[o.offset].offsetWidth, l = n;
  if (r)
    for (let c = 0; c < n; c++)
      r[c] && (a -= r[c], l--);
  return a / l;
}
function Ox(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function Kp(t, e, n, r) {
  const i = n == "right" ? -r : r, o = t.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!o) return -1;
  const { pos: s } = o, a = Zi(t.state.doc.resolve(s));
  if (!a) return -1;
  if (n == "right") return a.pos;
  const l = tt.get(a.node(-1)), c = a.start(-1), d = l.map.indexOf(a.pos - c);
  return d % l.width == 0 ? -1 : c + l.map[d - 1];
}
function Gp(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function C2(t, e) {
  t.dispatch(
    t.state.tr.setMeta(ln, { setHandle: e })
  );
}
function Tx(t, e, n) {
  const r = t.state.doc.resolve(e), i = r.node(-1), o = tt.get(i), s = r.start(-1), a = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < o.height; c++) {
    const d = c * o.width + a;
    if (c && o.map[d] == o.map[d - o.width]) continue;
    const u = o.map[d], f = i.nodeAt(u).attrs, p = f.colspan == 1 ? 0 : a - o.colCount(u);
    if (f.colwidth && f.colwidth[p] == n) continue;
    const h = f.colwidth ? f.colwidth.slice() : Lx(f.colspan);
    h[p] = n, l.setNodeMarkup(s + u, null, { ...f, colwidth: h });
  }
  l.docChanged && t.dispatch(l);
}
function qp(t, e, n, r) {
  const i = t.state.doc.resolve(e), o = i.node(-1), s = i.start(-1), a = tt.get(o).colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && K1(
    o,
    l.firstChild,
    l,
    r,
    a,
    n
  );
}
function Lx(t) {
  return Array(t).fill(0);
}
function Nx(t, e) {
  var n;
  const r = [], i = t.doc.resolve(e), o = i.node(-1);
  if (!o)
    return Ke.empty;
  const s = tt.get(o), a = i.start(-1), l = s.colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < s.height; c++) {
    const d = l + c * s.width;
    if ((l == s.width - 1 || s.map[d] != s.map[d + 1]) && (c == 0 || s.map[d] != s.map[d - s.width])) {
      const u = s.map[d], f = a + u + o.nodeAt(u).nodeSize - 1, p = document.createElement("div");
      p.className = "column-resize-handle", (n = ln.getState(t)) != null && n.dragging && r.push(
        Tt.node(
          a + u,
          a + u + o.nodeAt(u).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(Tt.widget(f, p));
    }
  }
  return Ke.create(t.doc, r);
}
function Ax({
  allowTableNodeSelection: t = !1
} = {}) {
  return new Qe({
    key: vr,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(vr);
        if (r != null) return r == -1 ? null : r;
        if (n == null || !e.docChanged) return n;
        const { deleted: i, pos: o } = e.mapping.mapResult(n);
        return i ? null : o;
      }
    },
    props: {
      decorations: WE,
      handleDOMEvents: {
        mousedown: vx
      },
      createSelectionBetween(e) {
        return vr.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: bx,
      handleKeyDown: Cx,
      handlePaste: yx
    },
    appendTransaction(e, n, r) {
      return GE(
        r,
        p2(r, n),
        t
      );
    }
  });
}
function G1(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function Qp(t, e, n, r, i, o) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const d = t.firstChild;
  if (d !== null)
    for (let u = 0, f = 0; u < d.childCount; u += 1) {
      const { colspan: p, colwidth: h } = d.child(u).attrs;
      for (let m = 0; m < p; m += 1, f += 1) {
        const g = i === f ? o : h && h[m], C = g ? `${g}px` : "";
        if (a += g || r, g || (l = !1), c) {
          if (c.style.width !== C) {
            const [v, _] = G1(r, g);
            c.style.setProperty(v, _);
          }
          c = c.nextSibling;
        } else {
          const v = document.createElement("col"), [_, b] = G1(r, g);
          v.style.setProperty(_, b), e.appendChild(v);
        }
      }
    }
  for (; c; ) {
    const u = c.nextSibling;
    (s = c.parentNode) === null || s === void 0 || s.removeChild(c), c = u;
  }
  l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
}
class Rx {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Qp(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, Qp(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function Ix(t, e, n, r) {
  let i = 0, o = !0;
  const s = [], a = t.firstChild;
  if (!a)
    return {};
  for (let u = 0, f = 0; u < a.childCount; u += 1) {
    const { colspan: p, colwidth: h } = a.child(u).attrs;
    for (let m = 0; m < p; m += 1, f += 1) {
      const g = n === f ? r : h && h[m];
      i += g || e, g || (o = !1);
      const [C, v] = G1(e, g);
      s.push([
        "col",
        { style: `${C}: ${v}` }
      ]);
    }
  }
  const l = o ? `${i}px` : "", c = o ? "" : `${i}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c };
}
function Yp(t, e) {
  return t.createAndFill();
}
function Dx(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const r = t.nodes[n];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), t.cached.tableNodeTypes = e, e;
}
function Px(t, e, n, r, i) {
  const o = Dx(t), s = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const d = Yp(o.cell);
    if (d && a.push(d), r) {
      const u = Yp(o.header_cell);
      u && s.push(u);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(o.row.createChecked(null, r && c === 0 ? s : a));
  return o.table.createChecked(null, l);
}
function Bx(t) {
  return t instanceof je;
}
const xs = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!Bx(e))
    return !1;
  let n = 0;
  const r = u6(e.ranges[0].$from, (o) => o.type.name === "table");
  return r == null || r.node.descendants((o) => {
    if (o.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(o.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, $x = nt.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: Rx,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: r, tableMinWidth: i } = Ix(t, this.options.cellMinWidth);
    return [
      "table",
      Be(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${i}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: o }) => {
        const s = Px(o.schema, t, e, n);
        if (i) {
          const a = r.selection.from + 1;
          r.replaceSelectionWith(s).scrollIntoView().setSelection(ie.near(r.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => YE(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => JE(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => ex(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => nx(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => rx(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => ox(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => fx(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => zp(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => Hp(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => $o("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => $o("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => dx(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => zp(t, e) ? !0 : Hp(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => lx(t, e)(n, r),
      goToNextCell: () => ({ state: t, dispatch: e }) => Up(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => Up(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && p2(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const r = je.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: xs,
      "Mod-Backspace": xs,
      Delete: xs,
      "Mod-Delete": xs
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        _x({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      Ax({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: xe(q(t, "tableRole", e))
    };
  }
}), zx = nt.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", Be(this.options.HTMLAttributes, t), 0];
  }
}), Hx = nt.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", Be(this.options.HTMLAttributes, t), 0];
  }
}), Fx = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Ux = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Fi = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, q1 = "numeric", Q1 = "ascii", Y1 = "alpha", bo = "asciinumeric", lo = "alphanumeric", J1 = "domain", b2 = "emoji", Vx = "scheme", jx = "slashscheme", Xl = "whitespace";
function Wx(t, e) {
  return t in e || (e[t] = []), e[t];
}
function qr(t, e, n) {
  e[q1] && (e[bo] = !0, e[lo] = !0), e[Q1] && (e[bo] = !0, e[Y1] = !0), e[bo] && (e[lo] = !0), e[Y1] && (e[lo] = !0), e[lo] && (e[J1] = !0), e[b2] && (e[J1] = !0);
  for (const r in e) {
    const i = Wx(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function Zx(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Kt(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Kt.groups = {};
Kt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], o = e.jr[r][1];
      if (o && i.test(t))
        return o;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || Kt.groups;
    let i;
    return e && e.j ? i = e : (i = new Kt(e), n && r && qr(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const o = t.length;
    if (!o)
      return i;
    for (let s = 0; s < o - 1; s++)
      i = i.tt(t[s]);
    return i.tt(t[o - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || Kt.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const o = e;
    let s, a = i.go(t);
    if (a ? (s = new Kt(), Fi(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new Kt(), o) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = Fi(Zx(s.t, r), n);
          qr(o, l, r);
        } else n && qr(o, n, r);
      s.t = o;
    }
    return i.j[t] = s, s;
  }
};
const Ee = (t, e, n, r, i) => t.ta(e, n, r, i), Je = (t, e, n, r, i) => t.tr(e, n, r, i), Jp = (t, e, n, r, i) => t.ts(e, n, r, i), P = (t, e, n, r, i) => t.tt(e, n, r, i), Jn = "WORD", X1 = "UWORD", y2 = "ASCIINUMERICAL", v2 = "ALPHANUMERICAL", zo = "LOCALHOST", ec = "TLD", tc = "UTLD", Vs = "SCHEME", _i = "SLASH_SCHEME", xd = "NUM", nc = "WS", kd = "NL", yo = "OPENBRACE", vo = "CLOSEBRACE", la = "OPENBRACKET", ca = "CLOSEBRACKET", da = "OPENPAREN", ua = "CLOSEPAREN", fa = "OPENANGLEBRACKET", pa = "CLOSEANGLEBRACKET", ha = "FULLWIDTHLEFTPAREN", ga = "FULLWIDTHRIGHTPAREN", ma = "LEFTCORNERBRACKET", Ca = "RIGHTCORNERBRACKET", ba = "LEFTWHITECORNERBRACKET", ya = "RIGHTWHITECORNERBRACKET", va = "FULLWIDTHLESSTHAN", wa = "FULLWIDTHGREATERTHAN", _a = "AMPERSAND", Ea = "APOSTROPHE", xa = "ASTERISK", br = "AT", ka = "BACKSLASH", Sa = "BACKTICK", Ma = "CARET", wr = "COLON", Sd = "COMMA", Oa = "DOLLAR", Bn = "DOT", Ta = "EQUALS", Md = "EXCLAMATION", hn = "HYPHEN", wo = "PERCENT", La = "PIPE", Na = "PLUS", Aa = "POUND", _o = "QUERY", Od = "QUOTE", w2 = "FULLWIDTHMIDDLEDOT", Td = "SEMI", $n = "SLASH", Eo = "TILDE", Ra = "UNDERSCORE", _2 = "EMOJI", Ia = "SYM";
var E2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: v2,
  AMPERSAND: _a,
  APOSTROPHE: Ea,
  ASCIINUMERICAL: y2,
  ASTERISK: xa,
  AT: br,
  BACKSLASH: ka,
  BACKTICK: Sa,
  CARET: Ma,
  CLOSEANGLEBRACKET: pa,
  CLOSEBRACE: vo,
  CLOSEBRACKET: ca,
  CLOSEPAREN: ua,
  COLON: wr,
  COMMA: Sd,
  DOLLAR: Oa,
  DOT: Bn,
  EMOJI: _2,
  EQUALS: Ta,
  EXCLAMATION: Md,
  FULLWIDTHGREATERTHAN: wa,
  FULLWIDTHLEFTPAREN: ha,
  FULLWIDTHLESSTHAN: va,
  FULLWIDTHMIDDLEDOT: w2,
  FULLWIDTHRIGHTPAREN: ga,
  HYPHEN: hn,
  LEFTCORNERBRACKET: ma,
  LEFTWHITECORNERBRACKET: ba,
  LOCALHOST: zo,
  NL: kd,
  NUM: xd,
  OPENANGLEBRACKET: fa,
  OPENBRACE: yo,
  OPENBRACKET: la,
  OPENPAREN: da,
  PERCENT: wo,
  PIPE: La,
  PLUS: Na,
  POUND: Aa,
  QUERY: _o,
  QUOTE: Od,
  RIGHTCORNERBRACKET: Ca,
  RIGHTWHITECORNERBRACKET: ya,
  SCHEME: Vs,
  SEMI: Td,
  SLASH: $n,
  SLASH_SCHEME: _i,
  SYM: Ia,
  TILDE: Eo,
  TLD: ec,
  UNDERSCORE: Ra,
  UTLD: tc,
  UWORD: X1,
  WORD: Jn,
  WS: nc
});
const qn = /[a-z]/, eo = new RegExp("\\p{L}", "u"), e1 = new RegExp("\\p{Emoji}", "u"), Qn = /\d/, t1 = /\s/, Xp = "\r", n1 = `
`, Kx = "️", Gx = "‍", r1 = "￼";
let ks = null, Ss = null;
function qx(t = []) {
  const e = {};
  Kt.groups = e;
  const n = new Kt();
  ks == null && (ks = eh(Fx)), Ss == null && (Ss = eh(Ux)), P(n, "'", Ea), P(n, "{", yo), P(n, "}", vo), P(n, "[", la), P(n, "]", ca), P(n, "(", da), P(n, ")", ua), P(n, "<", fa), P(n, ">", pa), P(n, "（", ha), P(n, "）", ga), P(n, "「", ma), P(n, "」", Ca), P(n, "『", ba), P(n, "』", ya), P(n, "＜", va), P(n, "＞", wa), P(n, "&", _a), P(n, "*", xa), P(n, "@", br), P(n, "`", Sa), P(n, "^", Ma), P(n, ":", wr), P(n, ",", Sd), P(n, "$", Oa), P(n, ".", Bn), P(n, "=", Ta), P(n, "!", Md), P(n, "-", hn), P(n, "%", wo), P(n, "|", La), P(n, "+", Na), P(n, "#", Aa), P(n, "?", _o), P(n, '"', Od), P(n, "/", $n), P(n, ";", Td), P(n, "~", Eo), P(n, "_", Ra), P(n, "\\", ka), P(n, "・", w2);
  const r = Je(n, Qn, xd, {
    [q1]: !0
  });
  Je(r, Qn, r);
  const i = Je(r, qn, y2, {
    [bo]: !0
  }), o = Je(r, eo, v2, {
    [lo]: !0
  }), s = Je(n, qn, Jn, {
    [Q1]: !0
  });
  Je(s, Qn, i), Je(s, qn, s), Je(i, Qn, i), Je(i, qn, i);
  const a = Je(n, eo, X1, {
    [Y1]: !0
  });
  Je(a, qn), Je(a, Qn, o), Je(a, eo, a), Je(o, Qn, o), Je(o, qn), Je(o, eo, o);
  const l = P(n, n1, kd, {
    [Xl]: !0
  }), c = P(n, Xp, nc, {
    [Xl]: !0
  }), d = Je(n, t1, nc, {
    [Xl]: !0
  });
  P(n, r1, d), P(c, n1, l), P(c, r1, d), Je(c, t1, d), P(d, Xp), P(d, n1), Je(d, t1, d), P(d, r1, d);
  const u = Je(n, e1, _2, {
    [b2]: !0
  });
  P(u, "#"), Je(u, e1, u), P(u, Kx, u);
  const f = P(u, Gx);
  P(f, "#"), Je(f, e1, u);
  const p = [[qn, s], [Qn, i]], h = [[qn, null], [eo, a], [Qn, o]];
  for (let m = 0; m < ks.length; m++)
    fr(n, ks[m], ec, Jn, p);
  for (let m = 0; m < Ss.length; m++)
    fr(n, Ss[m], tc, X1, h);
  qr(ec, {
    tld: !0,
    ascii: !0
  }, e), qr(tc, {
    utld: !0,
    alpha: !0
  }, e), fr(n, "file", Vs, Jn, p), fr(n, "mailto", Vs, Jn, p), fr(n, "http", _i, Jn, p), fr(n, "https", _i, Jn, p), fr(n, "ftp", _i, Jn, p), fr(n, "ftps", _i, Jn, p), qr(Vs, {
    scheme: !0,
    ascii: !0
  }, e), qr(_i, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((m, g) => m[0] > g[0] ? 1 : -1);
  for (let m = 0; m < t.length; m++) {
    const g = t[m][0], v = t[m][1] ? {
      [Vx]: !0
    } : {
      [jx]: !0
    };
    g.indexOf("-") >= 0 ? v[J1] = !0 : qn.test(g) ? Qn.test(g) ? v[bo] = !0 : v[Q1] = !0 : v[q1] = !0, Jp(n, g, g, v);
  }
  return Jp(n, "localhost", zo, {
    ascii: !0
  }), n.jd = new Kt(Ia), {
    start: n,
    tokens: Fi({
      groups: e
    }, E2)
  };
}
function x2(t, e) {
  const n = Qx(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let o = 0, s = 0;
  for (; s < r; ) {
    let a = t, l = null, c = 0, d = null, u = -1, f = -1;
    for (; s < r && (l = a.go(n[s])); )
      a = l, a.accepts() ? (u = 0, f = 0, d = a) : u >= 0 && (u += n[s].length, f++), c += n[s].length, o += n[s].length, s++;
    o -= u, s -= f, c -= u, i.push({
      t: d.t,
      // token type/name
      v: e.slice(o - c, o),
      // string value
      s: o - c,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function Qx(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), o, s = i < 55296 || i > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(s), r += s.length;
  }
  return e;
}
function fr(t, e, n, r, i) {
  let o;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? o = t.j[l] : (o = new Kt(r), o.jr = i.slice(), t.j[l] = o), t = o;
  }
  return o = new Kt(n), o.jr = i.slice(), t.j[e[s - 1]] = o, o;
}
function eh(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let o = 0;
    for (; i.indexOf(t[r + o]) >= 0; )
      o++;
    if (o > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(r, r + o), 10); s > 0; s--)
        n.pop();
      r += o;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const Ho = {
  defaultProtocol: "http",
  events: null,
  format: th,
  formatHref: th,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Ld(t, e = null) {
  let n = Fi({}, Ho);
  t && (n = Fi(n, t instanceof Ld ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
Ld.prototype = {
  o: Ho,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Ho[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function th(t) {
  return t;
}
function k2(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
k2.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = Ho.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), i = t.get("tagName", n, e), o = this.toFormattedString(t), s = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), d = t.getObj("attributes", n, e), u = t.getObj("events", n, e);
    return s.href = r, a && (s.class = a), l && (s.target = l), c && (s.rel = c), d && Fi(s, d), {
      tagName: i,
      attributes: s,
      content: o,
      eventListeners: u
    };
  }
};
function al(t, e) {
  class n extends k2 {
    constructor(i, o) {
      super(i, o), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const nh = al("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), rh = al("text"), Yx = al("nl"), Ms = al("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = Ho.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== zo && t[1].t === wr;
  }
}), fn = (t) => new Kt(t);
function Jx({
  groups: t
}) {
  const e = t.domain.concat([_a, xa, br, ka, Sa, Ma, Oa, Ta, hn, xd, wo, La, Na, Aa, $n, Ia, Eo, Ra]), n = [Ea, wr, Sd, Bn, Md, wo, _o, Od, Td, fa, pa, yo, vo, ca, la, da, ua, ha, ga, ma, Ca, ba, ya, va, wa], r = [_a, Ea, xa, ka, Sa, Ma, Oa, Ta, hn, yo, vo, wo, La, Na, Aa, _o, $n, Ia, Eo, Ra], i = fn(), o = P(i, Eo);
  Ee(o, r, o), Ee(o, t.domain, o);
  const s = fn(), a = fn(), l = fn();
  Ee(i, t.domain, s), Ee(i, t.scheme, a), Ee(i, t.slashscheme, l), Ee(s, r, o), Ee(s, t.domain, s);
  const c = P(s, br);
  P(o, br, c), P(a, br, c), P(l, br, c);
  const d = P(o, Bn);
  Ee(d, r, o), Ee(d, t.domain, o);
  const u = fn();
  Ee(c, t.domain, u), Ee(u, t.domain, u);
  const f = P(u, Bn);
  Ee(f, t.domain, u);
  const p = fn(nh);
  Ee(f, t.tld, p), Ee(f, t.utld, p), P(c, zo, p);
  const h = P(u, hn);
  P(h, hn, h), Ee(h, t.domain, u), Ee(p, t.domain, u), P(p, Bn, f), P(p, hn, h);
  const m = P(p, wr);
  Ee(m, t.numeric, nh);
  const g = P(s, hn), C = P(s, Bn);
  P(g, hn, g), Ee(g, t.domain, s), Ee(C, r, o), Ee(C, t.domain, s);
  const v = fn(Ms);
  Ee(C, t.tld, v), Ee(C, t.utld, v), Ee(v, t.domain, s), Ee(v, r, o), P(v, Bn, C), P(v, hn, g), P(v, br, c);
  const _ = P(v, wr), b = fn(Ms);
  Ee(_, t.numeric, b);
  const x = fn(Ms), y = fn();
  Ee(x, e, x), Ee(x, n, y), Ee(y, e, x), Ee(y, n, y), P(v, $n, x), P(b, $n, x);
  const M = P(a, wr), S = P(l, wr), T = P(S, $n), D = P(T, $n);
  Ee(a, t.domain, s), P(a, Bn, C), P(a, hn, g), Ee(l, t.domain, s), P(l, Bn, C), P(l, hn, g), Ee(M, t.domain, x), P(M, $n, x), P(M, _o, x), Ee(D, t.domain, x), Ee(D, e, x), P(D, $n, x);
  const j = [
    [yo, vo],
    // {}
    [la, ca],
    // []
    [da, ua],
    // ()
    [fa, pa],
    // <>
    [ha, ga],
    // （）
    [ma, Ca],
    // 「」
    [ba, ya],
    // 『』
    [va, wa]
    // ＜＞
  ];
  for (let V = 0; V < j.length; V++) {
    const [X, de] = j[V], ee = P(x, X);
    P(y, X, ee), P(ee, de, x);
    const J = fn(Ms);
    Ee(ee, e, J);
    const L = fn();
    Ee(ee, n), Ee(J, e, J), Ee(J, n, L), Ee(L, e, J), Ee(L, n, L), P(J, de, x), P(L, de, x);
  }
  return P(i, zo, v), P(i, kd, Yx), {
    start: i,
    tokens: E2
  };
}
function Xx(t, e, n) {
  let r = n.length, i = 0, o = [], s = [];
  for (; i < r; ) {
    let a = t, l = null, c = null, d = 0, u = null, f = -1;
    for (; i < r && !(l = a.go(n[i].t)); )
      s.push(n[i++]);
    for (; i < r && (c = l || a.go(n[i].t)); )
      l = null, a = c, a.accepts() ? (f = 0, u = a) : f >= 0 && f++, i++, d++;
    if (f < 0)
      i -= d, i < r && (s.push(n[i]), i++);
    else {
      s.length > 0 && (o.push(i1(rh, e, s)), s = []), i -= f, d -= f;
      const p = u.t, h = n.slice(i - d, i);
      o.push(i1(p, e, h));
    }
  }
  return s.length > 0 && o.push(i1(rh, e, s)), o;
}
function i1(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = e.slice(r, i);
  return new t(o, n);
}
const ek = typeof console < "u" && console && console.warn || (() => {
}), tk = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Ze = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function nk() {
  return Kt.groups = {}, Ze.scanner = null, Ze.parser = null, Ze.tokenQueue = [], Ze.pluginQueue = [], Ze.customSchemes = [], Ze.initialized = !1, Ze;
}
function ih(t, e = !1) {
  if (Ze.initialized && ek(`linkifyjs: already initialized - will not register custom scheme "${t}" ${tk}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Ze.customSchemes.push([t, e]);
}
function rk() {
  Ze.scanner = qx(Ze.customSchemes);
  for (let t = 0; t < Ze.tokenQueue.length; t++)
    Ze.tokenQueue[t][1]({
      scanner: Ze.scanner
    });
  Ze.parser = Jx(Ze.scanner.tokens);
  for (let t = 0; t < Ze.pluginQueue.length; t++)
    Ze.pluginQueue[t][1]({
      scanner: Ze.scanner,
      parser: Ze.parser
    });
  return Ze.initialized = !0, Ze;
}
function Nd(t) {
  return Ze.initialized || rk(), Xx(Ze.parser.start, t, x2(Ze.scanner.start, t));
}
Nd.scan = x2;
function S2(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new Ld(n), i = Nd(t), o = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    a.isLink && (!e || a.t === e) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
function ik(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function ok(t) {
  return new Qe({
    key: new ct("autolink"),
    appendTransaction: (e, n, r) => {
      const i = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), o = e.some((c) => c.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: s } = r, a = F5(n.doc, [...e]);
      if (K5(a).forEach(({ newRange: c }) => {
        const d = V5(r.doc, c, (p) => p.isTextblock);
        let u, f;
        if (d.length > 1 ? (u = d[0], f = r.doc.textBetween(u.pos, u.pos + u.node.nodeSize, void 0, " ")) : d.length && r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (u = d[0], f = r.doc.textBetween(u.pos, c.to, void 0, " ")), u && f) {
          const p = f.split(" ").filter((C) => C !== "");
          if (p.length <= 0)
            return !1;
          const h = p[p.length - 1], m = u.pos + f.lastIndexOf(h);
          if (!h)
            return !1;
          const g = Nd(h).map((C) => C.toObject(t.defaultProtocol));
          if (!ik(g))
            return !1;
          g.filter((C) => C.isLink).map((C) => ({
            ...C,
            from: m + C.start + 1,
            to: m + C.end + 1
          })).filter((C) => r.schema.marks.code ? !r.doc.rangeHasMark(C.from, C.to, r.schema.marks.code) : !0).filter((C) => t.validate(C.value)).filter((C) => t.shouldAutoLink(C.value)).forEach((C) => {
            Nc(C.from, C.to, r.doc).some((v) => v.mark.type === t.type) || s.addMark(C.from, C.to, t.type.create({
              href: C.href
            }));
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function sk(t) {
  return new Qe({
    key: new ct("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var i, o;
        if (r.button !== 0 || !e.editable)
          return !1;
        let s = r.target;
        const a = [];
        for (; s.nodeName !== "DIV"; )
          a.push(s), s = s.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return !1;
        const l = p6(e.state, t.type.name), c = r.target, d = (i = c == null ? void 0 : c.href) !== null && i !== void 0 ? i : l.href, u = (o = c == null ? void 0 : c.target) !== null && o !== void 0 ? o : l.target;
        return c && d ? (window.open(d, u), !0) : !1;
      }
    }
  });
}
function ak(t) {
  return new Qe({
    key: new ct("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e, { selection: o } = i, { empty: s } = o;
        if (s)
          return !1;
        let a = "";
        r.content.forEach((c) => {
          a += c.textContent;
        });
        const l = S2(a, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? !1 : t.editor.commands.setMark(t.type, {
          href: l.href
        });
      }
    }
  });
}
const lk = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function Ur(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !t || t.replace(lk, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const ck = vn.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ih(t);
        return;
      }
      ih(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    nk();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!Ur(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!Ur(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!Ur(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Be(this.options.HTMLAttributes, t), 0] : [
      "a",
      Be(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Ur(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Ur(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Dr({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: r } = this.options, i = S2(t).filter((o) => o.isLink && this.options.isAllowedUri(o.value, {
              defaultValidate: (s) => !!Ur(s, n),
              protocols: n,
              defaultProtocol: r
            }));
            i.length && i.forEach((o) => e.push({
              text: o.value,
              data: {
                href: o.href
              },
              index: o.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(ok({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (r) => this.options.isAllowedUri(r, {
        defaultValidate: (i) => !!Ur(i, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(sk({
      type: this.type
    })), this.options.linkOnPaste && t.push(ak({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), dk = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, uk = nt.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", Be(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      m6({
        find: dk,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t;
          return { src: n, alt: e, title: r };
        }
      })
    ];
  }
}), o1 = {};
function fk(t) {
  return new Promise((e, n) => {
    const r = {
      complete: !1,
      width: 0,
      height: 0,
      src: t
    };
    if (!t) {
      n(r);
      return;
    }
    if (o1[t]) {
      e({ ...o1[t] });
      return;
    }
    const i = new Image();
    i.onload = () => {
      r.width = i.width, r.height = i.height, r.complete = !0, o1[t] = { ...r }, e(r);
    }, i.onerror = () => {
      n(r);
    }, i.src = t;
  });
}
const Ei = {
  INLINE: "inline",
  BREAK_TEXT: "block",
  FLOAT_LEFT: "left",
  FLOAT_RIGHT: "right"
}, pk = { class: "image-view__body" }, hk = { class: "popover__tools" }, gk = ["onClick"], mk = ["src", "title", "alt", "width", "height"], Ck = { class: "image-resizer" }, bk = ["onMousedown"], pr = 20, oh = 1500, yk = /* @__PURE__ */ ve({
  __name: "image-view",
  props: qo,
  setup(t) {
    const e = t, n = Ct(["inline", "block", "left", "right"]), r = Ct({
      width: oh,
      height: oh
    }), i = U(!1), o = U(!1), s = Ct({
      w: 0,
      h: 0,
      dir: "",
      x: 0,
      y: 0
    }), a = Ct(["tl", "tr", "bl", "br"]), l = Ct({
      width: 0,
      height: 0
    }), c = Ge(() => e.node.attrs.src), d = Ge(() => e.node.attrs.width), u = Ge(() => e.node.attrs.height), f = Ge(() => e.node.attrs.display), p = Ge(() => ["image-view", `image-view--${f.value}`]), h = async () => {
      const y = await fk(c.value);
      y.complete || (y.width = pr, y.height = pr), l.width = y.width, l.height = y.height;
    }, m = () => {
      const { editor: y } = e;
      if (y) {
        const { from: M, to: S } = y.state.selection, T = e.getPos();
        o.value = M === S && M === T;
      }
    };
    di(() => {
      var y;
      h(), m(), (y = e.editor) == null || y.on("selectionUpdate", m);
    }), Th(() => {
      var y;
      (y = e.editor) == null || y.off("selectionUpdate", m), x();
    });
    const g = () => {
      var y;
      (y = e.editor) == null || y.commands.setNodeSelection(e.getPos()), o.value = !0;
    }, C = (y, M) => {
      var de;
      y.stopPropagation(), y.preventDefault();
      const S = l.width, T = l.height, D = S / T, j = r.width;
      let { width: V, height: X } = e.node.attrs;
      (!V || !X) && (V && !X ? (V = V > j ? j : V, X = Math.round(V / D)) : X && !V ? (V = Math.round(X * D), V = V > j ? j : V) : (V = S > j ? j : S, X = Math.round(V / D)), (de = e.updateAttributes) == null || de.call(e, {
        width: V,
        height: X
      })), s.x = y.clientX, s.y = y.clientY, s.w = V, s.h = X, s.dir = M, i.value = !0, b();
    }, v = (y) => {
      var L;
      if (y.preventDefault(), y.stopPropagation(), !i.value) return;
      const { x: M, y: S, w: T, h: D, dir: j } = s, V = l.width / l.height, X = (y.clientX - M) * (/l/.test(j) ? -1 : 1), de = (y.clientY - S) * (/t/.test(j) ? -1 : 1);
      let ee, J;
      /r/.test(j) ? (ee = Cr(T + X, pr, r.width), J = Math.round(ee / V), J = Cr(J, pr, r.height), J >= r.height && (J = r.height, ee = Math.round(J * V))) : /l/.test(j) ? (ee = Cr(T - X, pr, r.width), J = Math.round(ee / V), J = Cr(J, pr, r.height), J >= r.height && (J = r.height, ee = Math.round(J * V))) : (J = Cr(D + de, pr, r.height), ee = Math.round(J * V), ee = Cr(ee, pr, r.width), ee >= r.width && (ee = r.width, J = Math.round(ee / V))), (L = e.updateAttributes) == null || L.call(e, {
        width: ee,
        height: J
      });
    }, _ = (y) => {
      y.preventDefault(), y.stopPropagation(), x(), i.value && (i.value = !1, s.x = s.y = s.w = s.h = 0, s.dir = "", g());
    }, b = () => {
      document.addEventListener("mousemove", v, !0), document.addEventListener("mouseup", _, !0);
    }, x = () => {
      document.removeEventListener("mousemove", v, !0), document.removeEventListener("mouseup", _, !0);
    };
    return (y, M) => {
      const S = ce("a-popover");
      return B(), ye(se(Go), {
        as: "span",
        class: lt(p.value)
      }, {
        default: R(() => [
          E("div", pk, [
            k(S, {
              placement: "top",
              trigger: "click"
            }, {
              content: R(() => [
                E("div", hk, [
                  (B(!0), he(Ye, null, bt(n, (T) => (B(), he("div", {
                    class: "popover__item",
                    key: T,
                    onClick: (D) => y.updateAttributes({ display: T })
                  }, ft(T), 9, gk))), 128)),
                  E("div", {
                    class: "popover__item",
                    onClick: M[0] || (M[0] = (T) => y.deleteNode())
                  }, [
                    k(se(Jo))
                  ])
                ])
              ]),
              default: R(() => [
                E("img", {
                  src: c.value,
                  title: y.node.attrs.title,
                  alt: y.node.attrs.alt,
                  width: d.value,
                  height: u.value,
                  onClick: g
                }, null, 8, mk)
              ]),
              _: 1
            }),
            za(E("div", Ck, [
              (B(!0), he(Ye, null, bt(a, (T) => (B(), he("span", {
                key: T,
                class: lt([`image-resizer__handler--${T}`, "image-resizer__handler"]),
                onMousedown: (D) => C(D, T)
              }, null, 42, bk))), 128))
            ], 512), [
              [ic, i.value || o.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
}), vk = /* @__PURE__ */ dt(yk, [["__scopeId", "data-v-99950f2c"]]), wk = 200, _k = Ei.INLINE, Ek = 300, xk = uk.extend({
  inline() {
    return !0;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      width: {
        default: wk,
        parseHTML: (e) => {
          const n = e.style.width || e.getAttribute("width") || null;
          return n == null ? null : parseInt(n, 10);
        },
        renderHTML: (e) => ({
          width: e.width
        })
      },
      height: {
        default: null,
        parseHTML: (e) => {
          const n = e.style.height || e.getAttribute("height") || null;
          return n == null ? null : parseInt(n, 10);
        },
        renderHTML: (e) => ({
          height: e.height
        })
      },
      display: {
        default: _k,
        parseHTML: (e) => {
          const { cssFloat: n, display: r } = e.style;
          let i = e.getAttribute("data-display") || e.getAttribute("display");
          return i ? i = /(inline|block|left|right)/.test(i) ? i : Ei.INLINE : n === "left" && !r ? i = Ei.FLOAT_LEFT : n === "right" && !r ? i = Ei.FLOAT_RIGHT : !n && r === "block" ? i = Ei.BREAK_TEXT : i = Ei.INLINE, i;
        },
        renderHTML: (e) => ({
          "data-display": e.display
        })
      }
    };
  },
  addNodeView() {
    return Qo(vk);
  },
  parseHTML() {
    return [
      {
        tag: "img[src]"
      }
    ];
  }
}), kk = { class: "popover__tools" }, Sk = ["onClick"], Mk = ["onMousedown"], Ok = ["src", "width"], sh = 200, Tk = 1500, Lk = /* @__PURE__ */ ve({
  __name: "video-view",
  props: qo,
  setup(t) {
    const e = t, n = U(!1), r = U(!1), i = Ct(["left", "center", "right"]), o = Ct({
      width: 0,
      height: 0
    }), s = Ct({
      w: 0,
      h: 0,
      x: 0,
      y: 0,
      dir: ""
    }), a = Ge(() => e.node.attrs.src), l = Ge(() => e.node.attrs.width), c = Ge(() => e.node.attrs.display), d = U();
    di(() => {
      o.width = d.value.getBoundingClientRect().width, o.height = d.value.getBoundingClientRect().height;
    });
    const u = (C, v) => {
      C.stopPropagation(), C.preventDefault();
      const _ = o.width / o.height;
      let { width: b, height: x } = e.node.attrs;
      b && !x ? x = Math.round(b / _) : !b && x ? b = Math.round(x * _) : !b && !x && (b = o.width), s.w = b, s.h = x, s.x = C.clientX, s.y = C.clientY, s.dir = v, r.value = !0, h();
    }, f = (C) => {
      var T;
      if (!r.value) return;
      const { x: v, y: _, w: b, h: x, dir: y } = s, M = (C.clientX - v) * (/l/.test(y) ? -1 : 1), S = (C.clientY - _) * (/t/.test(y) ? -1 : 1);
      (T = e.updateAttributes) == null || T.call(e, {
        width: Cr(b + M, sh, Tk),
        height: Math.max(x + S, sh)
      });
    }, p = (C) => {
      C.preventDefault(), C.stopPropagation(), m(), r.value && (r.value = !1, s.x = s.y = s.w = s.h = 0, s.dir = "");
    }, h = () => {
      document.addEventListener("mousemove", f, !0), document.addEventListener("mouseup", p, !0);
    }, m = () => {
      document.removeEventListener("mousemove", f, !0), document.removeEventListener("mouseup", p, !0);
    }, g = () => {
      var C;
      (C = e.deleteNode) == null || C.call(e);
    };
    return Th(() => {
      m();
    }), (C, v) => {
      const _ = ce("a-popover");
      return B(), ye(se(Go), {
        as: "div",
        class: lt(["video-view", `display-${c.value}`])
      }, {
        default: R(() => [
          k(_, null, {
            content: R(() => [
              E("div", kk, [
                (B(!0), he(Ye, null, bt(i, (b) => (B(), he("div", {
                  class: "popover__item",
                  key: b,
                  onClick: (x) => C.updateAttributes({ display: b })
                }, ft(b), 9, Sk))), 128)),
                E("div", {
                  class: "popover__item",
                  onClick: v[0] || (v[0] = (b) => g())
                }, [
                  k(se(Jo))
                ])
              ])
            ]),
            default: R(() => [
              E("div", {
                class: lt(["video-resizer", !n.value && !r.value ? "border_trans" : "border_blue"]),
                onMouseenter: v[1] || (v[1] = (b) => n.value = !0),
                onMouseleave: v[2] || (v[2] = (b) => n.value = !1)
              }, [
                k(R4, { name: "fade" }, {
                  default: R(() => [
                    za(E("div", null, [
                      (B(), he(Ye, null, bt(["tl", "tr", "bl", "br"], (b) => E("span", {
                        key: b,
                        class: lt([`video-resizer__handler--${b}`, "video-resizer__handler"]),
                        onMousedown: (x) => u(x, b)
                      }, null, 42, Mk)), 64))
                    ], 512), [
                      [ic, n.value || r.value]
                    ])
                  ]),
                  _: 1
                }),
                E("video", {
                  ref_key: "videoRef",
                  ref: d,
                  src: a.value,
                  controls: "",
                  width: l.value
                }, null, 8, Ok)
              ], 34)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
}), Nk = /* @__PURE__ */ dt(Lk, [["__scopeId", "data-v-82911887"]]), Ak = nt.create({
  name: "video",
  group() {
    return "block";
  },
  draggable: !0,
  // 添加内容配置
  content: "",
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null
      },
      width: {
        default: Ek
      },
      height: {
        default: null
      },
      display: {
        default: "left"
      }
    };
  },
  // 添加 parseHTML 方法
  parseHTML() {
    return [
      {
        tag: "video"
      }
    ];
  },
  // 添加 renderHTML 方法
  renderHTML({ HTMLAttributes: t }) {
    return [
      "video",
      Be(t, {
        controls: "true"
      })
    ];
  },
  addCommands() {
    return {
      setVideo: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addNodeView() {
    return Qo(Nk);
  }
}), Rk = nt.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", Be(this.options.HTMLAttributes, t), 0];
  }
}), Ik = Rk.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      backgroundColor: {
        default: null,
        parseHTML: (e) => e.getAttribute("data-background-color"),
        renderHTML: (e) => ({
          "data-background-color": e.backgroundColor,
          style: `background-color: ${e.backgroundColor}`
        })
      }
    };
  }
}), Dk = "listItem", Pk = "textStyle", Bk = Z6.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      defaultStyle: ""
    };
  },
  addAttributes() {
    return {
      orderedStyle: {
        default: this.options.defaultStyle,
        parseHTML: (t) => t.getAttribute("data-ordered-style"),
        renderHTML: (t) => ({
          "data-ordered-style": t.orderedStyle || this.options.defaultStyle
        })
      }
    };
  },
  addCommands() {
    return {
      setOrderedStyle: (t) => () => {
        this.options.defaultStyle = t;
      },
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Dk, this.editor.getAttributes(Pk)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  }
}), $k = "listItem", zk = "textStyle", Hk = H6.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      defaultStyle: ""
    };
  },
  addAttributes() {
    return {
      bulletStyle: {
        default: this.options.defaultStyle,
        parseHTML: (t) => t.getAttribute("data-bullet-style"),
        renderHTML: (t) => ({
          "data-bullet-style": t.bulletStyle || this.options.defaultStyle
        })
      }
    };
  },
  addCommands() {
    return {
      setBulletStyle: (t) => () => {
        this.options.defaultStyle = t;
      },
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes($k, this.editor.getAttributes(zk)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  }
}), Ti = {
  max: 7,
  min: 0,
  more: 1,
  less: -1
};
function ah({ delta: t, types: e }) {
  return ({ state: n, dispatch: r, editor: i }) => {
    const { selection: o } = n;
    let { tr: s } = n;
    return s = s.setSelection(o), s = Fk(s, t, e, i), s.docChanged ? (r && r(s), !0) : !1;
  };
}
function Fk(t, e, n, r) {
  const { doc: i, selection: o } = t;
  if (!i || !o || !(o instanceof ie || o instanceof Gt))
    return t;
  const { from: s, to: a } = o;
  return i.nodesBetween(s, a, (l, c) => {
    const d = l.type;
    return n.includes(d.name) ? (t = Uk(t, c, e), !1) : !N1(l.type.name, r.extensionManager.extensions);
  }), t;
}
function Uk(t, e, n) {
  if (!t.doc) return t;
  const r = t.doc.nodeAt(e);
  if (!r) return t;
  const i = Ti.min, o = Ti.max, s = Cr((r.attrs.indent || 0) + n, i, o);
  if (s === r.attrs.indent) return t;
  const a = {
    ...r.attrs,
    indent: s
  };
  return t.setNodeMarkup(e, r.type, a, r.marks);
}
const Vk = qe.create({
  name: "indent",
  addOptions() {
    return {
      types: ["paragraph", "heading", "blockquote"],
      minIndent: Ti.min,
      maxIndent: Ti.max
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          indent: {
            default: 0,
            parseHTML: (t) => {
              const e = t.getAttribute("data-indent");
              return (e ? parseInt(e, 10) : 0) || 0;
            },
            renderHTML: (t) => t.indent ? { "data-indent": t.indent } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => ah({
        delta: Ti.more,
        types: this.options.types
      }),
      outdent: () => ah({
        delta: Ti.less,
        types: this.options.types
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.indent(),
      "Shift-Tab": () => this.editor.commands.outdent()
    };
  }
});
function jk(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function M2(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && M2(n);
  }), t;
}
class lh {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function O2(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function Mr(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in t)
    n[r] = t[r];
  return e.forEach(function(r) {
    for (const i in r)
      n[i] = r[i];
  }), /** @type {T} */
  n;
}
const Wk = "</span>", ch = (t) => !!t.scope, Zk = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
class Kk {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += O2(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!ch(e)) return;
    const n = Zk(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    ch(e) && (this.buffer += Wk);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const dh = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
class Ad {
  constructor() {
    this.rootNode = dh(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = dh({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      Ad._collapse(n);
    }));
  }
}
class Gk extends Ad {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const r = e.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new Kk(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Fo(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function T2(t) {
  return fi("(?=", t, ")");
}
function qk(t) {
  return fi("(?:", t, ")*");
}
function Qk(t) {
  return fi("(?:", t, ")?");
}
function fi(...t) {
  return t.map((n) => Fo(n)).join("");
}
function Yk(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function Rd(...t) {
  return "(" + (Yk(t).capture ? "" : "?:") + t.map((r) => Fo(r)).join("|") + ")";
}
function L2(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function Jk(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const Xk = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Id(t, { joinWith: e }) {
  let n = 0;
  return t.map((r) => {
    n += 1;
    const i = n;
    let o = Fo(r), s = "";
    for (; o.length > 0; ) {
      const a = Xk.exec(o);
      if (!a) {
        s += o;
        break;
      }
      s += o.substring(0, a.index), o = o.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + i) : (s += a[0], a[0] === "(" && n++);
    }
    return s;
  }).map((r) => `(${r})`).join(e);
}
const eS = /\b\B/, N2 = "[a-zA-Z]\\w*", Dd = "[a-zA-Z_]\\w*", A2 = "\\b\\d+(\\.\\d+)?", R2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", I2 = "\\b(0b[01]+)", tS = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", nS = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = fi(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), Mr({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, r) => {
      n.index !== 0 && r.ignoreMatch();
    }
  }, t);
}, Uo = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, rS = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Uo]
}, iS = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Uo]
}, oS = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, ll = function(t, e, n = {}) {
  const r = Mr(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = Rd(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: fi(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, sS = ll("//", "$"), aS = ll("/\\*", "\\*/"), lS = ll("#", "$"), cS = {
  scope: "number",
  begin: A2,
  relevance: 0
}, dS = {
  scope: "number",
  begin: R2,
  relevance: 0
}, uS = {
  scope: "number",
  begin: I2,
  relevance: 0
}, fS = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    Uo,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [Uo]
    }
  ]
}, pS = {
  scope: "title",
  begin: N2,
  relevance: 0
}, hS = {
  scope: "title",
  begin: Dd,
  relevance: 0
}, gS = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Dd,
  relevance: 0
}, mS = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var Os = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: rS,
  BACKSLASH_ESCAPE: Uo,
  BINARY_NUMBER_MODE: uS,
  BINARY_NUMBER_RE: I2,
  COMMENT: ll,
  C_BLOCK_COMMENT_MODE: aS,
  C_LINE_COMMENT_MODE: sS,
  C_NUMBER_MODE: dS,
  C_NUMBER_RE: R2,
  END_SAME_AS_BEGIN: mS,
  HASH_COMMENT_MODE: lS,
  IDENT_RE: N2,
  MATCH_NOTHING_RE: eS,
  METHOD_GUARD: gS,
  NUMBER_MODE: cS,
  NUMBER_RE: A2,
  PHRASAL_WORDS_MODE: oS,
  QUOTE_STRING_MODE: iS,
  REGEXP_MODE: fS,
  RE_STARTERS_RE: tS,
  SHEBANG: nS,
  TITLE_MODE: pS,
  UNDERSCORE_IDENT_RE: Dd,
  UNDERSCORE_TITLE_MODE: hS
});
function CS(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function bS(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function yS(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = CS, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function vS(t, e) {
  Array.isArray(t.illegal) && (t.illegal = Rd(...t.illegal));
}
function wS(t, e) {
  if (t.match) {
    if (t.begin || t.end) throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function _S(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const ES = (t, e) => {
  if (!t.beforeMatch) return;
  if (t.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((r) => {
    delete t[r];
  }), t.keywords = n.keywords, t.begin = fi(n.beforeMatch, T2(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, xS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], kS = "keyword";
function D2(t, e, n = kS) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? i(n, t.split(" ")) : Array.isArray(t) ? i(n, t) : Object.keys(t).forEach(function(o) {
    Object.assign(
      r,
      D2(t[o], e, o)
    );
  }), r;
  function i(o, s) {
    e && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
      const l = a.split("|");
      r[l[0]] = [o, SS(l[0], l[1])];
    });
  }
}
function SS(t, e) {
  return e ? Number(e) : MS(t) ? 0 : 1;
}
function MS(t) {
  return xS.includes(t.toLowerCase());
}
const uh = {}, ni = (t) => {
  console.error(t);
}, fh = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, bi = (t, e) => {
  uh[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), uh[`${t}/${e}`] = !0);
}, Da = new Error();
function P2(t, e, { key: n }) {
  let r = 0;
  const i = t[n], o = {}, s = {};
  for (let a = 1; a <= e.length; a++)
    s[a + r] = i[a], o[a + r] = !0, r += L2(e[a - 1]);
  t[n] = s, t[n]._emit = o, t[n]._multi = !0;
}
function OS(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw ni("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Da;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw ni("beginScope must be object"), Da;
    P2(t, t.begin, { key: "beginScope" }), t.begin = Id(t.begin, { joinWith: "" });
  }
}
function TS(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw ni("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Da;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw ni("endScope must be object"), Da;
    P2(t, t.end, { key: "endScope" }), t.end = Id(t.end, { joinWith: "" });
  }
}
function LS(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function NS(t) {
  LS(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), OS(t), TS(t);
}
function AS(t) {
  function e(s, a) {
    return new RegExp(
      Fo(s),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += L2(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(Id(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((u, f) => f > 0 && u !== void 0), d = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, d);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, d]) => l.addRule(c, d)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const d = this.getMatcher(0);
        d.lastIndex = this.lastIndex + 1, c = d.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function i(s) {
    const a = new r();
    return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
  }
  function o(s, a) {
    const l = (
      /** @type CompiledMode */
      s
    );
    if (s.isCompiled) return l;
    [
      bS,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      wS,
      NS,
      ES
    ].forEach((d) => d(s, a)), t.compilerExtensions.forEach((d) => d(s, a)), s.__beforeBegin = null, [
      yS,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      vS,
      // default to 1 relevance if not specified
      _S
    ].forEach((d) => d(s, a)), s.isCompiled = !0;
    let c = null;
    return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), c = s.keywords.$pattern, delete s.keywords.$pattern), c = c || /\w+/, s.keywords && (s.keywords = D2(s.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = e(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = e(l.end)), l.terminatorEnd = Fo(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      s.illegal
    )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(d) {
      return RS(d === "self" ? s : d);
    })), s.contains.forEach(function(d) {
      o(
        /** @type Mode */
        d,
        l
      );
    }), s.starts && o(s.starts, a), l.matcher = i(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = Mr(t.classNameAliases || {}), o(
    /** @type Mode */
    t
  );
}
function B2(t) {
  return t ? t.endsWithParent || B2(t.starts) : !1;
}
function RS(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return Mr(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : B2(t) ? Mr(t, { starts: t.starts ? Mr(t.starts) : null }) : Object.isFrozen(t) ? Mr(t) : t;
}
var IS = "11.10.0";
class DS extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const s1 = O2, ph = Mr, hh = Symbol("nomatch"), PS = 7, $2 = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const o = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Gk
  };
  function l(L) {
    return a.noHighlightRe.test(L);
  }
  function c(L) {
    let I = L.className + " ";
    I += L.parentNode ? L.parentNode.className : "";
    const G = a.languageDetectRe.exec(I);
    if (G) {
      const oe = T(G[1]);
      return oe || (fh(o.replace("{}", G[1])), fh("Falling back to no-highlight mode for this block.", L)), oe ? G[1] : "no-highlight";
    }
    return I.split(/\s+/).find((oe) => l(oe) || T(oe));
  }
  function d(L, I, G) {
    let oe = "", me = "";
    typeof I == "object" ? (oe = L, G = I.ignoreIllegals, me = I.language) : (bi("10.7.0", "highlight(lang, code, ...args) has been deprecated."), bi("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), me = L, oe = I), G === void 0 && (G = !0);
    const _e = {
      code: oe,
      language: me
    };
    ee("before:highlight", _e);
    const ze = _e.result ? _e.result : u(_e.language, _e.code, G);
    return ze.code = _e.code, ee("after:highlight", ze), ze;
  }
  function u(L, I, G, oe) {
    const me = /* @__PURE__ */ Object.create(null);
    function _e(z, Z) {
      return z.keywords[Z];
    }
    function ze() {
      if (!ae.keywords) {
        De.addText(Te);
        return;
      }
      let z = 0;
      ae.keywordPatternRe.lastIndex = 0;
      let Z = ae.keywordPatternRe.exec(Te), Ce = "";
      for (; Z; ) {
        Ce += Te.substring(z, Z.index);
        const Le = ge.case_insensitive ? Z[0].toLowerCase() : Z[0], ot = _e(ae, Le);
        if (ot) {
          const [en, Ki] = ot;
          if (De.addText(Ce), Ce = "", me[Le] = (me[Le] || 0) + 1, me[Le] <= PS && ($t += Ki), en.startsWith("_"))
            Ce += Z[0];
          else {
            const O = ge.classNameAliases[en] || en;
            He(Z[0], O);
          }
        } else
          Ce += Z[0];
        z = ae.keywordPatternRe.lastIndex, Z = ae.keywordPatternRe.exec(Te);
      }
      Ce += Te.substring(z), De.addText(Ce);
    }
    function pt() {
      if (Te === "") return;
      let z = null;
      if (typeof ae.subLanguage == "string") {
        if (!e[ae.subLanguage]) {
          De.addText(Te);
          return;
        }
        z = u(ae.subLanguage, Te, !0, Bt[ae.subLanguage]), Bt[ae.subLanguage] = /** @type {CompiledMode} */
        z._top;
      } else
        z = p(Te, ae.subLanguage.length ? ae.subLanguage : null);
      ae.relevance > 0 && ($t += z.relevance), De.__addSublanguage(z._emitter, z.language);
    }
    function Re() {
      ae.subLanguage != null ? pt() : ze(), Te = "";
    }
    function He(z, Z) {
      z !== "" && (De.startScope(Z), De.addText(z), De.endScope());
    }
    function Jt(z, Z) {
      let Ce = 1;
      const Le = Z.length - 1;
      for (; Ce <= Le; ) {
        if (!z._emit[Ce]) {
          Ce++;
          continue;
        }
        const ot = ge.classNameAliases[z[Ce]] || z[Ce], en = Z[Ce];
        ot ? He(en, ot) : (Te = en, ze(), Te = ""), Ce++;
      }
    }
    function _t(z, Z) {
      return z.scope && typeof z.scope == "string" && De.openNode(ge.classNameAliases[z.scope] || z.scope), z.beginScope && (z.beginScope._wrap ? (He(Te, ge.classNameAliases[z.beginScope._wrap] || z.beginScope._wrap), Te = "") : z.beginScope._multi && (Jt(z.beginScope, Z), Te = "")), ae = Object.create(z, { parent: { value: ae } }), ae;
    }
    function dn(z, Z, Ce) {
      let Le = Jk(z.endRe, Ce);
      if (Le) {
        if (z["on:end"]) {
          const ot = new lh(z);
          z["on:end"](Z, ot), ot.isMatchIgnored && (Le = !1);
        }
        if (Le) {
          for (; z.endsParent && z.parent; )
            z = z.parent;
          return z;
        }
      }
      if (z.endsWithParent)
        return dn(z.parent, Z, Ce);
    }
    function Et(z) {
      return ae.matcher.regexIndex === 0 ? (Te += z[0], 1) : (zt = !0, 0);
    }
    function un(z) {
      const Z = z[0], Ce = z.rule, Le = new lh(Ce), ot = [Ce.__beforeBegin, Ce["on:begin"]];
      for (const en of ot)
        if (en && (en(z, Le), Le.isMatchIgnored))
          return Et(Z);
      return Ce.skip ? Te += Z : (Ce.excludeBegin && (Te += Z), Re(), !Ce.returnBegin && !Ce.excludeBegin && (Te = Z)), _t(Ce, z), Ce.returnBegin ? 0 : Z.length;
    }
    function An(z) {
      const Z = z[0], Ce = I.substring(z.index), Le = dn(ae, z, Ce);
      if (!Le)
        return hh;
      const ot = ae;
      ae.endScope && ae.endScope._wrap ? (Re(), He(Z, ae.endScope._wrap)) : ae.endScope && ae.endScope._multi ? (Re(), Jt(ae.endScope, z)) : ot.skip ? Te += Z : (ot.returnEnd || ot.excludeEnd || (Te += Z), Re(), ot.excludeEnd && (Te = Z));
      do
        ae.scope && De.closeNode(), !ae.skip && !ae.subLanguage && ($t += ae.relevance), ae = ae.parent;
      while (ae !== Le.parent);
      return Le.starts && _t(Le.starts, z), ot.returnEnd ? 0 : Z.length;
    }
    function En() {
      const z = [];
      for (let Z = ae; Z !== ge; Z = Z.parent)
        Z.scope && z.unshift(Z.scope);
      z.forEach((Z) => De.openNode(Z));
    }
    let Xt = {};
    function xn(z, Z) {
      const Ce = Z && Z[0];
      if (Te += z, Ce == null)
        return Re(), 0;
      if (Xt.type === "begin" && Z.type === "end" && Xt.index === Z.index && Ce === "") {
        if (Te += I.slice(Z.index, Z.index + 1), !i) {
          const Le = new Error(`0 width match regex (${L})`);
          throw Le.languageName = L, Le.badRule = Xt.rule, Le;
        }
        return 1;
      }
      if (Xt = Z, Z.type === "begin")
        return un(Z);
      if (Z.type === "illegal" && !G) {
        const Le = new Error('Illegal lexeme "' + Ce + '" for mode "' + (ae.scope || "<unnamed>") + '"');
        throw Le.mode = ae, Le;
      } else if (Z.type === "end") {
        const Le = An(Z);
        if (Le !== hh)
          return Le;
      }
      if (Z.type === "illegal" && Ce === "")
        return 1;
      if (kn > 1e5 && kn > Z.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return Te += Ce, Ce.length;
    }
    const ge = T(L);
    if (!ge)
      throw ni(o.replace("{}", L)), new Error('Unknown language: "' + L + '"');
    const Wt = AS(ge);
    let Nt = "", ae = oe || Wt;
    const Bt = {}, De = new a.__emitter(a);
    En();
    let Te = "", $t = 0, rt = 0, kn = 0, zt = !1;
    try {
      if (ge.__emitTokens)
        ge.__emitTokens(I, De);
      else {
        for (ae.matcher.considerAll(); ; ) {
          kn++, zt ? zt = !1 : ae.matcher.considerAll(), ae.matcher.lastIndex = rt;
          const z = ae.matcher.exec(I);
          if (!z) break;
          const Z = I.substring(rt, z.index), Ce = xn(Z, z);
          rt = z.index + Ce;
        }
        xn(I.substring(rt));
      }
      return De.finalize(), Nt = De.toHTML(), {
        language: L,
        value: Nt,
        relevance: $t,
        illegal: !1,
        _emitter: De,
        _top: ae
      };
    } catch (z) {
      if (z.message && z.message.includes("Illegal"))
        return {
          language: L,
          value: s1(I),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: z.message,
            index: rt,
            context: I.slice(rt - 100, rt + 100),
            mode: z.mode,
            resultSoFar: Nt
          },
          _emitter: De
        };
      if (i)
        return {
          language: L,
          value: s1(I),
          illegal: !1,
          relevance: 0,
          errorRaised: z,
          _emitter: De,
          _top: ae
        };
      throw z;
    }
  }
  function f(L) {
    const I = {
      value: s1(L),
      illegal: !1,
      relevance: 0,
      _top: s,
      _emitter: new a.__emitter(a)
    };
    return I._emitter.addText(L), I;
  }
  function p(L, I) {
    I = I || a.languages || Object.keys(e);
    const G = f(L), oe = I.filter(T).filter(j).map(
      (Re) => u(Re, L, !1)
    );
    oe.unshift(G);
    const me = oe.sort((Re, He) => {
      if (Re.relevance !== He.relevance) return He.relevance - Re.relevance;
      if (Re.language && He.language) {
        if (T(Re.language).supersetOf === He.language)
          return 1;
        if (T(He.language).supersetOf === Re.language)
          return -1;
      }
      return 0;
    }), [_e, ze] = me, pt = _e;
    return pt.secondBest = ze, pt;
  }
  function h(L, I, G) {
    const oe = I && n[I] || G;
    L.classList.add("hljs"), L.classList.add(`language-${oe}`);
  }
  function m(L) {
    let I = null;
    const G = c(L);
    if (l(G)) return;
    if (ee(
      "before:highlightElement",
      { el: L, language: G }
    ), L.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", L);
      return;
    }
    if (L.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(L)), a.throwUnescapedHTML))
      throw new DS(
        "One of your code blocks includes unescaped HTML.",
        L.innerHTML
      );
    I = L;
    const oe = I.textContent, me = G ? d(oe, { language: G, ignoreIllegals: !0 }) : p(oe);
    L.innerHTML = me.value, L.dataset.highlighted = "yes", h(L, G, me.language), L.result = {
      language: me.language,
      // TODO: remove with version 11.0
      re: me.relevance,
      relevance: me.relevance
    }, me.secondBest && (L.secondBest = {
      language: me.secondBest.language,
      relevance: me.secondBest.relevance
    }), ee("after:highlightElement", { el: L, result: me, text: oe });
  }
  function g(L) {
    a = ph(a, L);
  }
  const C = () => {
    b(), bi("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function v() {
    b(), bi("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let _ = !1;
  function b() {
    if (document.readyState === "loading") {
      _ = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(m);
  }
  function x() {
    _ && b();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", x, !1);
  function y(L, I) {
    let G = null;
    try {
      G = I(t);
    } catch (oe) {
      if (ni("Language definition for '{}' could not be registered.".replace("{}", L)), i)
        ni(oe);
      else
        throw oe;
      G = s;
    }
    G.name || (G.name = L), e[L] = G, G.rawDefinition = I.bind(null, t), G.aliases && D(G.aliases, { languageName: L });
  }
  function M(L) {
    delete e[L];
    for (const I of Object.keys(n))
      n[I] === L && delete n[I];
  }
  function S() {
    return Object.keys(e);
  }
  function T(L) {
    return L = (L || "").toLowerCase(), e[L] || e[n[L]];
  }
  function D(L, { languageName: I }) {
    typeof L == "string" && (L = [L]), L.forEach((G) => {
      n[G.toLowerCase()] = I;
    });
  }
  function j(L) {
    const I = T(L);
    return I && !I.disableAutodetect;
  }
  function V(L) {
    L["before:highlightBlock"] && !L["before:highlightElement"] && (L["before:highlightElement"] = (I) => {
      L["before:highlightBlock"](
        Object.assign({ block: I.el }, I)
      );
    }), L["after:highlightBlock"] && !L["after:highlightElement"] && (L["after:highlightElement"] = (I) => {
      L["after:highlightBlock"](
        Object.assign({ block: I.el }, I)
      );
    });
  }
  function X(L) {
    V(L), r.push(L);
  }
  function de(L) {
    const I = r.indexOf(L);
    I !== -1 && r.splice(I, 1);
  }
  function ee(L, I) {
    const G = L;
    r.forEach(function(oe) {
      oe[G] && oe[G](I);
    });
  }
  function J(L) {
    return bi("10.7.0", "highlightBlock will be removed entirely in v12.0"), bi("10.7.0", "Please use highlightElement now."), m(L);
  }
  Object.assign(t, {
    highlight: d,
    highlightAuto: p,
    highlightAll: b,
    highlightElement: m,
    // TODO: Remove with v12 API
    highlightBlock: J,
    configure: g,
    initHighlighting: C,
    initHighlightingOnLoad: v,
    registerLanguage: y,
    unregisterLanguage: M,
    listLanguages: S,
    getLanguage: T,
    registerAliases: D,
    autoDetection: j,
    inherit: ph,
    addPlugin: X,
    removePlugin: de
  }), t.debugMode = function() {
    i = !1;
  }, t.safeMode = function() {
    i = !0;
  }, t.versionString = IS, t.regex = {
    concat: fi,
    lookahead: T2,
    either: Rd,
    optional: Qk,
    anyNumberOfTimes: qk
  };
  for (const L in Os)
    typeof Os[L] == "object" && M2(Os[L]);
  return Object.assign(t, Os), t;
}, Ui = $2({});
Ui.newInstance = () => $2({});
var BS = Ui;
Ui.HighlightJS = Ui;
Ui.default = Ui;
var $S = /* @__PURE__ */ jk(BS);
function z2(t, e = []) {
  return t.map((n) => {
    const r = [...e, ...n.properties ? n.properties.className : []];
    return n.children ? z2(n.children, r) : {
      text: n.value,
      classes: r
    };
  }).flat();
}
function gh(t) {
  return t.value || t.children || [];
}
function zS(t) {
  return !!$S.getLanguage(t);
}
function mh({ doc: t, name: e, lowlight: n, defaultLanguage: r }) {
  const i = [];
  return T1(t, (o) => o.type.name === e).forEach((o) => {
    var s;
    let a = o.pos + 1;
    const l = o.node.attrs.language || r, c = n.listLanguages(), d = l && (c.includes(l) || zS(l) || !((s = n.registered) === null || s === void 0) && s.call(n, l)) ? gh(n.highlight(l, o.node.textContent)) : gh(n.highlightAuto(o.node.textContent));
    z2(d).forEach((u) => {
      const f = a + u.text.length;
      if (u.classes.length) {
        const p = Tt.inline(a, f, {
          class: u.classes.join(" ")
        });
        i.push(p);
      }
      a = f;
    });
  }), Ke.create(t, i);
}
function HS(t) {
  return typeof t == "function";
}
function FS({ name: t, lowlight: e, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((i) => HS(e[i])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const r = new Qe({
    key: new ct("lowlight"),
    state: {
      init: (i, { doc: o }) => mh({
        doc: o,
        name: t,
        lowlight: e,
        defaultLanguage: n
      }),
      apply: (i, o, s, a) => {
        const l = s.selection.$head.parent.type.name, c = a.selection.$head.parent.type.name, d = T1(s.doc, (f) => f.type.name === t), u = T1(a.doc, (f) => f.type.name === t);
        return i.docChanged && ([l, c].includes(t) || u.length !== d.length || i.steps.some((f) => (
          // @ts-ignore
          f.from !== void 0 && f.to !== void 0 && d.some((p) => (
            // @ts-ignore
            p.pos >= f.from && p.pos + p.node.nodeSize <= f.to
          ))
        ))) ? mh({
          doc: i.doc,
          name: t,
          lowlight: e,
          defaultLanguage: n
        }) : o.map(i.mapping, i.doc);
      }
    },
    props: {
      decorations(i) {
        return r.getState(i);
      }
    }
  });
  return r;
}
const US = F6.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) === null || t === void 0 ? void 0 : t.call(this),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      ...((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)) || [],
      FS({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
}), VS = { class: "language" }, jS = { class: "pre-wrap" }, WS = /* @__PURE__ */ ve({
  __name: "code-block-view",
  props: qo,
  setup(t) {
    const e = t, n = U(e.extension.options.lowlight.listLanguages()), r = Ge({
      get() {
        return e.node.attrs.language;
      },
      set(i) {
        e.updateAttributes({ language: i });
      }
    });
    return (i, o) => {
      const s = ce("a-select-option"), a = ce("a-select");
      return B(), ye(se(Go), {
        as: "div",
        class: "code-block"
      }, {
        default: R(() => [
          E("div", VS, [
            k(a, {
              ref: "select",
              value: r.value,
              "onUpdate:value": o[0] || (o[0] = (l) => r.value = l)
            }, {
              default: R(() => [
                (B(!0), he(Ye, null, bt(n.value, (l, c) => (B(), ye(s, {
                  value: l,
                  key: c
                }, {
                  default: R(() => [
                    Ae(ft(l), 1)
                  ]),
                  _: 2
                }, 1032, ["value"]))), 128))
              ]),
              _: 1
            }, 8, ["value"])
          ]),
          E("div", jS, [
            E("pre", null, [
              E("code", null, [
                k(se(d9))
              ])
            ])
          ])
        ]),
        _: 1
      });
    };
  }
}), ZS = /* @__PURE__ */ dt(WS, [["__scopeId", "data-v-4fd71d43"]]), KS = US.extend({
  name: "CodeBlockLights",
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      language: {
        default: "html"
      }
    };
  },
  addNodeView() {
    return Qo(ZS);
  }
}), GS = "search-highlight", qS = "search-highlight-current";
function a1(t, e, n) {
  const r = [], i = new RegExp(e, "gi");
  return t.descendants((o, s) => {
    if (!o.isText || !o.text) return;
    const a = o.text;
    let l;
    for (; (l = i.exec(a)) !== null; ) {
      const c = s + l.index, d = c + l[0].length, u = Tt.inline(c, d, {
        class: r.length === n ? qS : GS
      });
      u && r.push(u);
    }
  }), r;
}
const xi = new ct("search");
let H2 = new Qe({
  state: {
    init() {
      return {
        decorationSet: Ke.empty
      };
    },
    apply(t, e) {
      const n = t.getMeta(xi);
      return n ? {
        decorationSet: Ke.create(t.doc, n.decorations)
      } : {
        decorationSet: e.decorationSet.map(t.mapping, t.doc)
      };
    }
  },
  props: {
    decorations(t) {
      return H2.getState(t).decorationSet;
    }
  }
});
const QS = qe.create({
  name: "searchreplace",
  addOptions() {
    return {
      activeIndex: 0,
      decorations: [],
      currentQuery: ""
    };
  },
  /**
   * @param {string} dispatch -如果调度已通过，请执行它们的效果，可能通过将事务传递给调度
   * @returns
   */
  //@ts-ignore
  addCommands() {
    return {
      search: (t) => ({ dispatch: e, tr: n }) => {
        if (!t.trim()) return !1;
        if (this.options.currentQuery = t, e)
          try {
            const r = a1(n.doc, t, this.options.activeIndex);
            this.options.decorations = r.map((i) => i), ao.emit("search", this.options), n.setMeta(xi, { decorations: r });
          } catch (r) {
            console.error("[@warn/search-replace] Search error:", r);
          }
        return !0;
      },
      findNext: () => ({ dispatch: t }) => (t && (this.options.activeIndex = this.options.activeIndex < this.options.decorations.length - 1 ? this.options.activeIndex + 1 : this.options.decorations.length - 1), !0),
      findPrev: () => ({ dispatch: t }) => (t && (this.options.activeIndex = this.options.activeIndex - 1 <= 0 ? 0 : this.options.activeIndex - 1), !0),
      clearSearch: () => ({ dispatch: t, tr: e }) => (t && (this.options.activeIndex = 0, this.options.decorations = [], e.setMeta(xi, { decorations: [] })), !0),
      replace: (t) => ({
        dispatch: e,
        tr: n,
        editor: r
      }) => {
        if (!t.trim()) return !1;
        const i = this.options.currentQuery, o = a1(n.doc, i, this.options.activeIndex);
        if (e && o.length > 0) {
          const s = o[this.options.activeIndex];
          s && (n.replaceWith(s.from, s.to, r.schema.text(t)), this.options.decorations = o.map((a) => a), n.setMeta(xi, { decorations: o }), ao.emit("search", this.options)), this.options.activeIndex === o.length - 1 && (this.options.activeIndex = 0);
        }
        return !0;
      },
      replaceAll: (t) => ({
        dispatch: e,
        tr: n,
        editor: r
      }) => t.trim() ? (e && this.options.decorations.length > 0 && ([...this.options.decorations].sort((i, o) => o.from - i.from).forEach((i) => {
        n.replaceWith(i.from, i.to, r.schema.text(t));
      }), this.options.activeIndex = 0, this.options.decorations = [], n.setMeta(xi, { decorations: [] }), ao.emit("search", this.options)), !0) : !1
    };
  },
  addProseMirrorPlugins() {
    return [H2];
  },
  // 富文本编辑器内容变化
  //@ts-ignore
  onUpdate({ editor: t }) {
    const { currentQuery: e, activeIndex: n } = this.options;
    if (e) {
      const r = a1(t.state.doc, e, n);
      this.options.decorations = r, this.options.activeIndex > this.options.decorations.length - 1 && (this.options.activeIndex = this.options.decorations.length - 1);
      const i = t.state.tr;
      i.setMeta(xi, { decorations: r }), t.view.dispatch(i), ao.emit("search", this.options);
    }
  }
}), YS = ["data"], JS = ["href"], XS = ["src"], eM = /* @__PURE__ */ ve({
  __name: "iframe-view",
  props: qo,
  setup(t) {
    const e = t, n = Ge(() => {
      const r = e.node.attrs.src;
      return r ? !!(r.startsWith("data:application/pdf") || r.includes(".pdf") || r.includes("application/pdf")) : !1;
    });
    return (r, i) => (B(), ye(se(Go), {
      as: "div",
      class: "iframe"
    }, {
      default: R(() => [
        n.value ? (B(), he("object", {
          key: 0,
          class: "iframe__embed",
          data: r.node.attrs.src,
          type: "application/pdf",
          style: { border: "none" }
        }, [
          E("p", null, [
            i[0] || (i[0] = Ae("您的浏览器不支持PDF显示，请 ")),
            E("a", {
              href: r.node.attrs.src,
              target: "_blank"
            }, "点击这里下载", 8, JS)
          ])
        ], 8, YS)) : (B(), he("iframe", {
          key: 1,
          class: "iframe__embed",
          src: r.node.attrs.src,
          style: { border: "none" }
        }, null, 8, XS))
      ]),
      _: 1
    }));
  }
}), tM = /* @__PURE__ */ dt(eM, [["__scopeId", "data-v-932be85d"]]), nM = nt.create({
  name: "iframe",
  // schema
  group: "block",
  selectable: !1,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null,
        parseHTML: (e) => e.getAttribute("src")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "iframe",
      Be(t, {
        frameborder: 0,
        allowfullscreen: "true"
      })
    ];
  },
  addCommands() {
    return {
      setIframe: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addNodeView() {
    return Qo(tM);
  }
}), rM = TE.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      fontSize: {
        default: null,
        parseHTML: (e) => e.style.fontSize.replace("px", ""),
        renderHTML: (e) => e.fontSize ? {
          style: `font-size: ${e.fontSize}px`
        } : {}
      }
    };
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      setFontSize: (e) => ({ commands: n, editor: r }) => {
        if (!r.isActive("heading"))
          return n.setMark(this.name, { fontSize: e });
      },
      unsetFontSize: () => ({ chain: e }) => e().setMark(this.name, { fontSize: null }).removeEmptyTextStyle().run()
      // setLineHeight:
      // 	lineHeight =>
      // 	({ commands }) => {
      // 		return commands.setMark(this.name, { lineHeight });
      // 	}
    };
  }
});
function iM(t) {
  const { selection: e } = t, { from: n, to: r } = e, i = [];
  return t.doc.nodesBetween(n, r, (o, s) => {
    o.isText && o.marks.forEach((a) => {
      i.includes(a) || i.push(a);
    });
  }), i;
}
function oM(t, e) {
  const { lastSelectionMarks: n } = F2.options;
  if (!n || n.length === 0)
    return !1;
  const { from: r, to: i } = t.selection, o = t.tr;
  return n.forEach((s) => {
    o.addMark(r, i, s);
  }), o.docChanged && e(o), !0;
}
const F2 = qe.create({
  name: "formatBrush",
  addOptions() {
    return {
      lastSelectionMarks: null
      // 存储最后一次选中格式信息
    };
  },
  addStorage() {
    return {
      isDoubleClick: !1,
      // 双击状态
      isBrushActive: !1
      // 格式刷模式是否激活
    };
  },
  //@ts-ignore
  onSelectionUpdate({ editor: t }) {
    const { state: e } = t;
    this.options.lastSelectionMarks && this.storage.isBrushActive && oM(e, t.view.dispatch);
  },
  addCommands() {
    return {
      copyFormat: (t) => ({ state: e }) => {
        const n = document.querySelector(".tiptap");
        n == null || n.classList.add("tiptap__brush"), this.options.lastSelectionMarks = null, t.type === "dblclick" && (this.storage.isDoubleClick = !0), this.storage.isBrushActive = !0;
        const { selection: r } = e;
        if (!r.empty) {
          const i = iM(e);
          this.options.lastSelectionMarks = i;
        }
        return !0;
      }
    };
  },
  // 监听键盘事件以退出格式刷
  addKeyboardShortcuts() {
    return {
      Escape: () => {
        this.storage.isBrushActive = !1, this.storage.isDoubleClick = !1;
        const t = document.querySelector(".tiptap");
        return t == null || t.classList.remove("tiptap__brush"), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Qe({
        props: {
          handleDOMEvents: {
            mouseup: () => {
              if (!this.storage.isDoubleClick) {
                this.storage.isBrushActive = !1;
                const t = document.querySelector(".tiptap");
                t == null || t.classList.remove("tiptap__brush");
              }
              return !0;
            }
          }
        }
      })
    ];
  }
}), sM = qe.create({
  name: "lineHeight",
  addOptions() {
    return {
      types: ["heading", "paragraph"],
      heights: ["100%", "115%", "150%", "200%", "250%", "300%"],
      defaultHeight: "100%"
    };
  },
  //@ts-ignore
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: this.options.defaultHeight,
            parseHTML: (t) => t.style.lineHeight || this.options.defaultHeight,
            renderHTML: (t) => t.lineHeight === this.options.defaultHeight ? {} : { style: `line-height: ${t.lineHeight}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => ({ commands: e }) => this.options.heights.includes(t) ? this.options.types.every(
        (n) => e.updateAttributes(n, { lineHeight: t })
      ) : !1,
      unsetLineHeight: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "lineHeight"))
    };
  }
}), aM = { class: "pdf-view__container" }, lM = {
  key: 0,
  class: "pdf-view__preview"
}, cM = ["data"], dM = { class: "pdf-view__fallback" }, uM = ["src"], fM = ["src"], pM = { class: "pdf-view__preview-controls" }, hM = {
  key: 1,
  class: "pdf-view__info"
}, gM = { class: "pdf-view__toggle" }, mM = /* @__PURE__ */ ve({
  __name: "pdf-view",
  props: qo,
  setup(t) {
    const e = t, n = U(!1), r = U("object"), i = Ge(() => {
      const a = e.node.attrs.fileName;
      return a || "document.pdf";
    });
    Ge(() => {
      var a;
      return (a = e.node.attrs.src) == null ? void 0 : a.startsWith("blob:");
    }), Ge(() => {
      var a;
      return (a = e.node.attrs.src) == null ? void 0 : a.startsWith("data:");
    });
    const o = () => {
      n.value = !n.value;
    }, s = () => {
      const a = document.createElement("a");
      a.href = e.node.attrs.src, a.download = i.value, a.target = "_blank", document.body.appendChild(a), a.click(), document.body.removeChild(a);
    };
    return (a, l) => {
      const c = ce("a-button"), d = ce("a-popover");
      return B(), ye(se(Go), {
        as: "div",
        class: "pdf-view"
      }, {
        default: R(() => [
          E("div", aM, [
            n.value ? (B(), he("div", lM, [
              r.value === "object" ? (B(), he("object", {
                key: 0,
                class: "pdf-view__embed",
                data: a.node.attrs.src,
                type: "application/pdf",
                style: { border: "none" }
              }, [
                E("div", dM, [
                  l[5] || (l[5] = E("p", null, "object标签无法显示PDF，尝试其他方式...", -1)),
                  E("button", {
                    onClick: l[0] || (l[0] = (u) => r.value = "iframe"),
                    class: "pdf-view__fallback-btn"
                  }, " 使用iframe预览 "),
                  E("button", {
                    onClick: l[1] || (l[1] = (u) => r.value = "embed"),
                    class: "pdf-view__fallback-btn"
                  }, " 使用embed预览 ")
                ])
              ], 8, cM)) : r.value === "iframe" ? (B(), he("iframe", {
                key: 1,
                class: "pdf-view__embed",
                src: a.node.attrs.src,
                style: { border: "none" }
              }, null, 8, uM)) : r.value === "embed" ? (B(), he("embed", {
                key: 2,
                class: "pdf-view__embed",
                src: a.node.attrs.src,
                type: "application/pdf",
                style: { border: "none" }
              }, null, 8, fM)) : it("", !0),
              E("div", pM, [
                E("button", {
                  onClick: l[2] || (l[2] = (u) => r.value = "object"),
                  class: "pdf-view__control-btn"
                }, "Object"),
                E("button", {
                  onClick: l[3] || (l[3] = (u) => r.value = "iframe"),
                  class: "pdf-view__control-btn"
                }, "Iframe"),
                E("button", {
                  onClick: l[4] || (l[4] = (u) => r.value = "embed"),
                  class: "pdf-view__control-btn"
                }, "Embed"),
                E("button", {
                  onClick: o,
                  class: "pdf-view__control-btn"
                }, "Link")
              ])
            ])) : it("", !0),
            n.value ? it("", !0) : (B(), he("div", hM, [
              k(d, { placement: "top" }, {
                content: R(() => [
                  E("div", gM, [
                    k(c, {
                      onClick: o,
                      type: "link",
                      size: "small"
                    }, {
                      default: R(() => [
                        Ae(ft(n.value ? "Link模式" : "预览模式"), 1)
                      ]),
                      _: 1
                    })
                  ])
                ]),
                default: R(() => [
                  E("a", {
                    class: "pdf-view__filename",
                    onClick: s
                  }, "📄" + ft(i.value), 1)
                ]),
                _: 1
              })
            ]))
          ])
        ]),
        _: 1
      });
    };
  }
}), CM = /* @__PURE__ */ dt(mM, [["__scopeId", "data-v-a3c29bca"]]), bM = nt.create({
  name: "pdf",
  group: "block",
  selectable: !1,
  draggable: !0,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null,
        parseHTML: (e) => e.getAttribute("src") || e.getAttribute("data")
      },
      fileName: {
        default: null,
        parseHTML: (e) => e.getAttribute("data-filename")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-type='pdf']"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      Be(t, {
        "data-type": "pdf"
      })
    ];
  },
  addCommands() {
    return {
      setPdf: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addNodeView() {
    return Qo(CM);
  }
});
function yM(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, d = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, u = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + t.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], C = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], b = {
    type: m,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: C
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, y = [
    x,
    u,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    d,
    c
  ], M = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: b,
    contains: y.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: b,
        contains: y.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, S = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: b,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: b,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          d
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: b,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          d,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: b,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              d,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      u
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: b,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      M,
      S,
      x,
      y,
      [
        u,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: b,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: b
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function vM(t) {
  const e = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = yM(t), r = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return r.type = [
    ...r.type,
    ...e.type
  ], r.literal = [
    ...r.literal,
    ...e.literal
  ], r.built_in = [
    ...r.built_in,
    ...e.built_in
  ], r._hints = e._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function wM(t) {
  const e = t.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [t.BACKSLASH_ESCAPE]
  }, o = t.inherit(
    t.COMMENT(),
    {
      match: [
        /(^|\s)/,
        /#.*$/
      ],
      scope: {
        2: "comment"
      }
    }
  ), s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      t.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, a = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      n,
      i
    ]
  };
  i.contains.push(a);
  const l = {
    match: /\\"/
  }, c = {
    className: "string",
    begin: /'/,
    end: /'/
  }, d = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      t.NUMBER_MODE,
      n
    ]
  }, f = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], p = t.SHEBANG({
    binary: `(${f.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, m = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "time",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "coproc",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], C = { match: /(\/[a-z._-]+)+/ }, v = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], _ = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "sudo",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], b = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], x = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: [
      "sh",
      "zsh"
    ],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: m,
      literal: g,
      built_in: [
        ...v,
        ..._,
        // Shell modifiers
        "set",
        "shopt",
        ...b,
        ...x
      ]
    },
    contains: [
      p,
      // to catch known shells and boost relevancy
      t.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      u,
      o,
      s,
      C,
      a,
      l,
      c,
      d,
      n
    ]
  };
}
function _M(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, d = {
    className: "number",
    variants: [
      { match: /\b(0b[01']+)/ },
      { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
      { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
      { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
    ],
    relevance: 0
  }, u = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + t.IDENT_RE + "\\s*\\(", g = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "typeof",
      "typeof_unqual",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_BitInt",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal96",
      "_Decimal128",
      "_Decimal64x",
      "_Decimal128x",
      "_Float16",
      "_Float32",
      "_Float64",
      "_Float128",
      "_Float32x",
      "_Float64x",
      "_Float128x",
      // modifiers
      "const",
      "static",
      "constexpr",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, C = [
    u,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    d,
    c
  ], v = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: g,
    contains: C.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: g,
        contains: C.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, _ = {
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: g,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: g,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [t.inherit(f, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: g,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          d,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              d,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      u
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: g,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      v,
      _,
      C,
      [
        u,
        {
          begin: t.IDENT_RE + "::",
          keywords: g
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            t.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: u,
      strings: c,
      keywords: g
    }
  };
}
function EM(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, d = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, u = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + t.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + t.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], C = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], b = {
    type: m,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: C
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, y = [
    x,
    u,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    d,
    c
  ], M = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: b,
    contains: y.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: b,
        contains: y.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, S = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: b,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: b,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          d
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: b,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          d,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: b,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              d,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      u
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: b,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      M,
      S,
      x,
      y,
      [
        u,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: b,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: b
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function xM(t) {
  const e = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], i = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], o = [
    "add",
    "alias",
    "and",
    "ascending",
    "args",
    "async",
    "await",
    "by",
    "descending",
    "dynamic",
    "equals",
    "file",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "record",
    "remove",
    "required",
    "scoped",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], s = {
    keyword: i.concat(o),
    built_in: e,
    literal: r
  }, a = t.inherit(t.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, c = {
    className: "string",
    begin: /"""("*)(?!")(.|\n)*?"""\1/,
    relevance: 1
  }, d = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, u = t.inherit(d, { illegal: /\n/ }), f = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: s
  }, p = t.inherit(f, { illegal: /\n/ }), h = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      t.BACKSLASH_ESCAPE,
      p
    ]
  }, m = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      f
    ]
  }, g = t.inherit(m, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      p
    ]
  });
  f.contains = [
    m,
    h,
    d,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.C_BLOCK_COMMENT_MODE
  ], p.contains = [
    g,
    h,
    u,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.inherit(t.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const C = { variants: [
    c,
    m,
    h,
    d,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ] }, v = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      a
    ]
  }, _ = t.IDENT_RE + "(<" + t.IDENT_RE + "(\\s*,\\s*" + t.IDENT_RE + ")*>)?(\\[\\])?", b = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + t.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: s,
    illegal: /::/,
    contains: [
      t.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      C,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          a,
          v,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          v,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + _ + "\\s+)+" + t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              t.TITLE_MODE,
              v
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [
              C,
              l,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      b
    ]
  };
}
const kM = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), SM = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], MM = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], OM = [
  ...SM,
  ...MM
], TM = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), LM = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), NM = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), AM = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function RM(t) {
  const e = t.regex, n = kM(t), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", o = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + s,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + LM.join("|") + ")" },
          { begin: ":(:)?(" + NM.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + AM.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: o
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: TM.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...a,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + OM.join("|") + ")\\b"
      }
    ]
  };
}
function IM(t) {
  const e = t.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function DM(t) {
  const o = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: o,
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            // hex without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            // hex with a present digit before . (making a digit afterwards optional)
            relevance: 0
          },
          {
            match: /-?\b0[oO](_?[0-7])*i?/,
            // leading 0o octal
            relevance: 0
          },
          {
            match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
            // decimal without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            // decimal with a present digit before . (making a digit afterwards optional)
            relevance: 0
          }
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          t.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: o,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function PM(t) {
  const e = t.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      t.HASH_COMMENT_MODE,
      t.QUOTE_STRING_MODE,
      t.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: e.concat(n, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function BM(t) {
  const e = t.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: t.NUMBER_RE }
    ]
  }, r = t.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, o = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, s = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, a = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      o,
      i,
      s,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, d = /'[^']*'/, u = e.either(
    l,
    c,
    d
  ), f = e.concat(
    u,
    "(\\s*\\.\\s*",
    u,
    ")*",
    e.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: f,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            a,
            o,
            i,
            s,
            n
          ]
        }
      }
    ]
  };
}
var ki = "[0-9](_*[0-9])*", Ts = `\\.(${ki})`, Ls = "[0-9a-fA-F](_*[0-9a-fA-F])*", Ch = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${ki})((${Ts})|\\.)?|(${Ts}))[eE][+-]?(${ki})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${ki})((${Ts})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Ts})[fFdD]?\\b` },
    { begin: `\\b(${ki})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Ls})\\.?|(${Ls})?\\.(${Ls}))[pP][+-]?(${ki})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Ls})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function U2(t, e, n) {
  return n === -1 ? "" : t.replace(e, (r) => U2(t, e, n - 1));
}
function $M(t) {
  const e = t.regex, n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", r = n + U2("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits",
      "goto",
      "when"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, c = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, d = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [t.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [t.BACKSLASH_ESCAPE]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          d,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          t.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              t.APOS_STRING_MODE,
              t.QUOTE_STRING_MODE,
              Ch,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      Ch,
      c
    ]
  };
}
const bh = "[A-Za-z$_][0-9A-Za-z$_]*", zM = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], HM = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], V2 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], j2 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], W2 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], FM = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], UM = [].concat(
  W2,
  V2,
  j2
);
function VM(t) {
  const e = t.regex, n = (I, { after: G }) => {
    const oe = "</" + I[0].slice(1);
    return I.input.indexOf(oe, G) !== -1;
  }, r = bh, i = {
    begin: "<>",
    end: "</>"
  }, o = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (I, G) => {
      const oe = I[0].length + I.index, me = I.input[oe];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        me === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        me === ","
      ) {
        G.ignoreMatch();
        return;
      }
      me === ">" && (n(I, { after: oe }) || G.ignoreMatch());
      let _e;
      const ze = I.input.substring(oe);
      if (_e = ze.match(/^\s*=/)) {
        G.ignoreMatch();
        return;
      }
      if ((_e = ze.match(/^\s+extends\s+/)) && _e.index === 0) {
        G.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: bh,
    keyword: zM,
    literal: HM,
    built_in: UM,
    "variable.language": FM
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, d = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", u = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${d})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${d})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, v = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, _ = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    p,
    h,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    u
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = _.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(_)
  });
  const b = [].concat(v, f.contains), x = b.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(b)
    }
  ]), y = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: x
  }, M = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, S = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...V2,
        ...j2
      ]
    }
  }, T = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, D = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [y],
    illegal: /%/
  }, j = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function V(I) {
    return e.concat("(?!", I.join("|"), ")");
  }
  const X = {
    match: e.concat(
      /\b/,
      V([
        ...W2,
        "super",
        "import"
      ].map((I) => `${I}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, de = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, ee = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      y
    ]
  }, J = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", L = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(J)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      y
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: S },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      T,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      p,
      h,
      m,
      g,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      u,
      S,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      L,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: J,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      D,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          y,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      de,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [y]
      },
      X,
      j,
      M,
      ee,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function jM(t) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: {
      literal: r
    },
    contains: [
      e,
      n,
      t.QUOTE_STRING_MODE,
      i,
      t.C_NUMBER_MODE,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var Si = "[0-9](_*[0-9])*", Ns = `\\.(${Si})`, As = "[0-9a-fA-F](_*[0-9a-fA-F])*", WM = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Si})((${Ns})|\\.)?|(${Ns}))[eE][+-]?(${Si})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Si})((${Ns})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Ns})[fFdD]?\\b` },
    { begin: `\\b(${Si})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${As})\\.?|(${As})?\\.(${As}))[pP][+-]?(${Si})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${As})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function ZM(t) {
  const e = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: t.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [t.C_NUMBER_MODE]
  }, o = {
    className: "variable",
    begin: "\\$" + t.UNDERSCORE_IDENT_RE
  }, s = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          o,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          t.BACKSLASH_ESCAPE,
          o,
          i
        ]
      }
    ]
  };
  i.contains.push(s);
  const a = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + t.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          t.inherit(s, { className: "string" }),
          "self"
        ]
      }
    ]
  }, c = WM, d = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [t.C_BLOCK_COMMENT_MODE] }
  ), u = { variants: [
    {
      className: "type",
      begin: t.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, f = u;
  return f.variants[1].contains = [u], u.variants[1].contains = [f], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: e,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      d,
      n,
      r,
      a,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: e,
        relevance: 5,
        contains: [
          {
            begin: t.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [t.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: e,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  u,
                  t.C_LINE_COMMENT_MODE,
                  d
                ],
                relevance: 0
              },
              t.C_LINE_COMMENT_MODE,
              d,
              a,
              l,
              s,
              t.C_NUMBER_MODE
            ]
          },
          d
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          t.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          a,
          l
        ]
      },
      s,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      c
    ]
  };
}
const KM = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), GM = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], qM = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], QM = [
  ...GM,
  ...qM
], YM = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), Z2 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), K2 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), JM = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse(), XM = Z2.concat(K2).sort().reverse();
function eO(t) {
  const e = KM(t), n = XM, r = "and or not only", i = "[\\w-]+", o = "(" + i + "|@\\{" + i + "\\})", s = [], a = [], l = function(_) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + _ + ".*?" + _
    };
  }, c = function(_, b, x) {
    return {
      className: _,
      begin: b,
      relevance: x
    };
  }, d = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: YM.join(" ")
  }, u = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: a,
    keywords: d,
    relevance: 0
  };
  a.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    e.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    e.HEXCOLOR,
    u,
    c("variable", "@@?" + i, 10),
    c("variable", "@\\{" + i + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: "and not" },
    e.FUNCTION_DISPATCH
  );
  const f = a.concat({
    begin: /\{/,
    end: /\}/,
    contains: s
  }), p = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(a)
    // using this form to override VALUE’s 'function' match
  }, h = {
    begin: o + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + JM.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: a
        }
      }
    ]
  }, m = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: d,
      returnEnd: !0,
      contains: a,
      relevance: 0
    }
  }, g = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: f
    }
  }, C = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: o,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      p,
      c("keyword", "all\\b"),
      c("variable", "@\\{" + i + "\\}"),
      // otherwise it’s identified as tag
      {
        begin: "\\b(" + QM.join("|") + ")\\b",
        className: "selector-tag"
      },
      e.CSS_NUMBER_MODE,
      c("selector-tag", o, 0),
      c("selector-id", "#" + o),
      c("selector-class", "\\." + o, 0),
      c("selector-tag", "&", 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + Z2.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + K2.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: f
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      e.FUNCTION_DISPATCH
    ]
  }, v = {
    begin: i + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [C]
  };
  return s.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    m,
    g,
    v,
    h,
    C,
    p,
    e.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: s
  };
}
function tO(t) {
  const e = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: e,
    end: n,
    contains: ["self"]
  }, i = [
    t.COMMENT("--(?!" + e + ")", "$"),
    t.COMMENT(
      "--" + e,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    aliases: ["pluto"],
    keywords: {
      $pattern: t.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          t.inherit(t.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      t.C_NUMBER_MODE,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: e,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function nO(t) {
  const e = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + t.UNDERSCORE_IDENT_RE + "\\)",
        contains: [t.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      e
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [
      e,
      n
      // Added QUOTE_STRING as they can be a part of functions
    ]
  }, i = { begin: "^" + t.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, o = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, s = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      t.HASH_COMMENT_MODE,
      e,
      n,
      r,
      i,
      o,
      s
    ]
  };
}
function rO(t) {
  const e = t.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, o = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, s = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, c = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, d = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, u = t.inherit(c, { contains: [] }), f = t.inherit(d, { contains: [] });
  c.contains.push(f), d.contains.push(u);
  let p = [
    n,
    l
  ];
  return [
    c,
    d,
    u,
    f
  ].forEach((C) => {
    C.contains = C.contains.concat(p);
  }), p = p.concat(c, d), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: p
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: p
              }
            ]
          }
        ]
      },
      n,
      o,
      c,
      d,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: p,
        end: "$"
      },
      i,
      r,
      l,
      s,
      {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      }
    ]
  };
}
function iO(t) {
  const e = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: a,
    illegal: "</",
    contains: [
      e,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      t.C_NUMBER_MODE,
      t.QUOTE_STRING_MODE,
      t.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [t.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t.inherit(t.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [t.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + t.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function oO(t) {
  const e = t.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "class",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "field",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "method",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, o = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, s = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, a = {
    scope: "attr",
    match: /\s+:\s*\w+(\s*\(.*?\))?/
  }, l = {
    scope: "variable",
    variants: [
      { begin: /\$\d/ },
      {
        begin: e.concat(
          /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![A-Za-z])(?![@$%])"
        )
      },
      {
        // Only $= is a special Perl variable and one can't declare @= or %=.
        begin: /[$%@](?!")[^\s\w{=]|\$=/,
        relevance: 0
      }
    ],
    contains: [a]
  }, c = {
    className: "number",
    variants: [
      // decimal numbers:
      // include the case where a number starts with a dot (eg. .9), and
      // the leading 0? avoids mixing the first and second match on 0.x cases
      { match: /0?\.[0-9][0-9_]+\b/ },
      // include the special versioned number (eg. v5.38)
      { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
      // non-decimal numbers:
      { match: /\b0[0-7][0-7_]*\b/ },
      { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
      { match: /\b0b[0-1][0-1_]*\b/ }
    ],
    relevance: 0
  }, d = [
    t.BACKSLASH_ESCAPE,
    o,
    l
  ], u = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], f = (m, g, C = "\\1") => {
    const v = C === "\\1" ? C : e.concat(C, g);
    return e.concat(
      e.concat("(?:", m, ")"),
      g,
      /(?:\\.|[^\\\/])*?/,
      v,
      /(?:\\.|[^\\\/])*?/,
      C,
      r
    );
  }, p = (m, g, C) => e.concat(
    e.concat("(?:", m, ")"),
    g,
    /(?:\\.|[^\\\/])*?/,
    C,
    r
  ), h = [
    l,
    t.HASH_COMMENT_MODE,
    t.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    s,
    {
      className: "string",
      contains: d,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    c,
    {
      // regexp container
      begin: "(\\/\\/|" + t.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        t.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: f("s|tr|y", e.either(...u, { capture: !0 })) },
            // and then paired delmis
            { begin: f("s|tr|y", "\\(", "\\)") },
            { begin: f("s|tr|y", "\\[", "\\]") },
            { begin: f("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: p("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: p("m|qr", e.either(...u, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: p("m|qr", /\(/, /\)/) },
            { begin: p("m|qr", /\[/, /\]/) },
            { begin: p("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub method",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE, a]
    },
    {
      className: "class",
      beginKeywords: "class",
      end: "[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE, a, c]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return o.contains = h, s.contains = h, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: h
  };
}
function sO(t) {
  const e = t.regex, n = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), i = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), o = e.concat(
    /[A-Z]+/,
    n
  ), s = {
    scope: "variable",
    match: "\\$+" + r
  }, a = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, l = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, c = t.inherit(t.APOS_STRING_MODE, { illegal: null }), d = t.inherit(t.QUOTE_STRING_MODE, {
    illegal: null,
    contains: t.QUOTE_STRING_MODE.contains.concat(l)
  }), u = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: t.QUOTE_STRING_MODE.contains.concat(l),
    "on:begin": (de, ee) => {
      ee.data._beginMatch = de[1] || de[2];
    },
    "on:end": (de, ee) => {
      ee.data._beginMatch !== de[1] && ee.ignoreMatch();
    }
  }, f = t.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), p = `[ 	
]`, h = {
    scope: "string",
    variants: [
      d,
      c,
      u,
      f
    ]
  }, m = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, g = [
    "false",
    "null",
    "true"
  ], C = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], v = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], b = {
    keyword: C,
    literal: ((de) => {
      const ee = [];
      return de.forEach((J) => {
        ee.push(J), J.toLowerCase() === J ? ee.push(J.toUpperCase()) : ee.push(J.toLowerCase());
      }), ee;
    })(g),
    built_in: v
  }, x = (de) => de.map((ee) => ee.replace(/\|\d+$/, "")), y = { variants: [
    {
      match: [
        /new/,
        e.concat(p, "+"),
        // to prevent built ins from being confused as the class constructor call
        e.concat("(?!", x(v).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, M = e.concat(r, "\\b(?!\\()"), S = { variants: [
    {
      match: [
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        M
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        M
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        e.concat(
          "::",
          e.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, T = {
    scope: "attr",
    match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
  }, D = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: b,
    contains: [
      T,
      s,
      S,
      t.C_BLOCK_COMMENT_MODE,
      h,
      m,
      y
    ]
  }, j = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      e.concat("(?!fn\\b|function\\b|", x(C).join("\\b|"), "|", x(v).join("\\b|"), "\\b)"),
      r,
      e.concat(p, "*"),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [D]
  };
  D.contains.push(j);
  const V = [
    T,
    S,
    t.C_BLOCK_COMMENT_MODE,
    h,
    m,
    y
  ], X = {
    begin: e.concat(
      /#\[\s*\\?/,
      e.either(
        i,
        o
      )
    ),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: g,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: g,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...V
        ]
      },
      ...V,
      {
        scope: "meta",
        variants: [
          { match: i },
          { match: o }
        ]
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: b,
    contains: [
      X,
      t.HASH_COMMENT_MODE,
      t.COMMENT("//", "$"),
      t.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: t.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      a,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      s,
      j,
      S,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      y,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          t.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: b,
            contains: [
              "self",
              X,
              s,
              S,
              t.C_BLOCK_COMMENT_MODE,
              h,
              m
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [t.inherit(t.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      h,
      m
    ]
  };
}
function aO(t) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          t.inherit(t.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          t.inherit(t.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function lO(t) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function cO(t) {
  const e = t.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], a = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, c = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: a,
    illegal: /#/
  }, d = {
    begin: /\{\{/,
    relevance: 0
  }, u = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          d,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          d,
          c
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          t.BACKSLASH_ESCAPE,
          d,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          t.BACKSLASH_ESCAPE,
          d,
          c
        ]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", p = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, h = `\\b|${r.join("|")}`, m = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${p}))[eE][+-]?(${f})[jJ]?(?=${h})`
      },
      {
        begin: `(${p})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${h})`
      }
    ]
  }, g = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: a,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, C = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: a,
        contains: [
          "self",
          l,
          m,
          u,
          t.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return c.contains = [
    u,
    m,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: a,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      m,
      {
        // very common convention
        scope: "variable.language",
        match: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      { match: /\bor\b/, scope: "keyword" },
      u,
      g,
      t.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [C]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          m,
          C,
          u
        ]
      }
    ]
  };
}
function dO(t) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function uO(t) {
  const e = t.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, o = e.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      t.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldn’t be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: e.lookahead(e.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      t.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [t.BACKSLASH_ESCAPE],
        variants: [
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              o,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: i },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: o
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function fO(t) {
  const e = t.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = e.concat(r, /(::\w+)*/), s = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, a = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, c = [
    t.COMMENT(
      "#",
      "$",
      { contains: [a] }
    ),
    t.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [a],
        relevance: 10
      }
    ),
    t.COMMENT("^__END__", t.MATCH_NOTHING_RE)
  ], d = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: s
  }, u = {
    className: "string",
    contains: [
      t.BACKSLASH_ESCAPE,
      d
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          t.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              t.BACKSLASH_ESCAPE,
              d
            ]
          })
        ]
      }
    ]
  }, f = "[1-9](_?[0-9])*|0", p = "[0-9](_?[0-9])*", h = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${f})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, m = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: s
      }
    ]
  }, y = [
    u,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: s
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: s
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        m
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: t.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: t.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        u,
        { begin: n }
      ],
      relevance: 0
    },
    h,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|(?!=)/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: s
    },
    {
      // regexp container
      begin: "(" + t.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            t.BACKSLASH_ESCAPE,
            d
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, c),
      relevance: 0
    }
  ].concat(l, c);
  d.contains = y, m.contains = y;
  const D = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: y
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: s,
        contains: y
      }
    }
  ];
  return c.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: s,
    illegal: /\/\*/,
    contains: [t.SHEBANG({ binary: "ruby" })].concat(D).concat(c).concat(y)
  };
}
function pO(t) {
  const e = t.regex, n = /(r#)?/, r = e.concat(n, t.UNDERSCORE_IDENT_RE), i = e.concat(n, t.IDENT_RE), o = {
    className: "title.function.invoke",
    relevance: 0,
    begin: e.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      i,
      e.lookahead(/\s*\(/)
    )
  }, s = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "union",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], l = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], c = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], d = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: t.IDENT_RE + "!?",
      type: d,
      keyword: a,
      literal: l,
      built_in: c
    },
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      t.inherit(t.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "symbol",
        // negative lookahead to avoid matching `'`
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
      },
      {
        scope: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          {
            begin: /b?'/,
            end: /'/,
            contains: [
              {
                scope: "char.escape",
                match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
              }
            ]
          }
        ]
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + s },
          { begin: "\\b0o([0-7_]+)" + s },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [
              t.BACKSLASH_ESCAPE
            ]
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          r
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          r,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: t.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: c,
          type: d
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      o
    ]
  };
}
const hO = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), gO = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], mO = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], CO = [
  ...gO,
  ...mO
], bO = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), yO = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), vO = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), wO = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function _O(t) {
  const e = hO(t), n = vO, r = yO, i = "@[a-z-]+", o = "and or not only", a = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      e.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + CO.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      a,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [e.CSS_NUMBER_MODE]
      },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + wO.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          a,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: o,
          attribute: bO.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          a,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  };
}
function EO(t) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function xO(t) {
  const e = t.regex, n = t.COMMENT("--", "$"), r = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ match: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ match: /""/ }]
  }, o = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], s = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], a = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], c = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], d = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], u = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], p = d, h = [
    ...c,
    ...l
  ].filter((x) => !d.includes(x)), m = {
    scope: "variable",
    match: /@[a-z0-9][a-z0-9_]*/
  }, g = {
    scope: "operator",
    match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, C = {
    match: e.concat(/\b/, e.either(...p), /\s*\(/),
    relevance: 0,
    keywords: { built_in: p }
  };
  function v(x) {
    return e.concat(
      /\b/,
      e.either(...x.map((y) => y.replace(/\s+/, "\\s+"))),
      /\b/
    );
  }
  const _ = {
    scope: "keyword",
    match: v(f),
    relevance: 0
  };
  function b(x, {
    exceptions: y,
    when: M
  } = {}) {
    const S = M;
    return y = y || [], x.map((T) => T.match(/\|\d+$/) || y.includes(T) ? T : S(T) ? `${T}|0` : T);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: b(h, { when: (x) => x.length < 3 }),
      literal: o,
      type: a,
      built_in: u
    },
    contains: [
      {
        scope: "type",
        match: v(s)
      },
      _,
      C,
      m,
      r,
      i,
      t.C_NUMBER_MODE,
      t.C_BLOCK_COMMENT_MODE,
      n,
      g
    ]
  };
}
function G2(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function to(t) {
  return Pe("(?=", t, ")");
}
function Pe(...t) {
  return t.map((n) => G2(n)).join("");
}
function kO(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function Ft(...t) {
  return "(" + (kO(t).capture ? "" : "?:") + t.map((r) => G2(r)).join("|") + ")";
}
const Pd = (t) => Pe(
  /\b/,
  t,
  /\w$/.test(t) ? /\b/ : /\B/
), SO = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(Pd), yh = [
  "init",
  "self"
].map(Pd), MO = [
  "Any",
  "Self"
], l1 = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "package",
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], vh = [
  "false",
  "nil",
  "true"
], OO = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], TO = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], wh = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], q2 = Ft(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), Q2 = Ft(
  q2,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), c1 = Pe(q2, Q2, "*"), Y2 = Ft(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Pa = Ft(
  Y2,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), Dn = Pe(Y2, Pa, "*"), Rs = Pe(/[A-Z]/, Pa, "*"), LO = [
  "attached",
  "autoclosure",
  Pe(/convention\(/, Ft("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  Pe(/objc\(/, Dn, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], NO = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function AO(t) {
  const e = {
    match: /\s+/,
    relevance: 0
  }, n = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    t.C_LINE_COMMENT_MODE,
    n
  ], i = {
    match: [
      /\./,
      Ft(...SO, ...yh)
    ],
    className: { 2: "keyword" }
  }, o = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: Pe(/\./, Ft(...l1)),
    relevance: 0
  }, s = l1.filter((ge) => typeof ge == "string").concat(["_|0"]), a = l1.filter((ge) => typeof ge != "string").concat(MO).map(Pd), l = { variants: [
    {
      className: "keyword",
      match: Ft(...a, ...yh)
    }
  ] }, c = {
    $pattern: Ft(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: s.concat(TO),
    literal: vh
  }, d = [
    i,
    o,
    l
  ], u = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: Pe(/\./, Ft(...wh)),
    relevance: 0
  }, f = {
    className: "built_in",
    match: Pe(/\b/, Ft(...wh), /(?=\()/)
  }, p = [
    u,
    f
  ], h = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, m = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: c1 },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${Q2})+`
      }
    ]
  }, g = [
    h,
    m
  ], C = "([0-9]_*)+", v = "([0-9a-fA-F]_*)+", _ = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${C})(\\.(${C}))?([eE][+-]?(${C}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${v})(\\.(${v}))?([pP][+-]?(${C}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, b = (ge = "") => ({
    className: "subst",
    variants: [
      { match: Pe(/\\/, ge, /[0\\tnr"']/) },
      { match: Pe(/\\/, ge, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), x = (ge = "") => ({
    className: "subst",
    match: Pe(/\\/, ge, /[\t ]*(?:[\r\n]|\r\n)/)
  }), y = (ge = "") => ({
    className: "subst",
    label: "interpol",
    begin: Pe(/\\/, ge, /\(/),
    end: /\)/
  }), M = (ge = "") => ({
    begin: Pe(ge, /"""/),
    end: Pe(/"""/, ge),
    contains: [
      b(ge),
      x(ge),
      y(ge)
    ]
  }), S = (ge = "") => ({
    begin: Pe(ge, /"/),
    end: Pe(/"/, ge),
    contains: [
      b(ge),
      y(ge)
    ]
  }), T = {
    className: "string",
    variants: [
      M(),
      M("#"),
      M("##"),
      M("###"),
      S(),
      S("#"),
      S("##"),
      S("###")
    ]
  }, D = [
    t.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [t.BACKSLASH_ESCAPE]
    }
  ], j = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: D
  }, V = (ge) => {
    const Wt = Pe(ge, /\//), Nt = Pe(/\//, ge);
    return {
      begin: Wt,
      end: Nt,
      contains: [
        ...D,
        {
          scope: "comment",
          begin: `#(?!.*${Nt})`,
          end: /$/
        }
      ]
    };
  }, X = {
    scope: "regexp",
    variants: [
      V("###"),
      V("##"),
      V("#"),
      j
    ]
  }, de = { match: Pe(/`/, Dn, /`/) }, ee = {
    className: "variable",
    match: /\$\d+/
  }, J = {
    className: "variable",
    match: `\\$${Pa}+`
  }, L = [
    de,
    ee,
    J
  ], I = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: NO,
        contains: [
          ...g,
          _,
          T
        ]
      }
    ] }
  }, G = {
    scope: "keyword",
    match: Pe(/@/, Ft(...LO), to(Ft(/\(/, /\s+/)))
  }, oe = {
    scope: "meta",
    match: Pe(/@/, Dn)
  }, me = [
    I,
    G,
    oe
  ], _e = {
    match: to(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: Pe(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Pa, "+")
      },
      {
        // Type identifier
        className: "type",
        match: Rs,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: Pe(/\s+&\s+/, to(Rs)),
        relevance: 0
      }
    ]
  }, ze = {
    begin: /</,
    end: />/,
    keywords: c,
    contains: [
      ...r,
      ...d,
      ...me,
      h,
      _e
    ]
  };
  _e.contains.push(ze);
  const pt = {
    match: Pe(Dn, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, Re = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: c,
    contains: [
      "self",
      pt,
      ...r,
      X,
      ...d,
      ...p,
      ...g,
      _,
      T,
      ...L,
      ...me,
      _e
    ]
  }, He = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      _e
    ]
  }, Jt = {
    begin: Ft(
      to(Pe(Dn, /\s*:/)),
      to(Pe(Dn, /\s+/, Dn, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: Dn
      }
    ]
  }, _t = {
    begin: /\(/,
    end: /\)/,
    keywords: c,
    contains: [
      Jt,
      ...r,
      ...d,
      ...g,
      _,
      T,
      ...me,
      _e,
      Re
    ],
    endsParent: !0,
    illegal: /["']/
  }, dn = {
    match: [
      /(func|macro)/,
      /\s+/,
      Ft(de.match, Dn, c1)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      He,
      _t,
      e
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, Et = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      He,
      _t,
      e
    ],
    illegal: /\[|%/
  }, un = {
    match: [
      /operator/,
      /\s+/,
      c1
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, An = {
    begin: [
      /precedencegroup/,
      /\s+/,
      Rs
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [_e],
    keywords: [
      ...OO,
      ...vh
    ],
    end: /}/
  }, En = {
    match: [
      /class\b/,
      /\s+/,
      /func\b/,
      /\s+/,
      /\b[A-Za-z_][A-Za-z0-9_]*\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword",
      5: "title.function"
    }
  }, Xt = {
    match: [
      /class\b/,
      /\s+/,
      /var\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword"
    }
  }, xn = {
    begin: [
      /(struct|protocol|class|extension|enum|actor)/,
      /\s+/,
      Dn,
      /\s*/
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    },
    keywords: c,
    contains: [
      He,
      ...d,
      {
        begin: /:/,
        end: /\{/,
        keywords: c,
        contains: [
          {
            scope: "title.class.inherited",
            match: Rs
          },
          ...d
        ],
        relevance: 0
      }
    ]
  };
  for (const ge of T.variants) {
    const Wt = ge.contains.find((ae) => ae.label === "interpol");
    Wt.keywords = c;
    const Nt = [
      ...d,
      ...p,
      ...g,
      _,
      T,
      ...L
    ];
    Wt.contains = [
      ...Nt,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...Nt
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...r,
      dn,
      Et,
      En,
      Xt,
      xn,
      un,
      An,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      X,
      ...d,
      ...p,
      ...g,
      _,
      T,
      ...L,
      ...me,
      _e,
      Re
    ]
  };
}
const Ba = "[A-Za-z$_][0-9A-Za-z$_]*", J2 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], X2 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], e4 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], t4 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], n4 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], r4 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], i4 = [].concat(
  n4,
  e4,
  t4
);
function RO(t) {
  const e = t.regex, n = (I, { after: G }) => {
    const oe = "</" + I[0].slice(1);
    return I.input.indexOf(oe, G) !== -1;
  }, r = Ba, i = {
    begin: "<>",
    end: "</>"
  }, o = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (I, G) => {
      const oe = I[0].length + I.index, me = I.input[oe];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        me === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        me === ","
      ) {
        G.ignoreMatch();
        return;
      }
      me === ">" && (n(I, { after: oe }) || G.ignoreMatch());
      let _e;
      const ze = I.input.substring(oe);
      if (_e = ze.match(/^\s*=/)) {
        G.ignoreMatch();
        return;
      }
      if ((_e = ze.match(/^\s+extends\s+/)) && _e.index === 0) {
        G.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: Ba,
    keyword: J2,
    literal: X2,
    built_in: i4,
    "variable.language": r4
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, d = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", u = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${d})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${d})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, v = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, _ = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    p,
    h,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    u
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = _.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(_)
  });
  const b = [].concat(v, f.contains), x = b.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(b)
    }
  ]), y = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: x
  }, M = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, S = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...e4,
        ...t4
      ]
    }
  }, T = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, D = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [y],
    illegal: /%/
  }, j = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function V(I) {
    return e.concat("(?!", I.join("|"), ")");
  }
  const X = {
    match: e.concat(
      /\b/,
      V([
        ...n4,
        "super",
        "import"
      ].map((I) => `${I}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, de = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, ee = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      y
    ]
  }, J = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", L = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(J)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      y
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: S },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      T,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      p,
      h,
      m,
      g,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      u,
      S,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      L,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: J,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: o },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      D,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          y,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      de,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [y]
      },
      X,
      j,
      M,
      ee,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function IO(t) {
  const e = t.regex, n = RO(t), r = Ba, i = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], o = {
    begin: [
      /namespace/,
      /\s+/,
      t.IDENT_RE
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    }
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: i
    },
    contains: [n.exports.CLASS_REFERENCE]
  }, a = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, l = [
    "type",
    // "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override",
    "satisfies"
  ], c = {
    $pattern: Ba,
    keyword: J2.concat(l),
    literal: X2,
    built_in: i4.concat(i),
    "variable.language": r4
  }, d = {
    className: "meta",
    begin: "@" + r
  }, u = (m, g, C) => {
    const v = m.contains.findIndex((_) => _.label === g);
    if (v === -1)
      throw new Error("can not find mode to replace");
    m.contains.splice(v, 1, C);
  };
  Object.assign(n.keywords, c), n.exports.PARAMS_CONTAINS.push(d);
  const f = n.contains.find((m) => m.scope === "attr"), p = Object.assign(
    {},
    f,
    { match: e.concat(r, e.lookahead(/\s*\?:/)) }
  );
  n.exports.PARAMS_CONTAINS.push([
    n.exports.CLASS_REFERENCE,
    // class reference for highlighting the params types
    f,
    // highlight the params key
    p
    // Added for optional property assignment highlighting
  ]), n.contains = n.contains.concat([
    d,
    o,
    s,
    p
    // Added for optional property assignment highlighting
  ]), u(n, "shebang", t.SHEBANG()), u(n, "use_strict", a);
  const h = n.contains.find((m) => m.label === "func.def");
  return h.relevance = 0, Object.assign(n, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), n;
}
function DO(t) {
  const e = t.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, o = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: e.concat(/# */, e.either(o, i), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: e.concat(/# */, a, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: e.concat(/# */, s, / *#/)
      },
      {
        // date plus time
        begin: e.concat(
          /# */,
          e.either(o, i),
          / +/,
          e.either(s, a),
          / *#/
        )
      }
    ]
  }, c = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, d = {
    className: "label",
    begin: /^\w+:/
  }, u = t.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), f = t.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      l,
      c,
      d,
      u,
      f,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [f]
      }
    ]
  };
}
function PO(t) {
  t.regex;
  const e = t.COMMENT(/\(;/, /;\)/);
  e.contains.push("self");
  const n = t.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], i = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, o = {
    className: "variable",
    begin: /\$[\w_]+/
  }, s = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, a = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, c = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      n,
      e,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      o,
      s,
      i,
      t.QUOTE_STRING_MODE,
      l,
      c,
      a
    ]
  };
}
function BO(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, o = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, s = t.inherit(o, {
    begin: /\(/,
    end: /\)/
  }), a = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          o,
          l,
          a,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  o,
                  s,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function $O(t) {
  const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      // added brackets support and special char support
      { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
      {
        // double quoted keys - with brackets and special char support
        begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
      },
      {
        // single quoted keys - with brackets and special char support
        begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, o = {
    className: "string",
    relevance: 0,
    begin: /'/,
    end: /'/,
    contains: [
      {
        match: /''/,
        scope: "char.escape",
        relevance: 0
      }
    ]
  }, s = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      t.BACKSLASH_ESCAPE,
      i
    ]
  }, a = t.inherit(s, { variants: [
    {
      begin: /'/,
      end: /'/,
      contains: [
        {
          begin: /''/,
          relevance: 0
        }
      ]
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), f = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, p = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, h = {
    begin: /\{/,
    end: /\}/,
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, m = {
    begin: "\\[",
    end: "\\]",
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, g = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    t.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    f,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: t.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    h,
    m,
    o,
    s
  ], C = [...g];
  return C.pop(), C.push(a), p.contains = C, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: g
  };
}
const zO = {
  arduino: vM,
  bash: wM,
  c: _M,
  cpp: EM,
  csharp: xM,
  css: RM,
  diff: IM,
  go: DM,
  graphql: PM,
  ini: BM,
  java: $M,
  javascript: VM,
  json: jM,
  kotlin: ZM,
  less: eO,
  lua: tO,
  makefile: nO,
  markdown: rO,
  objectivec: iO,
  perl: oO,
  php: sO,
  "php-template": aO,
  plaintext: lO,
  python: cO,
  "python-repl": dO,
  r: uO,
  ruby: fO,
  rust: pO,
  scss: _O,
  shell: EO,
  sql: xO,
  swift: AO,
  typescript: IO,
  vbnet: DO,
  wasm: PO,
  xml: BO,
  yaml: $O
};
var d1, _h;
function HO() {
  if (_h) return d1;
  _h = 1;
  function t(w) {
    return w instanceof Map ? w.clear = w.delete = w.set = function() {
      throw new Error("map is read-only");
    } : w instanceof Set && (w.add = w.clear = w.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(w), Object.getOwnPropertyNames(w).forEach((N) => {
      const H = w[N], fe = typeof H;
      (fe === "object" || fe === "function") && !Object.isFrozen(H) && t(H);
    }), w;
  }
  class e {
    /**
     * @param {CompiledMode} mode
     */
    constructor(N) {
      N.data === void 0 && (N.data = {}), this.data = N.data, this.isMatchIgnored = !1;
    }
    ignoreMatch() {
      this.isMatchIgnored = !0;
    }
  }
  function n(w) {
    return w.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function r(w, ...N) {
    const H = /* @__PURE__ */ Object.create(null);
    for (const fe in w)
      H[fe] = w[fe];
    return N.forEach(function(fe) {
      for (const We in fe)
        H[We] = fe[We];
    }), /** @type {T} */
    H;
  }
  const i = "</span>", o = (w) => !!w.scope, s = (w, { prefix: N }) => {
    if (w.startsWith("language:"))
      return w.replace("language:", "language-");
    if (w.includes(".")) {
      const H = w.split(".");
      return [
        `${N}${H.shift()}`,
        ...H.map((fe, We) => `${fe}${"_".repeat(We + 1)}`)
      ].join(" ");
    }
    return `${N}${w}`;
  };
  class a {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor(N, H) {
      this.buffer = "", this.classPrefix = H.classPrefix, N.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText(N) {
      this.buffer += n(N);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode(N) {
      if (!o(N)) return;
      const H = s(
        N.scope,
        { prefix: this.classPrefix }
      );
      this.span(H);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode(N) {
      o(N) && (this.buffer += i);
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span(N) {
      this.buffer += `<span class="${N}">`;
    }
  }
  const l = (w = {}) => {
    const N = { children: [] };
    return Object.assign(N, w), N;
  };
  class c {
    constructor() {
      this.rootNode = l(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add(N) {
      this.top.children.push(N);
    }
    /** @param {string} scope */
    openNode(N) {
      const H = l({ scope: N });
      this.add(H), this.stack.push(H);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); ) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk(N) {
      return this.constructor._walk(N, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk(N, H) {
      return typeof H == "string" ? N.addText(H) : H.children && (N.openNode(H), H.children.forEach((fe) => this._walk(N, fe)), N.closeNode(H)), N;
    }
    /**
     * @param {Node} node
     */
    static _collapse(N) {
      typeof N != "string" && N.children && (N.children.every((H) => typeof H == "string") ? N.children = [N.children.join("")] : N.children.forEach((H) => {
        c._collapse(H);
      }));
    }
  }
  class d extends c {
    /**
     * @param {*} options
     */
    constructor(N) {
      super(), this.options = N;
    }
    /**
     * @param {string} text
     */
    addText(N) {
      N !== "" && this.add(N);
    }
    /** @param {string} scope */
    startScope(N) {
      this.openNode(N);
    }
    endScope() {
      this.closeNode();
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    __addSublanguage(N, H) {
      const fe = N.root;
      H && (fe.scope = `language:${H}`), this.add(fe);
    }
    toHTML() {
      return new a(this, this.options).value();
    }
    finalize() {
      return this.closeAllNodes(), !0;
    }
  }
  function u(w) {
    return w ? typeof w == "string" ? w : w.source : null;
  }
  function f(w) {
    return m("(?=", w, ")");
  }
  function p(w) {
    return m("(?:", w, ")*");
  }
  function h(w) {
    return m("(?:", w, ")?");
  }
  function m(...w) {
    return w.map((H) => u(H)).join("");
  }
  function g(w) {
    const N = w[w.length - 1];
    return typeof N == "object" && N.constructor === Object ? (w.splice(w.length - 1, 1), N) : {};
  }
  function C(...w) {
    return "(" + (g(w).capture ? "" : "?:") + w.map((fe) => u(fe)).join("|") + ")";
  }
  function v(w) {
    return new RegExp(w.toString() + "|").exec("").length - 1;
  }
  function _(w, N) {
    const H = w && w.exec(N);
    return H && H.index === 0;
  }
  const b = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function x(w, { joinWith: N }) {
    let H = 0;
    return w.map((fe) => {
      H += 1;
      const We = H;
      let Fe = u(fe), Y = "";
      for (; Fe.length > 0; ) {
        const K = b.exec(Fe);
        if (!K) {
          Y += Fe;
          break;
        }
        Y += Fe.substring(0, K.index), Fe = Fe.substring(K.index + K[0].length), K[0][0] === "\\" && K[1] ? Y += "\\" + String(Number(K[1]) + We) : (Y += K[0], K[0] === "(" && H++);
      }
      return Y;
    }).map((fe) => `(${fe})`).join(N);
  }
  const y = /\b\B/, M = "[a-zA-Z]\\w*", S = "[a-zA-Z_]\\w*", T = "\\b\\d+(\\.\\d+)?", D = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", j = "\\b(0b[01]+)", V = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", X = (w = {}) => {
    const N = /^#![ ]*\//;
    return w.binary && (w.begin = m(
      N,
      /.*\b/,
      w.binary,
      /\b.*/
    )), r({
      scope: "meta",
      begin: N,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (H, fe) => {
        H.index !== 0 && fe.ignoreMatch();
      }
    }, w);
  }, de = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  }, ee = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [de]
  }, J = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [de]
  }, L = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }, I = function(w, N, H = {}) {
    const fe = r(
      {
        scope: "comment",
        begin: w,
        end: N,
        contains: []
      },
      H
    );
    fe.contains.push({
      scope: "doctag",
      // hack to avoid the space from being included. the space is necessary to
      // match here to prevent the plain text rule below from gobbling up doctags
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    });
    const We = C(
      // list of common 1 and 2 letter words in English
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      // note: this is not an exhaustive list of contractions, just popular ones
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      // contractions - can't we'd they're let's, etc
      /[A-Za-z]+[-][a-z]+/,
      // `no-way`, etc.
      /[A-Za-z][a-z]{2,}/
      // allow capitalized words at beginning of sentences
    );
    return fe.contains.push(
      {
        // TODO: how to include ", (, ) without breaking grammars that use these for
        // comment delimiters?
        // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
        // ---
        // this tries to find sequences of 3 english words in a row (without any
        // "programming" type syntax) this gives us a strong signal that we've
        // TRULY found a comment - vs perhaps scanning with the wrong language.
        // It's possible to find something that LOOKS like the start of the
        // comment - but then if there is no readable text - good chance it is a
        // false match and not a comment.
        //
        // for a visual example please see:
        // https://github.com/highlightjs/highlight.js/issues/2827
        begin: m(
          /[ ]+/,
          // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
          "(",
          We,
          /[.]?[:]?([.][ ]|[ ])/,
          "){3}"
        )
        // look for 3 words in a row
      }
    ), fe;
  }, G = I("//", "$"), oe = I("/\\*", "\\*/"), me = I("#", "$"), _e = {
    scope: "number",
    begin: T,
    relevance: 0
  }, ze = {
    scope: "number",
    begin: D,
    relevance: 0
  }, pt = {
    scope: "number",
    begin: j,
    relevance: 0
  }, Re = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [
      de,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [de]
      }
    ]
  }, He = {
    scope: "title",
    begin: M,
    relevance: 0
  }, Jt = {
    scope: "title",
    begin: S,
    relevance: 0
  }, _t = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + S,
    relevance: 0
  };
  var Et = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    APOS_STRING_MODE: ee,
    BACKSLASH_ESCAPE: de,
    BINARY_NUMBER_MODE: pt,
    BINARY_NUMBER_RE: j,
    COMMENT: I,
    C_BLOCK_COMMENT_MODE: oe,
    C_LINE_COMMENT_MODE: G,
    C_NUMBER_MODE: ze,
    C_NUMBER_RE: D,
    END_SAME_AS_BEGIN: function(w) {
      return Object.assign(
        w,
        {
          /** @type {ModeCallback} */
          "on:begin": (N, H) => {
            H.data._beginMatch = N[1];
          },
          /** @type {ModeCallback} */
          "on:end": (N, H) => {
            H.data._beginMatch !== N[1] && H.ignoreMatch();
          }
        }
      );
    },
    HASH_COMMENT_MODE: me,
    IDENT_RE: M,
    MATCH_NOTHING_RE: y,
    METHOD_GUARD: _t,
    NUMBER_MODE: _e,
    NUMBER_RE: T,
    PHRASAL_WORDS_MODE: L,
    QUOTE_STRING_MODE: J,
    REGEXP_MODE: Re,
    RE_STARTERS_RE: V,
    SHEBANG: X,
    TITLE_MODE: He,
    UNDERSCORE_IDENT_RE: S,
    UNDERSCORE_TITLE_MODE: Jt
  });
  function un(w, N) {
    w.input[w.index - 1] === "." && N.ignoreMatch();
  }
  function An(w, N) {
    w.className !== void 0 && (w.scope = w.className, delete w.className);
  }
  function En(w, N) {
    N && w.beginKeywords && (w.begin = "\\b(" + w.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", w.__beforeBegin = un, w.keywords = w.keywords || w.beginKeywords, delete w.beginKeywords, w.relevance === void 0 && (w.relevance = 0));
  }
  function Xt(w, N) {
    Array.isArray(w.illegal) && (w.illegal = C(...w.illegal));
  }
  function xn(w, N) {
    if (w.match) {
      if (w.begin || w.end) throw new Error("begin & end are not supported with match");
      w.begin = w.match, delete w.match;
    }
  }
  function ge(w, N) {
    w.relevance === void 0 && (w.relevance = 1);
  }
  const Wt = (w, N) => {
    if (!w.beforeMatch) return;
    if (w.starts) throw new Error("beforeMatch cannot be used with starts");
    const H = Object.assign({}, w);
    Object.keys(w).forEach((fe) => {
      delete w[fe];
    }), w.keywords = H.keywords, w.begin = m(H.beforeMatch, f(H.begin)), w.starts = {
      relevance: 0,
      contains: [
        Object.assign(H, { endsParent: !0 })
      ]
    }, w.relevance = 0, delete H.beforeMatch;
  }, Nt = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ], ae = "keyword";
  function Bt(w, N, H = ae) {
    const fe = /* @__PURE__ */ Object.create(null);
    return typeof w == "string" ? We(H, w.split(" ")) : Array.isArray(w) ? We(H, w) : Object.keys(w).forEach(function(Fe) {
      Object.assign(
        fe,
        Bt(w[Fe], N, Fe)
      );
    }), fe;
    function We(Fe, Y) {
      N && (Y = Y.map((K) => K.toLowerCase())), Y.forEach(function(K) {
        const pe = K.split("|");
        fe[pe[0]] = [Fe, De(pe[0], pe[1])];
      });
    }
  }
  function De(w, N) {
    return N ? Number(N) : Te(w) ? 0 : 1;
  }
  function Te(w) {
    return Nt.includes(w.toLowerCase());
  }
  const $t = {}, rt = (w) => {
    console.error(w);
  }, kn = (w, ...N) => {
    console.log(`WARN: ${w}`, ...N);
  }, zt = (w, N) => {
    $t[`${w}/${N}`] || (console.log(`Deprecated as of ${w}. ${N}`), $t[`${w}/${N}`] = !0);
  }, z = new Error();
  function Z(w, N, { key: H }) {
    let fe = 0;
    const We = w[H], Fe = {}, Y = {};
    for (let K = 1; K <= N.length; K++)
      Y[K + fe] = We[K], Fe[K + fe] = !0, fe += v(N[K - 1]);
    w[H] = Y, w[H]._emit = Fe, w[H]._multi = !0;
  }
  function Ce(w) {
    if (Array.isArray(w.begin)) {
      if (w.skip || w.excludeBegin || w.returnBegin)
        throw rt("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), z;
      if (typeof w.beginScope != "object" || w.beginScope === null)
        throw rt("beginScope must be object"), z;
      Z(w, w.begin, { key: "beginScope" }), w.begin = x(w.begin, { joinWith: "" });
    }
  }
  function Le(w) {
    if (Array.isArray(w.end)) {
      if (w.skip || w.excludeEnd || w.returnEnd)
        throw rt("skip, excludeEnd, returnEnd not compatible with endScope: {}"), z;
      if (typeof w.endScope != "object" || w.endScope === null)
        throw rt("endScope must be object"), z;
      Z(w, w.end, { key: "endScope" }), w.end = x(w.end, { joinWith: "" });
    }
  }
  function ot(w) {
    w.scope && typeof w.scope == "object" && w.scope !== null && (w.beginScope = w.scope, delete w.scope);
  }
  function en(w) {
    ot(w), typeof w.beginScope == "string" && (w.beginScope = { _wrap: w.beginScope }), typeof w.endScope == "string" && (w.endScope = { _wrap: w.endScope }), Ce(w), Le(w);
  }
  function Ki(w) {
    function N(Y, K) {
      return new RegExp(
        u(Y),
        "m" + (w.case_insensitive ? "i" : "") + (w.unicodeRegex ? "u" : "") + (K ? "g" : "")
      );
    }
    class H {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      // @ts-ignore
      addRule(K, pe) {
        pe.position = this.position++, this.matchIndexes[this.matchAt] = pe, this.regexes.push([pe, K]), this.matchAt += v(K) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        const K = this.regexes.map((pe) => pe[1]);
        this.matcherRe = N(x(K, { joinWith: "|" }), !0), this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(K) {
        this.matcherRe.lastIndex = this.lastIndex;
        const pe = this.matcherRe.exec(K);
        if (!pe)
          return null;
        const gt = pe.findIndex((qi, cl) => cl > 0 && qi !== void 0), st = this.matchIndexes[gt];
        return pe.splice(0, gt), Object.assign(pe, st);
      }
    }
    class fe {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(K) {
        if (this.multiRegexes[K]) return this.multiRegexes[K];
        const pe = new H();
        return this.rules.slice(K).forEach(([gt, st]) => pe.addRule(gt, st)), pe.compile(), this.multiRegexes[K] = pe, pe;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(K, pe) {
        this.rules.push([K, pe]), pe.type === "begin" && this.count++;
      }
      /** @param {string} s */
      exec(K) {
        const pe = this.getMatcher(this.regexIndex);
        pe.lastIndex = this.lastIndex;
        let gt = pe.exec(K);
        if (this.resumingScanAtSamePosition() && !(gt && gt.index === this.lastIndex)) {
          const st = this.getMatcher(0);
          st.lastIndex = this.lastIndex + 1, gt = st.exec(K);
        }
        return gt && (this.regexIndex += gt.position + 1, this.regexIndex === this.count && this.considerAll()), gt;
      }
    }
    function We(Y) {
      const K = new fe();
      return Y.contains.forEach((pe) => K.addRule(pe.begin, { rule: pe, type: "begin" })), Y.terminatorEnd && K.addRule(Y.terminatorEnd, { type: "end" }), Y.illegal && K.addRule(Y.illegal, { type: "illegal" }), K;
    }
    function Fe(Y, K) {
      const pe = (
        /** @type CompiledMode */
        Y
      );
      if (Y.isCompiled) return pe;
      [
        An,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        xn,
        en,
        Wt
      ].forEach((st) => st(Y, K)), w.compilerExtensions.forEach((st) => st(Y, K)), Y.__beforeBegin = null, [
        En,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        Xt,
        // default to 1 relevance if not specified
        ge
      ].forEach((st) => st(Y, K)), Y.isCompiled = !0;
      let gt = null;
      return typeof Y.keywords == "object" && Y.keywords.$pattern && (Y.keywords = Object.assign({}, Y.keywords), gt = Y.keywords.$pattern, delete Y.keywords.$pattern), gt = gt || /\w+/, Y.keywords && (Y.keywords = Bt(Y.keywords, w.case_insensitive)), pe.keywordPatternRe = N(gt, !0), K && (Y.begin || (Y.begin = /\B|\b/), pe.beginRe = N(pe.begin), !Y.end && !Y.endsWithParent && (Y.end = /\B|\b/), Y.end && (pe.endRe = N(pe.end)), pe.terminatorEnd = u(pe.end) || "", Y.endsWithParent && K.terminatorEnd && (pe.terminatorEnd += (Y.end ? "|" : "") + K.terminatorEnd)), Y.illegal && (pe.illegalRe = N(
        /** @type {RegExp | string} */
        Y.illegal
      )), Y.contains || (Y.contains = []), Y.contains = [].concat(...Y.contains.map(function(st) {
        return Q(st === "self" ? Y : st);
      })), Y.contains.forEach(function(st) {
        Fe(
          /** @type Mode */
          st,
          pe
        );
      }), Y.starts && Fe(Y.starts, K), pe.matcher = We(pe), pe;
    }
    if (w.compilerExtensions || (w.compilerExtensions = []), w.contains && w.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return w.classNameAliases = r(w.classNameAliases || {}), Fe(
      /** @type Mode */
      w
    );
  }
  function O(w) {
    return w ? w.endsWithParent || O(w.starts) : !1;
  }
  function Q(w) {
    return w.variants && !w.cachedVariants && (w.cachedVariants = w.variants.map(function(N) {
      return r(w, { variants: null }, N);
    })), w.cachedVariants ? w.cachedVariants : O(w) ? r(w, { starts: w.starts ? r(w.starts) : null }) : Object.isFrozen(w) ? r(w) : w;
  }
  var ue = "11.11.1";
  class Ne extends Error {
    constructor(N, H) {
      super(N), this.name = "HTMLInjectionError", this.html = H;
    }
  }
  const Se = n, ht = r, Ht = Symbol("nomatch"), cr = 7, Gi = function(w) {
    const N = /* @__PURE__ */ Object.create(null), H = /* @__PURE__ */ Object.create(null), fe = [];
    let We = !0;
    const Fe = "Could not find the language '{}', did you forget to load/include a language module?", Y = { disableAutodetect: !0, name: "Plain text", contains: [] };
    let K = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: d
    };
    function pe($) {
      return K.noHighlightRe.test($);
    }
    function gt($) {
      let re = $.className + " ";
      re += $.parentNode ? $.parentNode.className : "";
      const Me = K.languageDetectRe.exec(re);
      if (Me) {
        const Ue = dr(Me[1]);
        return Ue || (kn(Fe.replace("{}", Me[1])), kn("Falling back to no-highlight mode for this block.", $)), Ue ? Me[1] : "no-highlight";
      }
      return re.split(/\s+/).find((Ue) => pe(Ue) || dr(Ue));
    }
    function st($, re, Me) {
      let Ue = "", ut = "";
      typeof re == "object" ? (Ue = $, Me = re.ignoreIllegals, ut = re.language) : (zt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), zt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ut = $, Ue = re), Me === void 0 && (Me = !0);
      const Sn = {
        code: Ue,
        language: ut
      };
      es("before:highlight", Sn);
      const ur = Sn.result ? Sn.result : qi(Sn.language, Sn.code, Me);
      return ur.code = Sn.code, es("after:highlight", ur), ur;
    }
    function qi($, re, Me, Ue) {
      const ut = /* @__PURE__ */ Object.create(null);
      function Sn(W, te) {
        return W.keywords[te];
      }
      function ur() {
        if (!be.keywords) {
          xt.addText(Ve);
          return;
        }
        let W = 0;
        be.keywordPatternRe.lastIndex = 0;
        let te = be.keywordPatternRe.exec(Ve), ke = "";
        for (; te; ) {
          ke += Ve.substring(W, te.index);
          const Ie = In.case_insensitive ? te[0].toLowerCase() : te[0], At = Sn(be, Ie);
          if (At) {
            const [Zn, w4] = At;
            if (xt.addText(ke), ke = "", ut[Ie] = (ut[Ie] || 0) + 1, ut[Ie] <= cr && (rs += w4), Zn.startsWith("_"))
              ke += te[0];
            else {
              const _4 = In.classNameAliases[Zn] || Zn;
              Rn(te[0], _4);
            }
          } else
            ke += te[0];
          W = be.keywordPatternRe.lastIndex, te = be.keywordPatternRe.exec(Ve);
        }
        ke += Ve.substring(W), xt.addText(ke);
      }
      function ts() {
        if (Ve === "") return;
        let W = null;
        if (typeof be.subLanguage == "string") {
          if (!N[be.subLanguage]) {
            xt.addText(Ve);
            return;
          }
          W = qi(be.subLanguage, Ve, !0, jd[be.subLanguage]), jd[be.subLanguage] = /** @type {CompiledMode} */
          W._top;
        } else
          W = dl(Ve, be.subLanguage.length ? be.subLanguage : null);
        be.relevance > 0 && (rs += W.relevance), xt.__addSublanguage(W._emitter, W.language);
      }
      function tn() {
        be.subLanguage != null ? ts() : ur(), Ve = "";
      }
      function Rn(W, te) {
        W !== "" && (xt.startScope(te), xt.addText(W), xt.endScope());
      }
      function Hd(W, te) {
        let ke = 1;
        const Ie = te.length - 1;
        for (; ke <= Ie; ) {
          if (!W._emit[ke]) {
            ke++;
            continue;
          }
          const At = In.classNameAliases[W[ke]] || W[ke], Zn = te[ke];
          At ? Rn(Zn, At) : (Ve = Zn, ur(), Ve = ""), ke++;
        }
      }
      function Fd(W, te) {
        return W.scope && typeof W.scope == "string" && xt.openNode(In.classNameAliases[W.scope] || W.scope), W.beginScope && (W.beginScope._wrap ? (Rn(Ve, In.classNameAliases[W.beginScope._wrap] || W.beginScope._wrap), Ve = "") : W.beginScope._multi && (Hd(W.beginScope, te), Ve = "")), be = Object.create(W, { parent: { value: be } }), be;
      }
      function Ud(W, te, ke) {
        let Ie = _(W.endRe, ke);
        if (Ie) {
          if (W["on:end"]) {
            const At = new e(W);
            W["on:end"](te, At), At.isMatchIgnored && (Ie = !1);
          }
          if (Ie) {
            for (; W.endsParent && W.parent; )
              W = W.parent;
            return W;
          }
        }
        if (W.endsWithParent)
          return Ud(W.parent, te, ke);
      }
      function m4(W) {
        return be.matcher.regexIndex === 0 ? (Ve += W[0], 1) : (hl = !0, 0);
      }
      function C4(W) {
        const te = W[0], ke = W.rule, Ie = new e(ke), At = [ke.__beforeBegin, ke["on:begin"]];
        for (const Zn of At)
          if (Zn && (Zn(W, Ie), Ie.isMatchIgnored))
            return m4(te);
        return ke.skip ? Ve += te : (ke.excludeBegin && (Ve += te), tn(), !ke.returnBegin && !ke.excludeBegin && (Ve = te)), Fd(ke, W), ke.returnBegin ? 0 : te.length;
      }
      function b4(W) {
        const te = W[0], ke = re.substring(W.index), Ie = Ud(be, W, ke);
        if (!Ie)
          return Ht;
        const At = be;
        be.endScope && be.endScope._wrap ? (tn(), Rn(te, be.endScope._wrap)) : be.endScope && be.endScope._multi ? (tn(), Hd(be.endScope, W)) : At.skip ? Ve += te : (At.returnEnd || At.excludeEnd || (Ve += te), tn(), At.excludeEnd && (Ve = te));
        do
          be.scope && xt.closeNode(), !be.skip && !be.subLanguage && (rs += be.relevance), be = be.parent;
        while (be !== Ie.parent);
        return Ie.starts && Fd(Ie.starts, W), At.returnEnd ? 0 : te.length;
      }
      function y4() {
        const W = [];
        for (let te = be; te !== In; te = te.parent)
          te.scope && W.unshift(te.scope);
        W.forEach((te) => xt.openNode(te));
      }
      let ns = {};
      function Vd(W, te) {
        const ke = te && te[0];
        if (Ve += W, ke == null)
          return tn(), 0;
        if (ns.type === "begin" && te.type === "end" && ns.index === te.index && ke === "") {
          if (Ve += re.slice(te.index, te.index + 1), !We) {
            const Ie = new Error(`0 width match regex (${$})`);
            throw Ie.languageName = $, Ie.badRule = ns.rule, Ie;
          }
          return 1;
        }
        if (ns = te, te.type === "begin")
          return C4(te);
        if (te.type === "illegal" && !Me) {
          const Ie = new Error('Illegal lexeme "' + ke + '" for mode "' + (be.scope || "<unnamed>") + '"');
          throw Ie.mode = be, Ie;
        } else if (te.type === "end") {
          const Ie = b4(te);
          if (Ie !== Ht)
            return Ie;
        }
        if (te.type === "illegal" && ke === "")
          return Ve += `
`, 1;
        if (pl > 1e5 && pl > te.index * 3)
          throw new Error("potential infinite loop, way more iterations than matches");
        return Ve += ke, ke.length;
      }
      const In = dr($);
      if (!In)
        throw rt(Fe.replace("{}", $)), new Error('Unknown language: "' + $ + '"');
      const v4 = Ki(In);
      let fl = "", be = Ue || v4;
      const jd = {}, xt = new K.__emitter(K);
      y4();
      let Ve = "", rs = 0, Fr = 0, pl = 0, hl = !1;
      try {
        if (In.__emitTokens)
          In.__emitTokens(re, xt);
        else {
          for (be.matcher.considerAll(); ; ) {
            pl++, hl ? hl = !1 : be.matcher.considerAll(), be.matcher.lastIndex = Fr;
            const W = be.matcher.exec(re);
            if (!W) break;
            const te = re.substring(Fr, W.index), ke = Vd(te, W);
            Fr = W.index + ke;
          }
          Vd(re.substring(Fr));
        }
        return xt.finalize(), fl = xt.toHTML(), {
          language: $,
          value: fl,
          relevance: rs,
          illegal: !1,
          _emitter: xt,
          _top: be
        };
      } catch (W) {
        if (W.message && W.message.includes("Illegal"))
          return {
            language: $,
            value: Se(re),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: W.message,
              index: Fr,
              context: re.slice(Fr - 100, Fr + 100),
              mode: W.mode,
              resultSoFar: fl
            },
            _emitter: xt
          };
        if (We)
          return {
            language: $,
            value: Se(re),
            illegal: !1,
            relevance: 0,
            errorRaised: W,
            _emitter: xt,
            _top: be
          };
        throw W;
      }
    }
    function cl($) {
      const re = {
        value: Se($),
        illegal: !1,
        relevance: 0,
        _top: Y,
        _emitter: new K.__emitter(K)
      };
      return re._emitter.addText($), re;
    }
    function dl($, re) {
      re = re || K.languages || Object.keys(N);
      const Me = cl($), Ue = re.filter(dr).filter(zd).map(
        (tn) => qi(tn, $, !1)
      );
      Ue.unshift(Me);
      const ut = Ue.sort((tn, Rn) => {
        if (tn.relevance !== Rn.relevance) return Rn.relevance - tn.relevance;
        if (tn.language && Rn.language) {
          if (dr(tn.language).supersetOf === Rn.language)
            return 1;
          if (dr(Rn.language).supersetOf === tn.language)
            return -1;
        }
        return 0;
      }), [Sn, ur] = ut, ts = Sn;
      return ts.secondBest = ur, ts;
    }
    function o4($, re, Me) {
      const Ue = re && H[re] || Me;
      $.classList.add("hljs"), $.classList.add(`language-${Ue}`);
    }
    function ul($) {
      let re = null;
      const Me = gt($);
      if (pe(Me)) return;
      if (es(
        "before:highlightElement",
        { el: $, language: Me }
      ), $.dataset.highlighted) {
        console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", $);
        return;
      }
      if ($.children.length > 0 && (K.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn($)), K.throwUnescapedHTML))
        throw new Ne(
          "One of your code blocks includes unescaped HTML.",
          $.innerHTML
        );
      re = $;
      const Ue = re.textContent, ut = Me ? st(Ue, { language: Me, ignoreIllegals: !0 }) : dl(Ue);
      $.innerHTML = ut.value, $.dataset.highlighted = "yes", o4($, Me, ut.language), $.result = {
        language: ut.language,
        // TODO: remove with version 11.0
        re: ut.relevance,
        relevance: ut.relevance
      }, ut.secondBest && ($.secondBest = {
        language: ut.secondBest.language,
        relevance: ut.secondBest.relevance
      }), es("after:highlightElement", { el: $, result: ut, text: Ue });
    }
    function s4($) {
      K = ht(K, $);
    }
    const a4 = () => {
      Xo(), zt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function l4() {
      Xo(), zt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let Bd = !1;
    function Xo() {
      function $() {
        Xo();
      }
      if (document.readyState === "loading") {
        Bd || window.addEventListener("DOMContentLoaded", $, !1), Bd = !0;
        return;
      }
      document.querySelectorAll(K.cssSelector).forEach(ul);
    }
    function c4($, re) {
      let Me = null;
      try {
        Me = re(w);
      } catch (Ue) {
        if (rt("Language definition for '{}' could not be registered.".replace("{}", $)), We)
          rt(Ue);
        else
          throw Ue;
        Me = Y;
      }
      Me.name || (Me.name = $), N[$] = Me, Me.rawDefinition = re.bind(null, w), Me.aliases && $d(Me.aliases, { languageName: $ });
    }
    function d4($) {
      delete N[$];
      for (const re of Object.keys(H))
        H[re] === $ && delete H[re];
    }
    function u4() {
      return Object.keys(N);
    }
    function dr($) {
      return $ = ($ || "").toLowerCase(), N[$] || N[H[$]];
    }
    function $d($, { languageName: re }) {
      typeof $ == "string" && ($ = [$]), $.forEach((Me) => {
        H[Me.toLowerCase()] = re;
      });
    }
    function zd($) {
      const re = dr($);
      return re && !re.disableAutodetect;
    }
    function f4($) {
      $["before:highlightBlock"] && !$["before:highlightElement"] && ($["before:highlightElement"] = (re) => {
        $["before:highlightBlock"](
          Object.assign({ block: re.el }, re)
        );
      }), $["after:highlightBlock"] && !$["after:highlightElement"] && ($["after:highlightElement"] = (re) => {
        $["after:highlightBlock"](
          Object.assign({ block: re.el }, re)
        );
      });
    }
    function p4($) {
      f4($), fe.push($);
    }
    function h4($) {
      const re = fe.indexOf($);
      re !== -1 && fe.splice(re, 1);
    }
    function es($, re) {
      const Me = $;
      fe.forEach(function(Ue) {
        Ue[Me] && Ue[Me](re);
      });
    }
    function g4($) {
      return zt("10.7.0", "highlightBlock will be removed entirely in v12.0"), zt("10.7.0", "Please use highlightElement now."), ul($);
    }
    Object.assign(w, {
      highlight: st,
      highlightAuto: dl,
      highlightAll: Xo,
      highlightElement: ul,
      // TODO: Remove with v12 API
      highlightBlock: g4,
      configure: s4,
      initHighlighting: a4,
      initHighlightingOnLoad: l4,
      registerLanguage: c4,
      unregisterLanguage: d4,
      listLanguages: u4,
      getLanguage: dr,
      registerAliases: $d,
      autoDetection: zd,
      inherit: ht,
      addPlugin: p4,
      removePlugin: h4
    }), w.debugMode = function() {
      We = !1;
    }, w.safeMode = function() {
      We = !0;
    }, w.versionString = ue, w.regex = {
      concat: m,
      lookahead: f,
      either: C,
      optional: h,
      anyNumberOfTimes: p
    };
    for (const $ in Et)
      typeof Et[$] == "object" && t(Et[$]);
    return Object.assign(w, Et), w;
  }, Zt = Gi({});
  return Zt.newInstance = () => Gi({}), d1 = Zt, Zt.HighlightJS = Zt, Zt.default = Zt, d1;
}
var FO = /* @__PURE__ */ HO();
const UO = /* @__PURE__ */ p_(FO), Eh = {}, VO = "hljs-";
function jO(t) {
  const e = UO.newInstance();
  return t && o(t), {
    highlight: n,
    highlightAuto: r,
    listLanguages: i,
    register: o,
    registerAlias: s,
    registered: a
  };
  function n(l, c, d) {
    const u = d || Eh, f = typeof u.prefix == "string" ? u.prefix : VO;
    if (!e.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    e.configure({ __emitter: WO, classPrefix: f });
    const p = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      e.highlight(c, { ignoreIllegals: !0, language: l })
    );
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised
      });
    const h = p._emitter.root, m = (
      /** @type {RootData} */
      h.data
    );
    return m.language = p.language, m.relevance = p.relevance, h;
  }
  function r(l, c) {
    const u = (c || Eh).subset || i();
    let f = -1, p = 0, h;
    for (; ++f < u.length; ) {
      const m = u[f];
      if (!e.getLanguage(m)) continue;
      const g = n(m, l, c);
      g.data && g.data.relevance !== void 0 && g.data.relevance > p && (p = g.data.relevance, h = g);
    }
    return h || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: p }
    };
  }
  function i() {
    return e.listLanguages();
  }
  function o(l, c) {
    if (typeof l == "string")
      e.registerLanguage(l, c);
    else {
      let d;
      for (d in l)
        Object.hasOwn(l, d) && e.registerLanguage(d, l[d]);
    }
  }
  function s(l, c) {
    if (typeof l == "string")
      e.registerAliases(
        // Note: copy needed because hljs doesn’t accept readonly arrays yet.
        typeof c == "string" ? c : [...c],
        { languageName: l }
      );
    else {
      let d;
      for (d in l)
        if (Object.hasOwn(l, d)) {
          const u = l[d];
          e.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof u == "string" ? u : [...u],
            { languageName: d }
          );
        }
    }
  }
  function a(l) {
    return !!e.getLanguage(l);
  }
}
class WO {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(e) {
    this.options = e, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(e) {
    if (e === "") return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += e : n.children.push({ type: "text", value: e });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(e) {
    this.openNode(String(e));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(e, n) {
    const r = this.stack[this.stack.length - 1], i = (
      /** @type {Array<ElementContent>} */
      e.root.children
    );
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(e) {
    const n = this, r = e.split(".").map(function(s, a) {
      return a ? s + "_".repeat(a) : n.options.classPrefix + s;
    }), i = this.stack[this.stack.length - 1], o = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    i.children.push(o), this.stack.push(o);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const ZO = jO(zO), KO = /* @__PURE__ */ ve({
  __name: "index",
  props: {
    mode: {},
    content: { default: "" },
    modelValue: { default: "" }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, r = e, i = [
      dC.configure({
        orderedList: !1,
        bulletList: !1,
        blockquote: {
          HTMLAttributes: {
            class: "x-blockquote"
          }
        }
      }),
      ME.configure({
        HTMLAttributes: {
          class: "x-underline"
        }
      }),
      LE,
      RE.configure({
        multicolor: !0
      }),
      IE.configure({
        types: ["heading", "paragraph"]
      }),
      DE,
      ck.configure({
        openOnClick: !0,
        HTMLAttributes: {
          class: "x-link"
        }
      }),
      xk,
      Ak,
      $x,
      zx,
      Hx,
      Ik,
      Bk,
      Hk,
      Vk,
      KS.configure({ lowlight: ZO }),
      QS,
      nM,
      rM,
      F2,
      sM,
      bM
    ], o = U(0), s = u9({
      content: n.content || n.modelValue,
      extensions: i,
      onUpdate({ editor: d }) {
        c(d);
        const u = d.getHTML();
        r("update:modelValue", u);
      }
    }), a = U(!1), l = () => {
      a.value = !a.value;
    }, c = (d) => {
      const u = d.getText();
      o.value = u.length;
    };
    return Oh(() => n.modelValue, (d) => {
      s.value && d !== s.value.getHTML() && s.value.commands.setContent(d || "", !1);
    }, { immediate: !1 }), nr(q_, a.value), nr(l2, l), di(() => {
      c(s.value);
    }), (d, u) => se(s) ? (B(), he("div", {
      key: 0,
      class: lt(["vue3-tiptap", a.value ? "editor--fullscreen" : ""])
    }, [
      k(SE, { editor: se(s) }, {
        tool: R(() => [
          Vi(d.$slots, "tool", {}, void 0, !0)
        ]),
        _: 3
      }, 8, ["editor"]),
      k(se(c9), {
        editor: se(s),
        class: "editor"
      }, null, 8, ["editor"])
    ], 2)) : it("", !0);
  }
}), XO = /* @__PURE__ */ dt(KO, [["__scopeId", "data-v-76d6303b"]]);
export {
  XO as Vue3TipTap,
  XO as default
};
